
--- START FILE: index.html ---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mystic Vision - Inner Journey Companion</title>
    <link rel="stylesheet" href="style.css">
    <!-- Font Awesome 6 for modern icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Chart.js for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<body>
    <header>
        <div class="container">
            <h1>Mystic Vision</h1>
            <p>Your Path to Inner Harmony & Wisdom</p>
        </div>
    </header>

    <nav class="main-nav">
        <div class="container">
            <button class="nav-button active" data-section="dashboard-section"><i class="fas fa-home"></i> Home</button>
            <button class="nav-button" data-section="meditation-section"><i class="fas fa-om"></i> Meditation</button>
            <button class="nav-button" data-section="books-section"><i class="fas fa-book-reader"></i> Books</button>
            <button class="nav-button" data-section="statistics-section"><i class="fas fa-chart-line"></i> Stats</button>
            <button class="nav-button" data-section="goals-section"><i class="fas fa-bullseye"></i> Goals</button>
            <button class="nav-button" data-section="achievements-section"><i class="fas fa-trophy"></i> Achievements</button>
            <button class="nav-button" data-section="settings-section"><i class="fas fa-cog"></i> Settings</button>
        </div>
    </nav>

    <main class="container">
        <!-- Dashboard Section -->
        <section id="dashboard-section" class="app-section active-section">
            <div class="card dashboard-welcome">
                <h2>Welcome, Seeker!</h2>
                <p>A quick overview of your journey.</p>
                <div class="stats-grid">
                    <div><strong>Total Meditated:</strong> <span id="dash-total-med-time">0h 0m</span></div>
                    <div><strong>Sessions:</strong> <span id="dash-total-med-sessions">0</span></div>
                    <div><strong>Current Streak:</strong> <span id="dash-current-streak">0 days</span></div>
                    <div><strong>Books Read:</strong> <span id="dash-books-finished">0</span></div>
                </div>
            </div>
            <div class="card dashboard-recent-meds">
                <h3>Recent Meditations</h3>
                <ul id="dash-meditation-sessions-list">
                    <!-- Recent sessions will be dynamically added here -->
                </ul>
                <button class="btn-sm" onclick="showSection('meditation-section')">View All Meditations</button>
            </div>
            <div class="card dashboard-recent-reads">
                <h3>Currently Reading</h3>
                <ul id="dash-current-reading-list">
                    <!-- Currently reading books will be dynamically added here -->
                </ul>
                <button class="btn-sm" onclick="showSection('books-section')">View All Books</button>
            </div>
        </section>

        <!-- Meditation Section -->
        <section id="meditation-section" class="app-section">
            <div class="card meditation-timer-card">
                <h2><i class="fas fa-om"></i> Meditation Sanctuary</h2>
                <div class="timer-display" id="meditation-timer-display">00:00:00</div>
                <div class="preset-buttons">
                    <button class="preset-meditation-time btn-sm" data-minutes="5">5 min</button>
                    <button class="preset-meditation-time btn-sm" data-minutes="10">10 min</button>
                    <button class="preset-meditation-time btn-sm" data-minutes="20">20 min</button>
                    <button class="preset-meditation-time btn-sm" data-minutes="30">30 min</button>
                    <button id="open-interval-timer-btn" class="btn-sm"><i class="fas fa-clock"></i> Interval</button>
                </div>
                <div class="timer-controls">
                    <button id="start-meditation"><i class="fas fa-play"></i> Start</button>
                    <button id="pause-meditation" disabled><i class="fas fa-pause"></i> Pause</button>
                    <button id="stop-meditation" disabled><i class="fas fa-stop"></i> Stop</button>
                    <button id="reset-meditation"><i class="fas fa-redo-alt"></i> Reset</button>
                </div>

                <h3>Ambient Sounds</h3>
                <div class="sound-controls">
                    <select id="ambient-sound-selector" class="input-field">
                        <option value="none">None</option>
                        <option value="rain">Rain</option>
                        <option value="forest">Forest</option>
                        <option value="ocean">Ocean Waves</option>
                        <option value="chimes">Wind Chimes</option>
                    </select>
                    <input type="range" id="ambient-volume" min="0" max="1" step="0.05" value="0.5">
                </div>
            </div>

            <div class="card meditation-history-card">
                <h3><i class="fas fa-history"></i> Your Meditation Journey</h3>
                <ul id="meditation-sessions-list">
                    <!-- Meditation sessions will be dynamically added here -->
                </ul>
            </div>
        </section>

        <!-- Spiritual Books Section -->
        <section id="books-section" class="app-section">
            <div class="card">
                <h2><i class="fas fa-book-reader"></i> Wisdom Scrolls</h2>
                <div class="book-input-area">
                    <input type="file" id="new-book-cover" accept="image/*" style="display: none;">
                    <button id="upload-book-cover-btn" class="btn-icon" title="Upload Cover Image"><i class="fas fa-image"></i></button>
                    <input type="text" id="new-book-title" placeholder="Book Title" class="input-field">
                    <input type="text" id="new-book-author" placeholder="Author (optional)" class="input-field">
                    <input type="number" id="new-book-pages" placeholder="Total Pages (optional)" class="input-field small-input">
                    <input type="text" id="new-book-genre" placeholder="Genre (optional, e.g., Spiritual, Philosophy)" class="input-field">
                    <button id="add-book"><i class="fas fa-plus"></i> Add Book</button>
                </div>
                <div class="search-input-area">
                    <input type="text" id="book-search-input" placeholder="Search books by title, author, or genre..." class="input-field">
                    <button id="clear-book-search" class="btn-icon"><i class="fas fa-times"></i></button>
                </div>
                <h3>Your Spiritual Library</h3>
                <ul id="books-list">
                    <!-- Books will be dynamically added here -->
                </ul>
            </div>
        </section>

        <!-- Statistics Section -->
        <section id="statistics-section" class="app-section">
            <div class="card card-full-width">
                <h2><i class="fas fa-chart-line"></i> Meditation Statistics</h2>
                <h3>Daily Meditation Time Trend</h3>
                <canvas id="meditationTimeChart"></canvas>
                <h3>Meditation Session Count</h3>
                <canvas id="meditationSessionsChart"></canvas>
                <h3>Mood Distribution</h3>
                <canvas id="moodDistributionChart"></canvas>
                <h3>Top Meditation Tags</h3>
                <canvas id="topTagsChart"></canvas>
            </div>
            <div class="card card-full-width">
                <h2><i class="fas fa-chart-pie"></i> Book Reading Statistics</h2>
                <h3>Reading Time by Book</h3>
                <canvas id="bookReadingTimeChart"></canvas>
            </div>
            <div class="card card-full-width">
                <h2><i class="fas fa-calendar-alt"></i> Meditation Calendar</h2>
                <div id="meditation-calendar" class="meditation-calendar"></div>
            </div>
        </section>

        <!-- Goals Section -->
        <section id="goals-section" class="app-section">
            <div class="card">
                <h2><i class="fas fa-bullseye"></i> Your Goals</h2>
                <div class="goal-input-area">
                    <select id="goal-type" class="input-field small-input">
                        <option value="meditation_duration">Meditation Duration</option>
                        <option value="meditation_days">Meditation Days</option>
                        <option value="books_finished">Books Finished</option>
                    </select>
                    <input type="number" id="goal-value" placeholder="Target Value" class="input-field small-input" min="1">
                    <select id="goal-period" class="input-field small-input">
                        <option value="week">Per Week</option>
                        <option value="month">Per Month</option>
                        <option value="overall">Overall</option>
                    </select>
                    <button id="add-goal"><i class="fas fa-plus"></i> Add Goal</button>
                </div>
                <h3>Active Goals</h3>
                <ul id="active-goals-list">
                    <!-- Active goals will be dynamically added here -->
                </ul>
                <h3>Completed Goals</h3>
                <ul id="completed-goals-list">
                    <!-- Completed goals will be dynamically added here -->
                </ul>
            </div>
        </section>

        <!-- Achievements Section -->
        <section id="achievements-section" class="app-section">
            <div class="card card-full-width">
                <h2><i class="fas fa-trophy"></i> Your Achievements</h2>
                <div id="achievements-grid" class="achievements-grid">
                    <!-- Achievements will be dynamically added here -->
                </div>
            </div>
        </section>

        <!-- Settings Section -->
        <section id="settings-section" class="app-section">
            <div class="card">
                <h2><i class="fas fa-cog"></i> Settings</h2>
                <div class="setting-item">
                    <span>Theme:</span>
                    <select id="theme-selector" class="input-field small-input">
                        <option value="light">Light (Serene)</option>
                        <option value="dark">Dark (Mystic Night)</option>
                        <option value="cosmic">Cosmic Whisper</option>
                        <option value="forest">Forest Bloom</option>
                    </select>
                </div>
                <div class="setting-item">
                    <span>Custom Background Image:</span>
                    <input type="file" id="custom-background-file" accept="image/*" style="display: none;">
                    <button id="upload-custom-background-btn"><i class="fas fa-upload"></i> Upload Image</button>
                    <button id="clear-custom-background-btn" class="delete-button btn-sm"><i class="fas fa-times"></i> Clear</button>
                </div>
                <hr>
                <div class="setting-item">
                    <span>End Meditation Bell Sound:</span>
                    <label class="switch">
                        <input type="checkbox" id="bell-sound-toggle">
                        <span class="slider round"></span>
                    </label>
                </div>
                <div class="setting-item">
                    <span>Bell Volume:</span>
                    <input type="range" id="bell-volume" min="0" max="1" step="0.05" value="0.5">
                </div>
                <div class="setting-item">
                    <span>Daily Meditation Reminder:</span>
                    <input type="time" id="daily-reminder-time" class="input-field small-input">
                    <button id="set-daily-reminder-btn" class="btn-sm"><i class="fas fa-bell"></i> Set</button>
                    <button id="clear-daily-reminder-btn" class="delete-button btn-sm"><i class="fas fa-times"></i> Clear</button>
                </div>
                <hr>
                <div class="setting-item data-management-buttons">
                    <button id="export-data-btn" class="export-button"><i class="fas fa-download"></i> Export Data</button>
                    <input type="file" id="import-data-file" accept=".json" style="display: none;">
                    <button id="import-data-btn" class="import-button"><i class="fas fa-upload"></i> Import Data</button>
                    <button id="clear-all-data-btn" class="delete-button"><i class="fas fa-trash-alt"></i> Clear All Data</button>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; <span id="current-year"></span> Mystic Vision. All rights reserved.</p>
        </div>
    </footer>

    <!-- Modals -->

    <!-- Meditation Journal Modal -->
    <div id="meditation-journal-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" data-modal="meditation-journal-modal">&times;</span>
            <h2>Meditation Reflection</h2>
            <div class="journal-meta">
                <div class="mood-tracker">
                    <h4>Mood:</h4>
                    <div class="mood-emojis">
                        <span class="emoji" data-mood="calm">😌</span>
                        <span class="emoji" data-mood="focused">🧐</span>
                        <span class="emoji" data-mood="peaceful">🕊️</span>
                        <span class="emoji" data-mood="energetic">⚡</span>
                        <span class="emoji" data-mood="tired">😴</span>
                        <span class="emoji" data-mood="anxious">😟</span>
                        <span class="emoji" data-mood="happy">😊</span>
                    </div>
                </div>
                <div class="energy-tracker">
                    <h4>Energy Level:</h4>
                    <input type="range" id="energy-level" min="0" max="10" value="5" class="slider-energy">
                    <span id="energy-value">5</span>
                </div>
            </div>
            <h4>Tags:</h4>
            <input type="text" id="journal-tags-input" placeholder="Add tags (e.g., stress, focus, morning)" class="input-field">
            <h4>Thoughts & Insights:</h4>
            <textarea id="journal-text" placeholder="Write down your thoughts, insights, or feelings..."></textarea>
            <h4>Gratitude:</h4>
            <textarea id="gratitude-text" placeholder="What are you grateful for today?"></textarea>
            <button id="save-journal-entry">Save Reflection</button>
        </div>
    </div>

    <!-- Book Details/Notes Modal -->
    <div id="book-details-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" data-modal="book-details-modal">&times;</span>
            <div class="book-modal-header">
                <img id="modal-book-cover-img" src="./img/default_book.png" alt="Book Cover" class="modal-book-cover">
                <div>
                    <h2 id="modal-book-title"></h2>
                    <p><strong>Author:</strong> <span id="modal-book-author"></span></p>
                    <p><strong>Genre:</strong> <span id="modal-book-genre"></span></p>
                    <p><strong>Status:</strong> <span id="modal-book-status"></span></p>
                    <div class="book-rating" id="modal-book-rating">
                        <!-- Stars will be dynamically added here -->
                    </div>
                </div>
            </div>
            
            <div class="book-modal-progress">
                <p><strong>Total Pages:</strong> <span id="modal-book-total-pages"></span></p>
                <label for="modal-book-current-page"><strong>Current Page:</strong></label>
                <input type="number" id="modal-book-current-page" class="input-field small-input">
                <p><strong>Progress:</strong> <span id="modal-book-progress">0%</span></p>
                <div class="progress-bar-container"><div class="progress-bar" id="modal-progress-bar"></div></div>
                <p><strong>Total Reading Time:</strong> <span id="modal-book-total-reading-time">0h 0m</span></p>
            </div>
            
            <h3>Notes</h3>
            <textarea id="modal-book-notes-input" placeholder="Add a new note..."></textarea>
            <button id="add-book-note-btn">Add Note</button>
            <ul id="modal-book-notes-list">
                <!-- Book notes will be dynamically added here -->
            </ul>
        </div>
    </div>

    <!-- Interval Timer Setup Modal -->
    <div id="interval-timer-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" data-modal="interval-timer-modal">&times;</span>
            <h2><i class="fas fa-clock"></i> Set Up Interval Meditation</h2>
            <div id="interval-steps-container">
                <!-- Interval steps will be dynamically added here -->
            </div>
            <button id="add-interval-step" class="btn-sm"><i class="fas fa-plus"></i> Add Step</button>
            <button id="start-interval-meditation">Start Interval Meditation</button>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmation-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" data-modal="confirmation-modal">&times;</span>
            <h2>Confirm Action</h2>
            <p id="confirmation-message"></p>
            <div class="modal-actions">
                <button id="confirm-action-btn" class="delete-button">Confirm</button>
                <button id="cancel-action-btn" class="secondary-button">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Toast Notifications Container -->
    <div id="toast-container"></div>

    <script src="script.js"></script>
</body>
</html>

--- END FILE: index.html ---

--- START FILE: script.js ---

document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements Cache ---
    const elements = {
        // Main Navigation
        navButtons: document.querySelectorAll('.nav-button'),
        appSections: document.querySelectorAll('.app-section'),

        // Dashboard
        dashTotalMedTime: document.getElementById('dash-total-med-time'),
        dashTotalMedSessions: document.getElementById('dash-total-med-sessions'),
        dashCurrentStreak: document.getElementById('dash-current-streak'),
        dashBooksFinished: document.getElementById('dash-books-finished'),
        dashMeditationSessionsList: document.getElementById('dash-meditation-sessions-list'),
        dashCurrentReadingList: document.getElementById('dash-current-reading-list'),

        // Meditation Section
        meditationTimerDisplay: document.getElementById('meditation-timer-display'),
        startMeditationBtn: document.getElementById('start-meditation'),
        pauseMeditationBtn: document.getElementById('pause-meditation'),
        stopMeditationBtn: document.getElementById('stop-meditation'),
        resetMeditationBtn: document.getElementById('reset-meditation'),
        presetMeditationButtons: document.querySelectorAll('.preset-meditation-time'),
        meditationSessionsList: document.getElementById('meditation-sessions-list'),
        openIntervalTimerBtn: document.getElementById('open-interval-timer-btn'),
        ambientSoundSelector: document.getElementById('ambient-sound-selector'),
        ambientVolumeControl: document.getElementById('ambient-volume'),
        
        // Book Section
        newBookCoverInput: document.getElementById('new-book-cover'),
        uploadBookCoverBtn: document.getElementById('upload-book-cover-btn'),
        newBookTitleInput: document.getElementById('new-book-title'),
        newBookAuthorInput: document.getElementById('new-book-author'),
        newBookPagesInput: document.getElementById('new-book-pages'),
        newBookGenreInput: document.getElementById('new-book-genre'),
        addBookBtn: document.getElementById('add-book'),
        booksList: document.getElementById('books-list'),
        bookSearchInput: document.getElementById('book-search-input'),
        clearBookSearchBtn: document.getElementById('clear-book-search'),

        // Statistics Section
        meditationTimeChartCanvas: document.getElementById('meditationTimeChart'),
        meditationSessionsChartCanvas: document.getElementById('meditationSessionsChart'),
        moodDistributionChartCanvas: document.getElementById('moodDistributionChart'),
        topTagsChartCanvas: document.getElementById('topTagsChart'),
        bookReadingTimeChartCanvas: document.getElementById('bookReadingTimeChart'),
        meditationCalendar: document.getElementById('meditation-calendar'),

        // Goals Section
        goalTypeSelect: document.getElementById('goal-type'),
        goalValueInput: document.getElementById('goal-value'),
        goalPeriodSelect: document.getElementById('goal-period'),
        addGoalBtn: document.getElementById('add-goal'),
        activeGoalsList: document.getElementById('active-goals-list'),
        completedGoalsList: document.getElementById('completed-goals-list'),

        // Achievements Section
        achievementsGrid: document.getElementById('achievements-grid'),

        // Settings Section
        themeSelector: document.getElementById('theme-selector'),
        customBackgroundFileInput: document.getElementById('custom-background-file'),
        uploadCustomBackgroundBtn: document.getElementById('upload-custom-background-btn'),
        clearCustomBackgroundBtn: document.getElementById('clear-custom-background-btn'),
        bellSoundToggle: document.getElementById('bell-sound-toggle'),
        bellVolumeControl: document.getElementById('bell-volume'),
        dailyReminderTimeInput: document.getElementById('daily-reminder-time'),
        setDailyReminderBtn: document.getElementById('set-daily-reminder-btn'),
        clearDailyReminderBtn: document.getElementById('clear-daily-reminder-btn'),
        exportDataBtn: document.getElementById('export-data-btn'),
        importDataFile: document.getElementById('import-data-file'),
        importDataBtn: document.getElementById('import-data-btn'),
        clearAllDataBtn: document.getElementById('clear-all-data-btn'),

        // Modals
        meditationJournalModal: document.getElementById('meditation-journal-modal'),
        journalMoodEmojis: document.querySelectorAll('.mood-emojis .emoji'),
        journalEnergyLevel: document.getElementById('energy-level'),
        journalEnergyValue: document.getElementById('energy-value'),
        journalTagsInput: document.getElementById('journal-tags-input'),
        journalTextInput: document.getElementById('journal-text'),
        gratitudeTextInput: document.getElementById('gratitude-text'),
        saveJournalEntryBtn: document.getElementById('save-journal-entry'),

        bookDetailsModal: document.getElementById('book-details-modal'),
        modalBookCoverImg: document.getElementById('modal-book-cover-img'),
        modalBookTitle: document.getElementById('modal-book-title'),
        modalBookAuthor: document.getElementById('modal-book-author'),
        modalBookGenre: document.getElementById('modal-book-genre'),
        modalBookStatus: document.getElementById('modal-book-status'),
        modalBookRating: document.getElementById('modal-book-rating'),
        modalBookTotalPages: document.getElementById('modal-book-total-pages'),
        modalBookCurrentPage: document.getElementById('modal-book-current-page'),
        modalBookProgress: document.getElementById('modal-book-progress'),
        modalProgressBar: document.getElementById('modal-progress-bar'),
        modalBookTotalReadingTime: document.getElementById('modal-book-total-reading-time'),
        modalBookNotesInput: document.getElementById('modal-book-notes-input'),
        addBookNoteBtn: document.getElementById('add-book-note-btn'),
        modalBookNotesList: document.getElementById('modal-book-notes-list'),

        intervalTimerModal: document.getElementById('interval-timer-modal'),
        intervalStepsContainer: document.getElementById('interval-steps-container'),
        addIntervalStepBtn: document.getElementById('add-interval-step'),
        startIntervalMeditationBtn: document.getElementById('start-interval-meditation'),

        confirmationModal: document.getElementById('confirmation-modal'),
        confirmationMessage: document.getElementById('confirmation-message'),
        confirmActionBtn: document.getElementById('confirm-action-btn'),
        cancelActionBtn: document.getElementById('cancel-action-btn'),

        closeButtons: document.querySelectorAll('.close-button'),
        toastContainer: document.getElementById('toast-container')
    };

    // --- Global State Variables ---
    let meditationTimerInterval;
    let meditationStartTime = 0;
    let meditationElapsedTime = 0;
    let meditationPaused = false;
    let meditationDurationTarget = 0; // In milliseconds, for presets & intervals
    let meditationType = 'standard'; // 'standard' or 'interval'
    let currentIntervalIndex = 0;
    let intervalTimerSteps = []; // [{duration, sound, label}]

    let currentReadingBookId = null;
    let bookReadingTimerInterval;
    let bookReadingStartTime = 0;

    // --- Data Structures (Persisted in localStorage) ---
    // meditationSessions: [{ id, startTime, endTime, durationMs, date, journalEntry?, mood?, energy?, tags?, type? }]
    let meditationSessions = loadData('meditationSessions', []);

    // books: [{ id, title, author, totalPages, currentPage, readingSessions: [{ startTime, endTime, durationMs }], notes: [{ id, text, date }], coverImage?, status?, rating?, genre? }]
    let books = loadData('books', []);

    // goals: [{ id, type, value, period, currentProgress, completed, startDate, endDate? }]
    let goals = loadData('goals', []);

    // settings: { theme, bellSound, bellVolume, ambientSound, ambientVolume, dailyReminderTime, customBackground }
    let settings = loadData('settings', {
        theme: 'light',
        bellSound: true,
        bellVolume: 0.5,
        ambientSound: 'none',
        ambientVolume: 0.5,
        dailyReminderTime: '',
        customBackground: null
    });

    // --- Audio Context & Buffers ---
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const soundBuffers = {}; // To store loaded audio buffers
    const ambientSoundSources = {}; // To store active ambient sound sources
    let bellSoundVolumeNode, ambientSoundVolumeNode;

    const BELL_SOUND_URL = 'https://freesound.org/data/previews/203/203061_2112423-lq.mp3'; // Example bell
    const AMBIENT_SOUND_URLS = {
        rain: 'https://freesound.org/data/previews/25/25010_25086-lq.mp3', // Example rain
        forest: 'https://freesound.org/data/previews/140/140645_1955038-lq.mp3', // Example forest birds
        ocean: 'https://freesound.org/data/previews/165/165780_2984100-lq.mp3', // Example ocean waves
        chimes: 'https://freesound.org/data/previews/131/131652_2415714-lq.mp3' // Example wind chimes
    };

    // --- Charts ---
    let meditationTimeChart, meditationSessionsChart, moodDistributionChart, topTagsChart, bookReadingTimeChart;


    // --- Utility Functions ---

    /**
     * Loads data from localStorage or returns a default value.
     * @param {string} key
     * @param {any} defaultValue
     * @returns {any}
     */
    function loadData(key, defaultValue) {
        try {
            const data = localStorage.getItem(key);
            return data ? JSON.parse(data) : defaultValue;
        } catch (e) {
            console.error(`Error loading data for key ${key}:`, e);
            showToast('Error loading data: Local storage might be corrupted.', 'error');
            return defaultValue;
        }
    }

    /**
     * Saves data to localStorage.
     * @param {string} key
     * @param {any} data
     */
    function saveData(key, data) {
        try {
            localStorage.setItem(key, JSON.stringify(data));
        } catch (e) {
            console.error(`Error saving data for key ${key}:`, e);
            showToast('Not enough storage space. Please clear some data.', 'error');
        }
    }

    /**
     * Formats milliseconds into HH:MM:SS string.
     * @param {number} ms
     * @returns {string}
     */
    function formatTime(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        return [hours, minutes, seconds]
            .map(unit => String(unit).padStart(2, '0'))
            .join(':');
    }

    /**
     * Formats milliseconds into human-readable hours and minutes.
     * @param {number} ms
     * @returns {string}
     */
    function formatDuration(ms) {
        if (ms === 0) return '0m';
        const totalMinutes = Math.floor(ms / (1000 * 60));
        const hours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;
        if (hours > 0) {
            return `${hours}h ${minutes}m`;
        }
        return `${minutes}m`;
    }

    /**
     * Generates a unique ID.
     * @returns {string}
     */
    function generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
    }

    /**
     * Opens a modal.
     * @param {HTMLElement} modalElement
     */
    function openModal(modalElement) {
        modalElement.style.display = 'block';
        document.body.classList.add('modal-open');
    }

    /**
     * Closes a modal.
     * @param {HTMLElement} modalElement
     */
    function closeModal(modalElement) {
        modalElement.style.display = 'none';
        document.body.classList.remove('modal-open');
    }

    /**
     * Shows a toast notification.
     * @param {string} message
     * @param {string} type 'success', 'error', 'info'
     */
    function showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        let icon = '';
        if (type === 'success') icon = '<i class="fas fa-check-circle"></i>';
        else if (type === 'error') icon = '<i class="fas fa-exclamation-triangle"></i>';
        else icon = '<i class="fas fa-info-circle"></i>';

        toast.innerHTML = `${icon} <span>${message}</span>`;
        elements.toastContainer.appendChild(toast);

        setTimeout(() => {
            toast.classList.add('show');
        }, 10); // Small delay to trigger transition

        setTimeout(() => {
            toast.classList.remove('show');
            toast.classList.add('hide');
            toast.addEventListener('transitionend', () => toast.remove(), { once: true });
        }, 3000);
    }

    // --- Audio Functions ---
    async function loadSound(url, name) {
        try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            soundBuffers[name] = await audioContext.decodeAudioData(arrayBuffer);
            // console.log(`Sound ${name} loaded.`);
        } catch (error) {
            console.error(`Error loading sound ${name}:`, error);
            showToast(`Could not load sound: ${name}.`, 'error');
        }
    }

    function playSound(buffer, volumeNode, loop = false) {
        if (!buffer) return null;

        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.loop = loop;
        source.connect(volumeNode);
        volumeNode.connect(audioContext.destination);
        source.start(0);
        return source;
    }

    function stopSound(source) {
        if (source) {
            try {
                source.stop();
                source.disconnect();
            } catch (e) {
                // Already stopped or disconnected
            }
        }
    }

    function updateVolumeNodes() {
        if (!bellSoundVolumeNode) {
            bellSoundVolumeNode = audioContext.createGain();
            ambientSoundVolumeNode = audioContext.createGain();
        }
        bellSoundVolumeNode.gain.value = settings.bellSound ? settings.bellVolume : 0;
        ambientSoundVolumeNode.gain.value = settings.ambientVolume;
    }

    function stopAllAmbientSounds() {
        for (const key in ambientSoundSources) {
            stopSound(ambientSoundSources[key]);
            delete ambientSoundSources[key];
        }
    }

    function startAmbientSound(soundName) {
        stopAllAmbientSounds();
        if (soundName !== 'none' && soundBuffers[soundName]) {
            ambientSoundSources[soundName] = playSound(soundBuffers[soundName], ambientSoundVolumeNode, true);
        }
    }


    // --- Meditation Logic ---

    function startMeditationTimer(durationMinutes = 0, type = 'standard') {
        if (meditationTimerInterval) return;

        meditationDurationTarget = durationMinutes * 60 * 1000;
        meditationType = type;

        if (!meditationPaused) {
            meditationStartTime = Date.now();
            meditationElapsedTime = 0;
            currentIntervalIndex = 0; // Reset for new session
        } else {
            meditationStartTime = Date.now() - meditationElapsedTime;
            meditationPaused = false;
        }

        updateMeditationButtonStates(true, false, false);
        startAmbientSound(settings.ambientSound);

        meditationTimerInterval = setInterval(() => {
            meditationElapsedTime = Date.now() - meditationStartTime;
            elements.meditationTimerDisplay.textContent = formatTime(meditationElapsedTime);

            if (meditationType === 'standard' && meditationDurationTarget > 0 && meditationElapsedTime >= meditationDurationTarget) {
                stopMeditationTimer();
                playSound(soundBuffers['bell'], bellSoundVolumeNode);
                showToast('Meditation session completed!', 'success');
            } else if (meditationType === 'interval' && intervalTimerSteps.length > 0) {
                const totalIntervalDuration = intervalTimerSteps.slice(0, currentIntervalIndex + 1).reduce((sum, step) => sum + (step.duration * 1000), 0);

                if (meditationElapsedTime >= totalIntervalDuration) {
                    currentIntervalIndex++;
                    if (currentIntervalIndex < intervalTimerSteps.length) {
                        const nextStep = intervalTimerSteps[currentIntervalIndex];
                        playSound(soundBuffers[nextStep.sound], bellSoundVolumeNode);
                        showToast(`Next Interval: ${nextStep.label} (${nextStep.duration}s)`, 'info');
                    } else {
                        stopMeditationTimer();
                        playSound(soundBuffers['bell'], bellSoundVolumeNode);
                        showToast('Interval meditation completed!', 'success');
                    }
                }
            }
        }, 1000);
    }

    function pauseMeditationTimer() {
        if (!meditationTimerInterval) return;
        clearInterval(meditationTimerInterval);
        meditationTimerInterval = null;
        meditationPaused = true;
        updateMeditationButtonStates(false, true, false);
        stopAllAmbientSounds();
        showToast('Meditation paused.', 'info');
    }

    function stopMeditationTimer() {
        if (!meditationTimerInterval && !meditationPaused) return;

        clearInterval(meditationTimerInterval);
        meditationTimerInterval = null;
        stopAllAmbientSounds();

        const durationMs = meditationElapsedTime;

        if (durationMs > 5000) {
            const session = {
                id: generateId(),
                startTime: meditationStartTime,
                endTime: Date.now(),
                durationMs: durationMs,
                date: new Date(meditationStartTime).toDateString(),
                type: meditationType,
                mood: null,
                energy: null,
                tags: [],
                journalEntry: '',
                gratitudeEntry: ''
            };
            meditationSessions.push(session);
            saveData('meditationSessions', meditationSessions);
            renderMeditationSessions();
            updateMeditationStats();
            updateAchievements();
            updateGoals();
            openMeditationJournalModal(session.id);
            showToast('Meditation session recorded!', 'success');
        } else {
            showToast('Meditation session was too short to record (>5s required).', 'info');
        }

        resetMeditationDisplay();
    }

    function resetMeditationDisplay() {
        clearInterval(meditationTimerInterval);
        meditationTimerInterval = null;
        meditationStartTime = 0;
        meditationElapsedTime = 0;
        meditationPaused = false;
        meditationDurationTarget = 0;
        meditationType = 'standard';
        currentIntervalIndex = 0;
        stopAllAmbientSounds();
        elements.meditationTimerDisplay.textContent = '00:00:00';
        updateMeditationButtonStates(false, true, true);
    }

    function updateMeditationButtonStates(isTimerRunning, isTimerPaused, isTimerReset) {
        elements.startMeditationBtn.disabled = isTimerRunning && !isTimerPaused;
        elements.pauseMeditationBtn.disabled = !isTimerRunning || isTimerPaused;
        elements.stopMeditationBtn.disabled = !isTimerRunning && !isTimerPaused;
        elements.resetMeditationBtn.disabled = !isTimerRunning && !isTimerPaused;
        elements.presetMeditationButtons.forEach(btn => btn.disabled = isTimerRunning);
        elements.openIntervalTimerBtn.disabled = isTimerRunning;
    }

    function renderMeditationSessions() {
        elements.meditationSessionsList.innerHTML = ''; // Clear all
        elements.dashMeditationSessionsList.innerHTML = ''; // Clear dashboard

        const sortedSessions = [...meditationSessions].sort((a, b) => b.startTime - a.startTime);

        if (sortedSessions.length === 0) {
            elements.meditationSessionsList.innerHTML = '<li>No meditation sessions recorded yet. Start your journey!</li>';
        }

        sortedSessions.forEach(session => {
            const li = document.createElement('li');
            const date = new Date(session.startTime);
            const tags = session.tags && session.tags.length > 0 ? `<br><small>Tags: ${session.tags.join(', ')}</small>` : '';
            li.innerHTML = `
                <div>
                    <span>${date.toLocaleDateString()} at ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>
                    <br><strong>${formatDuration(session.durationMs)}</strong> (${session.type === 'interval' ? 'Interval' : 'Standard'})
                    ${session.mood ? `<span class="session-mood-emoji" title="Mood: ${session.mood}"> ${getEmojiForMood(session.mood)}</span>` : ''}
                    ${tags}
                </div>
                <button class="view-journal-btn btn-sm" data-session-id="${session.id}" title="View/Edit Journal"><i class="fas fa-feather-alt"></i></button>
            `;
            elements.meditationSessionsList.appendChild(li);
        });

        // Dashboard recent sessions (limit to 3)
        if (sortedSessions.length > 0) {
            sortedSessions.slice(0, 3).forEach(session => {
                const li = document.createElement('li');
                const date = new Date(session.startTime);
                li.innerHTML = `
                    <span>${date.toLocaleDateString()}: ${formatDuration(session.durationMs)}</span>
                    ${session.mood ? `<span class="session-mood-emoji" title="Mood: ${session.mood}"> ${getEmojiForMood(session.mood)}</span>` : ''}
                `;
                elements.dashMeditationSessionsList.appendChild(li);
            });
        } else {
            elements.dashMeditationSessionsList.innerHTML = '<li>No recent meditations.</li>';
        }

        document.querySelectorAll('.view-journal-btn').forEach(btn => {
            btn.onclick = (e) => openMeditationJournalModal(e.currentTarget.dataset.sessionId);
        });
    }

    function updateMeditationStats() {
        const totalDurationMs = meditationSessions.reduce((sum, session) => sum + session.durationMs, 0);
        const uniqueDates = new Set(meditationSessions.map(session => session.date));
        const avgDurationMs = meditationSessions.length > 0 ? totalDurationMs / meditationSessions.length : 0;

        const { currentStreak, longestStreak } = calculateStreaks();

        // Update Dashboard Stats
        elements.dashTotalMedTime.textContent = formatDuration(totalDurationMs);
        elements.dashTotalMedSessions.textContent = meditationSessions.length;
        elements.dashCurrentStreak.textContent = `${currentStreak} days`;
        
        // Update Chart.js data and re-render
        renderMeditationCharts();
        renderMeditationCalendar();
    }

    function calculateStreaks() {
        if (meditationSessions.length === 0) {
            return { currentStreak: 0, longestStreak: 0 };
        }

        const sortedDates = [...new Set(meditationSessions
            .map(session => new Date(session.startTime).toDateString()))]
            .sort((a, b) => new Date(a) - new Date(b));

        let currentStreak = 0;
        let longestStreak = 0;
        let lastDate = null;
        let tempCurrentStreak = 0;

        sortedDates.forEach(dateStr => {
            const currentDate = new Date(dateStr);
            if (lastDate === null) {
                tempCurrentStreak = 1;
            } else {
                const dayDiff = Math.round((currentDate - lastDate) / (1000 * 60 * 60 * 24));
                if (dayDiff === 1) {
                    tempCurrentStreak++;
                } else if (dayDiff > 1) {
                    tempCurrentStreak = 1;
                }
            }
            longestStreak = Math.max(longestStreak, tempCurrentStreak);
            lastDate = currentDate;
        });

        const today = new Date();
        today.setHours(0,0,0,0);
        const yesterday = new Date(today);
        yesterday.setDate(today.getDate() - 1);

        const latestMedDate = sortedDates.length > 0 ? new Date(sortedDates[sortedDates.length - 1]) : null;

        if (latestMedDate) {
            latestMedDate.setHours(0,0,0,0);
            if (latestMedDate.getTime() === today.getTime()) {
                currentStreak = tempCurrentStreak;
            } else if (latestMedDate.getTime() === yesterday.getTime()) {
                let streakFromYesterday = 0;
                let tempLastDate = null;
                for (let i = sortedDates.length - 1; i >= 0; i--) {
                    const d = new Date(sortedDates[i]);
                    d.setHours(0,0,0,0);
                    if (tempLastDate === null) {
                        if (d.getTime() === yesterday.getTime()) {
                            streakFromYesterday = 1;
                        } else {
                            break;
                        }
                    } else {
                        const dayDiff = Math.round((tempLastDate - d) / (1000 * 60 * 60 * 24));
                        if (dayDiff === 1) {
                            streakFromYesterday++;
                        } else {
                            break;
                        }
                    }
                    tempLastDate = d;
                }
                currentStreak = streakFromYesterday;
            } else {
                currentStreak = 0;
            }
        } else {
            currentStreak = 0;
        }

        return { currentStreak, longestStreak };
    }

    function openMeditationJournalModal(sessionId) {
        const session = meditationSessions.find(s => s.id === sessionId);
        if (session) {
            // Reset mood selection
            elements.journalMoodEmojis.forEach(emoji => emoji.classList.remove('selected'));
            if (session.mood) {
                const selectedEmoji = document.querySelector(`.mood-emojis .emoji[data-mood="${session.mood}"]`);
                if (selectedEmoji) selectedEmoji.classList.add('selected');
            }

            elements.journalEnergyLevel.value = session.energy !== null ? session.energy : 5;
            elements.journalEnergyValue.textContent = elements.journalEnergyLevel.value;

            elements.journalTagsInput.value = session.tags ? session.tags.join(', ') : '';
            elements.journalTextInput.value = session.journalEntry || '';
            elements.gratitudeTextInput.value = session.gratitudeEntry || '';

            saveJournalEntryBtn.onclick = () => {
                session.mood = document.querySelector('.mood-emojis .emoji.selected')?.dataset.mood || null;
                session.energy = parseInt(elements.journalEnergyLevel.value, 10);
                session.tags = elements.journalTagsInput.value.split(',').map(tag => tag.trim()).filter(tag => tag);
                session.journalEntry = elements.journalTextInput.value.trim();
                session.gratitudeEntry = elements.gratitudeTextInput.value.trim();

                saveData('meditationSessions', meditationSessions);
                closeModal(elements.meditationJournalModal);
                renderMeditationSessions(); // Re-render to show mood/tags
                updateMeditationStats(); // Re-render charts
                showToast('Journal entry saved!', 'success');
            };
            openModal(elements.meditationJournalModal);
        }
    }

    function getEmojiForMood(mood) {
        switch (mood) {
            case 'calm': return '😌';
            case 'focused': return '🧐';
            case 'peaceful': return '🕊️';
            case 'energetic': return '⚡';
            case 'tired': return '😴';
            case 'anxious': return '😟';
            case 'happy': return '😊';
            default: return '';
        }
    }

    function addIntervalStep() {
        const stepCount = elements.intervalStepsContainer.children.length;
        const div = document.createElement('div');
        div.className = 'interval-step';
        div.innerHTML = `
            <label>Step ${stepCount + 1}:</label>
            <input type="number" value="60" min="5" placeholder="Seconds" data-type="duration">s
            <select data-type="sound">
                <option value="bell">Bell</option>
                <option value="chimes">Chimes</option>
            </select>
            <input type="text" placeholder="Label (e.g., Focus)" data-type="label">
            <button class="delete-step-btn delete-button btn-sm"><i class="fas fa-times"></i></button>
        `;
        elements.intervalStepsContainer.appendChild(div);
        div.querySelector('.delete-step-btn').onclick = (e) => e.target.closest('.interval-step').remove();
    }

    function getIntervalStepsFromUI() {
        const steps = [];
        elements.intervalStepsContainer.querySelectorAll('.interval-step').forEach(stepDiv => {
            const duration = parseInt(stepDiv.querySelector('[data-type="duration"]').value, 10);
            const sound = stepDiv.querySelector('[data-type="sound"]').value;
            const label = stepDiv.querySelector('[data-type="label"]').value || `Step ${steps.length + 1}`;
            if (!isNaN(duration) && duration > 0) {
                steps.push({ duration, sound, label });
            }
        });
        return steps;
    }

    // --- Book Tracking Logic ---

    let newBookCoverBase64 = null; // Store base64 of selected cover image

    function addBook() {
        const title = elements.newBookTitleInput.value.trim();
        const author = elements.newBookAuthorInput.value.trim();
        const totalPages = parseInt(elements.newBookPagesInput.value, 10);
        const genre = elements.newBookGenreInput.value.trim();

        if (!title) {
            showToast('Please enter a book title!', 'error');
            return;
        }

        books.push({
            id: generateId(),
            title: title,
            author: author || 'Unknown Author',
            totalPages: isNaN(totalPages) || totalPages < 0 ? 0 : totalPages,
            currentPage: 0,
            readingSessions: [],
            notes: [],
            coverImage: newBookCoverBase64,
            status: 'Want to Read',
            rating: 0,
            genre: genre
        });
        saveData('books', books);
        elements.newBookTitleInput.value = '';
        elements.newBookAuthorInput.value = '';
        elements.newBookPagesInput.value = '';
        elements.newBookGenreInput.value = '';
        newBookCoverBase64 = null; // Clear selected cover
        elements.uploadBookCoverBtn.innerHTML = '<i class="fas fa-image"></i>'; // Reset button icon
        renderBooks();
        updateBookStatistics();
        updateAchievements();
        updateGoals();
        showToast('Book added successfully!', 'success');
    }

    function startBookReading(bookId) {
        if (currentReadingBookId) {
            showToast('Please stop reading the current book before starting another.', 'info');
            return;
        }

        currentReadingBookId = bookId;
        bookReadingStartTime = Date.now();
        // Set book status to 'Reading' automatically
        const book = books.find(b => b.id === bookId);
        if (book && book.status !== 'Reading') {
            book.status = 'Reading';
            saveData('books', books);
            renderBooks();
        }
        updateBookButtonsState();
        showToast(`Started reading "${book.title}".`, 'info');
    }

    function stopBookReading(bookId) {
        if (currentReadingBookId !== bookId) return;

        clearInterval(bookReadingTimerInterval);
        const endTime = Date.now();
        const durationMs = endTime - bookReadingStartTime;

        const book = books.find(b => b.id === bookId);
        if (book && durationMs > 5000) {
            book.readingSessions.push({
                startTime: bookReadingStartTime,
                endTime: endTime,
                durationMs: durationMs
            });
            saveData('books', books);
            showToast(`Recorded ${formatDuration(durationMs)} for "${book.title}".`, 'success');
        } else if (durationMs <= 5000) {
            showToast('Reading session was too short to record (>5s required).', 'info');
        }

        currentReadingBookId = null;
        bookReadingStartTime = 0;
        updateBookButtonsState();
        renderBooks();
        updateBookStatistics();
    }

    function updateBookButtonsState() {
        document.querySelectorAll('.book-item').forEach(bookItem => {
            const bookId = bookItem.dataset.id;
            const startBtn = bookItem.querySelector('.start-reading');
            const stopBtn = bookItem.querySelector('.stop-reading');
            if (startBtn && stopBtn) {
                startBtn.disabled = currentReadingBookId !== null;
                stopBtn.disabled = currentReadingBookId !== bookId;
            }
        });
    }

    function renderBooks(filterText = '') {
        elements.booksList.innerHTML = '';
        elements.dashCurrentReadingList.innerHTML = ''; // Clear dashboard current reading

        const filteredBooks = books.filter(book => {
            const lowerCaseFilter = filterText.toLowerCase();
            return book.title.toLowerCase().includes(lowerCaseFilter) ||
                   book.author.toLowerCase().includes(lowerCaseFilter) ||
                   book.genre.toLowerCase().includes(lowerCaseFilter);
        });

        if (filteredBooks.length === 0 && filterText === '') {
            elements.booksList.innerHTML = '<li>No spiritual books added yet. Add your first scroll of wisdom!</li>';
        } else if (filteredBooks.length === 0 && filterText !== '') {
            elements.booksList.innerHTML = `<li>No books matching "${filterText}".</li>`;
        }

        filteredBooks.forEach(book => {
            const li = document.createElement('li');
            li.className = 'book-item';
            li.dataset.id = book.id;

            const totalReadingMs = book.readingSessions.reduce((sum, session) => sum + session.durationMs, 0);
            const progress = book.totalPages > 0 ? ((book.currentPage / book.totalPages) * 100).toFixed(1) : 0;
            const coverSrc = book.coverImage || './img/default_book.png'; // Fallback to default image

            li.innerHTML = `
                <img src="${coverSrc}" alt="Book Cover" class="book-cover-thumbnail">
                <div class="book-item-info">
                    <strong>${book.title}</strong>
                    <span>by ${book.author} | ${book.genre || 'N/A'}</span>
                    <span>Status: ${book.status} | Progress: ${book.currentPage}/${book.totalPages} (${progress}%)</span>
                    <span>Total Read: ${formatDuration(totalReadingMs)}</span>
                </div>
                <div class="book-item-controls">
                    <button class="start-reading" data-book-id="${book.id}" title="Start Reading">
                        <i class="fas fa-play"></i>
                    </button>
                    <button class="stop-reading" data-book-id="${book.id}" title="Stop Reading">
                        <i class="fas fa-stop"></i>
                    </button>
                    <button class="view-book-details btn-sm" data-book-id="${book.id}" title="View Details & Notes">
                        <i class="fas fa-info-circle"></i>
                    </button>
                    <button class="delete-book delete-button btn-sm" data-book-id="${book.id}" title="Delete Book">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                </div>
            `;
            elements.booksList.appendChild(li);
        });

        // Dashboard: Currently Reading (limit to 2)
        const currentlyReadingBooks = books.filter(book => book.status === 'Reading').slice(0, 2);
        if (currentlyReadingBooks.length > 0) {
            currentlyReadingBooks.forEach(book => {
                const li = document.createElement('li');
                const progress = book.totalPages > 0 ? ((book.currentPage / book.totalPages) * 100).toFixed(1) : 0;
                li.innerHTML = `
                    <span><strong>${book.title}</strong> by ${book.author}</span>
                    <span>Progress: ${progress}%</span>
                `;
                elements.dashCurrentReadingList.appendChild(li);
            });
        } else {
            elements.dashCurrentReadingList.innerHTML = '<li>No books currently being read.</li>';
        }

        updateBookButtonsState(); // Set initial button states after rendering
    }

    function deleteBook(bookId) {
        if (currentReadingBookId === bookId) {
            showToast('Cannot delete a book while it is being read. Please stop the timer first.', 'error');
            return;
        }
        showConfirmationModal('Are you sure you want to delete this book and all its reading records?', () => {
            books = books.filter(book => book.id !== bookId);
            saveData('books', books);
            renderBooks();
            updateBookStatistics();
            updateAchievements();
            updateGoals();
            showToast('Book deleted successfully!', 'success');
            closeModal(elements.confirmationModal);
        });
    }

    function openBookDetailsModal(bookId) {
        const book = books.find(b => b.id === bookId);
        if (!book) return;

        elements.modalBookCoverImg.src = book.coverImage || './img/default_book.png';
        elements.modalBookTitle.textContent = book.title;
        elements.modalBookAuthor.textContent = book.author;
        elements.modalBookGenre.textContent = book.genre || 'N/A';
        elements.modalBookStatus.textContent = book.status;
        elements.modalBookTotalPages.textContent = book.totalPages;
        elements.modalBookCurrentPage.value = book.currentPage;

        const totalReadingMs = book.readingSessions.reduce((sum, s) => sum + s.durationMs, 0);
        elements.modalBookTotalReadingTime.textContent = formatDuration(totalReadingMs);

        // Update progress bar and text
        const updateProgressDisplay = () => {
            const progress = book.totalPages > 0 ? ((book.currentPage / book.totalPages) * 100).toFixed(1) : 0;
            elements.modalBookProgress.textContent = `${progress}%`;
            elements.modalProgressBar.style.width = `${progress}%`;
        };
        updateProgressDisplay();

        elements.modalBookCurrentPage.onchange = (e) => {
            const newPage = parseInt(e.target.value, 10);
            if (!isNaN(newPage) && newPage >= 0 && newPage <= book.totalPages) {
                book.currentPage = newPage;
                saveData('books', books);
                updateProgressDisplay();
                renderBooks(); // Re-render main list to update progress
                updateAchievements();
                updateGoals();
            } else {
                e.target.value = book.currentPage;
                showToast('Invalid page number!', 'error');
            }
        };

        // Render Rating Stars
        elements.modalBookRating.innerHTML = '';
        for (let i = 1; i <= 5; i++) {
            const star = document.createElement('i');
            star.className = `fas fa-star ${i <= book.rating ? 'active' : ''}`;
            star.dataset.rating = i;
            star.onclick = () => {
                book.rating = i;
                saveData('books', books);
                openBookDetailsModal(bookId); // Re-render stars
                showToast(`Rated "${book.title}" ${i} stars.`, 'info');
            };
            elements.modalBookRating.appendChild(star);
        }

        // Dropdown for Status
        const statusSelect = document.createElement('select');
        statusSelect.className = 'input-field small-input';
        ['Reading', 'Finished', 'Want to Read'].forEach(status => {
            const option = document.createElement('option');
            option.value = status;
            option.textContent = status;
            if (book.status === status) option.selected = true;
            statusSelect.appendChild(option);
        });
        statusSelect.onchange = (e) => {
            book.status = e.target.value;
            saveData('books', books);
            elements.modalBookStatus.textContent = book.status;
            renderBooks(); // Update status in main list
            updateAchievements(); // Check for 'Books Finished' achievement
            updateGoals();
            showToast(`Status for "${book.title}" changed to "${book.status}".`, 'info');
        };
        elements.modalBookStatus.replaceWith(statusSelect); // Replace span with select

        elements.modalBookNotesInput.value = ''; // Clear input for new note
        renderBookNotes(book);

        elements.addBookNoteBtn.onclick = () => {
            const noteText = elements.modalBookNotesInput.value.trim();
            if (noteText) {
                book.notes.push({ id: generateId(), text: noteText, date: new Date().toISOString() });
                saveData('books', books);
                elements.modalBookNotesInput.value = '';
                renderBookNotes(book);
                showToast('Note added!', 'success');
            }
        };

        openModal(elements.bookDetailsModal);
    }

    function renderBookNotes(book) {
        elements.modalBookNotesList.innerHTML = '';
        if (book.notes.length === 0) {
            elements.modalBookNotesList.innerHTML = '<li>No notes yet. Add your insights!</li>';
            return;
        }

        book.notes.sort((a,b) => new Date(b.date) - new Date(a.date)).forEach(note => { // Newest first
            const li = document.createElement('li');
            li.innerHTML = `
                <div class="note-content">${note.text}</div>
                <span class="note-date">${new Date(note.date).toLocaleDateString()} ${new Date(note.date).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>
                <button class="delete-note-btn delete-button btn-sm" data-note-id="${note.id}"><i class="fas fa-times"></i></button>
            `;
            elements.modalBookNotesList.appendChild(li);
        });

        elements.modalBookNotesList.querySelectorAll('.delete-note-btn').forEach(btn => {
            btn.onclick = (e) => {
                const noteId = e.currentTarget.dataset.noteId;
                book.notes = book.notes.filter(n => n.id !== noteId);
                saveData('books', books);
                renderBookNotes(book);
                showToast('Note deleted.', 'info');
            };
        });
    }

    // --- Statistics & Charts ---

    function createOrUpdateChart(chartVar, canvasId, type, data, options) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        if (chartVar) {
            chartVar.destroy(); // Destroy previous chart instance
        }
        return new Chart(ctx, { type, data, options });
    }

    function renderMeditationCharts() {
        // Data for Meditation Time Trend (Daily)
        const dailyMedTime = {};
        meditationSessions.forEach(session => {
            const date = new Date(session.startTime).toISOString().slice(0, 10);
            dailyMedTime[date] = (dailyMedTime[date] || 0) + session.durationMs;
        });
        const sortedDates = Object.keys(dailyMedTime).sort();
        const medTimeData = sortedDates.map(date => ({ x: date, y: dailyMedTime[date] / (1000 * 60) })); // Minutes

        meditationTimeChart = createOrUpdateChart(meditationTimeChart, 'meditationTimeChart', 'line', {
            datasets: [{
                label: 'Daily Meditation Time (minutes)',
                data: medTimeData,
                borderColor: 'rgb(75, 192, 192)',
                tension: 0.1,
                fill: false
            }]
        }, {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'time',
                    time: { unit: 'day' },
                    title: { display: true, text: 'Date' }
                },
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Minutes' }
                }
            }
        });

        // Data for Meditation Session Count
        const dailySessionCount = {};
        meditationSessions.forEach(session => {
            const date = new Date(session.startTime).toISOString().slice(0, 10);
            dailySessionCount[date] = (dailySessionCount[date] || 0) + 1;
        });
        const sessionCountData = sortedDates.map(date => ({ x: date, y: dailySessionCount[date] }));

        meditationSessionsChart = createOrUpdateChart(meditationSessionsChart, 'meditationSessionsChart', 'bar', {
            datasets: [{
                label: 'Daily Meditation Sessions',
                data: sessionCountData,
                backgroundColor: 'rgba(153, 102, 255, 0.6)'
            }]
        }, {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'time',
                    time: { unit: 'day' },
                    title: { display: true, text: 'Date' }
                },
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Sessions' },
                    ticks: { precision: 0 }
                }
            }
        });

        // Mood Distribution Chart
        const moodCounts = {};
        meditationSessions.forEach(session => {
            if (session.mood) {
                moodCounts[session.mood] = (moodCounts[session.mood] || 0) + 1;
            }
        });
        const moodLabels = Object.keys(moodCounts);
        const moodData = Object.values(moodCounts);
        const moodColors = moodLabels.map(mood => { // Assign consistent colors
            switch (mood) {
                case 'calm': return '#81C784'; // Greenish
                case 'focused': return '#64B5F6'; // Blueish
                case 'peaceful': return '#BA68C8'; // Purplish
                case 'energetic': return '#FFEB3B'; // Yellowish
                case 'tired': return '#90A4AE'; // Greyish
                case 'anxious': return '#EF5350'; // Reddish
                case 'happy': return '#FFD54F'; // Orangeish
                default: return '#CCCCCC';
            }
        });

        moodDistributionChart = createOrUpdateChart(moodDistributionChart, 'moodDistributionChart', 'pie', {
            labels: moodLabels,
            datasets: [{
                data: moodData,
                backgroundColor: moodColors
            }]
        }, {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'top' },
                title: { display: true, text: 'Mood Distribution' }
            }
        });

        // Top Tags Chart
        const tagCounts = {};
        meditationSessions.forEach(session => {
            if (session.tags) {
                session.tags.forEach(tag => {
                    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                });
            }
        });
        const sortedTags = Object.entries(tagCounts).sort(([, a], [, b]) => b - a).slice(0, 10); // Top 10
        const tagLabels = sortedTags.map(([tag]) => tag);
        const tagData = sortedTags.map(([, count]) => count);

        topTagsChart = createOrUpdateChart(topTagsChart, 'topTagsChart', 'bar', {
            labels: tagLabels,
            datasets: [{
                label: 'Tag Usage',
                data: tagData,
                backgroundColor: 'rgba(75, 192, 192, 0.6)'
            }]
        }, {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y', // Horizontal bars
            scales: {
                x: {
                    beginAtZero: true,
                    title: { display: true, text: 'Count' },
                    ticks: { precision: 0 }
                },
                y: {
                    title: { display: true, text: 'Tag' }
                }
            }
        });

        // Book Reading Time Chart
        const bookReadingTotals = {};
        books.forEach(book => {
            bookReadingTotals[book.title] = book.readingSessions.reduce((sum, s) => sum + s.durationMs, 0) / (1000 * 60 * 60); // Hours
        });
        const sortedBookData = Object.entries(bookReadingTotals).sort(([, a], [, b]) => b - a).filter(([, time]) => time > 0);
        const bookLabels = sortedBookData.map(([title]) => title);
        const bookData = sortedBookData.map(([, time]) => time);

        bookReadingTimeChart = createOrUpdateChart(bookReadingTimeChart, 'bookReadingTimeChart', 'bar', {
            labels: bookLabels,
            datasets: [{
                label: 'Total Reading Time (hours)',
                data: bookData,
                backgroundColor: 'rgba(255, 99, 132, 0.6)'
            }]
        }, {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                x: {
                    beginAtZero: true,
                    title: { display: true, text: 'Book Title' }
                },
                y: {
                    title: { display: true, text: 'Hours' }
                }
            }
        });
    }

    function renderMeditationCalendar() {
        elements.meditationCalendar.innerHTML = '';
        const meditatedDays = new Set(meditationSessions.map(s => new Date(s.startTime).toDateString()));

        const today = new Date();
        today.setHours(0,0,0,0);

        const now = new Date();
        const currentYear = now.getFullYear();
        const currentMonth = now.getMonth();

        // Header for the current month
        const header = document.createElement('div');
        header.className = 'calendar-header';
        header.textContent = new Date(currentYear, currentMonth).toLocaleString('default', { month: 'long', year: 'numeric' });
        elements.meditationCalendar.appendChild(header);

        // Day names
        const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        dayNames.forEach(day => {
            const div = document.createElement('div');
            div.className = 'calendar-day-name';
            div.textContent = day;
            elements.meditationCalendar.appendChild(div);
        });

        // Days of the month
        const firstDayOfMonth = new Date(currentYear, currentMonth, 1);
        const lastDayOfMonth = new Date(currentYear, currentMonth + 1, 0);
        const startDayOfWeek = firstDayOfMonth.getDay(); // 0 for Sunday, 1 for Monday...

        // Empty cells for days before the 1st
        for (let i = 0; i < startDayOfWeek; i++) {
            const div = document.createElement('div');
            div.className = 'calendar-day empty';
            elements.meditationCalendar.appendChild(div);
        }

        for (let day = 1; day <= lastDayOfMonth.getDate(); day++) {
            const date = new Date(currentYear, currentMonth, day);
            date.setHours(0,0,0,0);
            const dateString = date.toDateString();
            const div = document.createElement('div');
            div.className = 'calendar-day';
            div.textContent = day;

            if (meditatedDays.has(dateString)) {
                div.classList.add('meditated');
            }
            if (date.getTime() === today.getTime()) {
                div.classList.add('current-day');
            }
            elements.meditationCalendar.appendChild(div);
        }
    }


    // --- Goals Logic ---

    const GOAL_TYPES = {
        meditation_duration: { label: 'Meditation Duration', unit: 'minutes', getProgress: () => meditationSessions.reduce((sum, s) => sum + s.durationMs, 0) / (1000 * 60) },
        meditation_days: { label: 'Meditation Days', unit: 'days', getProgress: () => new Set(meditationSessions.map(s => s.date)).size },
        books_finished: { label: 'Books Finished', unit: 'books', getProgress: () => books.filter(b => b.status === 'Finished').length }
    };

    function addGoal() {
        const type = elements.goalTypeSelect.value;
        const value = parseInt(elements.goalValueInput.value, 10);
        const period = elements.goalPeriodSelect.value;

        if (isNaN(value) || value <= 0) {
            showToast('Please enter a valid target value for your goal.', 'error');
            return;
        }

        const newGoal = {
            id: generateId(),
            type: type,
            targetValue: value,
            period: period,
            currentProgress: 0, // Will be calculated by updateGoals
            completed: false,
            startDate: new Date().toISOString(),
            lastUpdate: new Date().toISOString()
        };
        goals.push(newGoal);
        saveData('goals', goals);
        elements.goalValueInput.value = '';
        renderGoals();
        updateGoals();
        showToast('Goal added successfully!', 'success');
    }

    function updateGoals() {
        const now = new Date();
        goals.forEach(goal => {
            if (goal.completed) return;

            let currentProgress = 0;
            let relevantSessions = [];

            if (goal.period === 'week') {
                const startOfWeek = new Date(now);
                startOfWeek.setDate(now.getDate() - now.getDay()); // Sunday
                startOfWeek.setHours(0,0,0,0);
                relevantSessions = meditationSessions.filter(s => new Date(s.startTime) >= startOfWeek);
                // For books, we need to re-evaluate the count for the current week, if it were dynamic.
                // For simplicity, for books, we will count overall finished books.
            } else if (goal.period === 'month') {
                const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
                relevantSessions = meditationSessions.filter(s => new Date(s.startTime) >= startOfMonth);
            } else { // 'overall'
                relevantSessions = meditationSessions;
            }

            if (goal.type === 'meditation_duration') {
                currentProgress = relevantSessions.reduce((sum, s) => sum + s.durationMs, 0) / (1000 * 60);
            } else if (goal.type === 'meditation_days') {
                currentProgress = new Set(relevantSessions.map(s => new Date(s.startTime).toDateString())).size;
            } else if (goal.type === 'books_finished') {
                currentProgress = books.filter(b => b.status === 'Finished').length;
            }

            goal.currentProgress = currentProgress;
            if (goal.currentProgress >= goal.targetValue) {
                goal.completed = true;
                showToast(`Goal Completed: ${GOAL_TYPES[goal.type].label} of ${goal.targetValue} ${GOAL_TYPES[goal.type].unit} ${goal.period === 'overall' ? '' : 'per ' + goal.period}!`, 'success');
            }
        });
        saveData('goals', goals);
        renderGoals();
    }

    function renderGoals() {
        elements.activeGoalsList.innerHTML = '';
        elements.completedGoalsList.innerHTML = '';

        const activeGoals = goals.filter(g => !g.completed);
        const completedGoals = goals.filter(g => g.completed);

        if (activeGoals.length === 0 && completedGoals.length === 0) {
            elements.activeGoalsList.innerHTML = '<li>No goals set yet. Set a goal to start tracking!</li>';
            return;
        }

        activeGoals.forEach(goal => {
            const li = document.createElement('li');
            const progress = Math.min(100, (goal.currentProgress / goal.targetValue) * 100).toFixed(1);
            li.innerHTML = `
                <div>
                    <strong>${GOAL_TYPES[goal.type].label}: ${goal.currentProgress.toFixed(1)} / ${goal.targetValue} ${GOAL_TYPES[goal.type].unit} ${goal.period === 'overall' ? '' : 'per ' + goal.period}</strong>
                    <div class="goal-progress-bar-container"><div class="goal-progress-bar" style="width: ${progress}%"></div></div>
                    <span>Progress: ${progress}%</span>
                </div>
                <button class="delete-goal-btn delete-button btn-sm" data-id="${goal.id}"><i class="fas fa-trash-alt"></i></button>
            `;
            elements.activeGoalsList.appendChild(li);
        });

        completedGoals.forEach(goal => {
            const li = document.createElement('li');
            li.className = 'completed';
            li.innerHTML = `
                <div>
                    <strong>${GOAL_TYPES[goal.type].label}: ${goal.targetValue} ${GOAL_TYPES[goal.type].unit} ${goal.period === 'overall' ? '' : 'per ' + goal.period}</strong>
                    <div class="goal-progress-bar-container"><div class="goal-progress-bar" style="width: 100%"></div></div>
                    <span>Completed on: ${new Date(goal.lastUpdate).toLocaleDateString()}</span>
                </div>
                <button class="delete-goal-btn delete-button btn-sm" data-id="${goal.id}"><i class="fas fa-trash-alt"></i></button>
            `;
            elements.completedGoalsList.appendChild(li);
        });

        document.querySelectorAll('.delete-goal-btn').forEach(btn => {
            btn.onclick = (e) => deleteGoal(e.currentTarget.dataset.id);
        });
    }

    function deleteGoal(goalId) {
        showConfirmationModal('Are you sure you want to delete this goal?', () => {
            goals = goals.filter(g => g.id !== goalId);
            saveData('goals', goals);
            renderGoals();
            showToast('Goal deleted.', 'info');
            closeModal(elements.confirmationModal);
        });
    }


    // --- Achievements Logic ---

    const achievementsList = [
        { id: 'first_session', name: 'First Step', description: 'Complete your first meditation session.', check: () => meditationSessions.length >= 1, unlocked: false, icon: 'fas fa-shoe-prints' },
        { id: 'seven_day_streak', name: '7-Day Streak', description: 'Meditate for 7 consecutive days.', check: () => calculateStreaks().longestStreak >= 7, unlocked: false, icon: 'fas fa-fire' },
        { id: '30_min_meditation', name: 'Deep Dive', description: 'Complete a meditation session of 30 minutes or more.', check: () => meditationSessions.some(s => s.durationMs >= 30 * 60 * 1000), unlocked: false, icon: 'fas fa-mountain' },
        { id: '10_hours_meditated', name: 'Seasoned Seeker', description: 'Accumulate 10 hours of meditation.', check: () => meditationSessions.reduce((sum, s) => sum + s.durationMs, 0) >= 10 * 60 * 60 * 1000, unlocked: false, icon: 'fas fa-star' },
        { id: 'first_book_finished', name: 'Wisdom Gained', description: 'Mark your first spiritual book as "Finished".', check: () => books.some(b => b.status === 'Finished'), unlocked: false, icon: 'fas fa-feather-alt' },
        { id: 'five_books_finished', name: 'Enlightened Library', description: 'Finish 5 spiritual books.', check: () => books.filter(b => b.status === 'Finished').length >= 5, unlocked: false, icon: 'fas fa-book-sparkles' },
        { id: 'first_journal_entry', name: 'Inner Voice', description: 'Write your first meditation journal entry.', check: () => meditationSessions.some(s => s.journalEntry && s.journalEntry.length > 0), unlocked: false, icon: 'fas fa-pen-nib' },
        { id: 'first_book_note', name: 'Reflective Reader', description: 'Add your first note to a spiritual book.', check: () => books.some(b => b.notes && b.notes.length > 0), unlocked: false, icon: 'fas fa-highlighter' },
    ];

    function updateAchievements() {
        let changed = false;
        achievementsList.forEach(achievement => {
            if (!achievement.unlocked && achievement.check()) {
                achievement.unlocked = true;
                changed = true;
                showToast(`Achievement Unlocked: ${achievement.name}!`, 'success');
            }
        });
        if (changed) {
            saveData('achievementsList', achievementsList); // Save updated unlocked status
            renderAchievements();
        }
    }

    function renderAchievements() {
        elements.achievementsGrid.innerHTML = '';
        const savedAchievements = loadData('achievementsList', achievementsList.map(a => ({ id: a.id, unlocked: false })));

        achievementsList.forEach(achievement => {
            const savedState = savedAchievements.find(sa => sa.id === achievement.id);
            if (savedState) achievement.unlocked = savedState.unlocked; // Apply saved state

            const card = document.createElement('div');
            card.className = `achievement-card ${achievement.unlocked ? 'unlocked' : ''}`;
            card.innerHTML = `
                <i class="${achievement.icon}"></i>
                <h4>${achievement.name}</h4>
                <p>${achievement.description}</p>
            `;
            elements.achievementsGrid.appendChild(card);
        });
    }

    // --- Settings Logic ---

    function applySettings() {
        document.body.className = `${settings.theme}-theme`; // Set theme class
        elements.themeSelector.value = settings.theme;
        elements.bellSoundToggle.checked = settings.bellSound;
        elements.bellVolumeControl.value = settings.bellVolume;
        elements.ambientSoundSelector.value = settings.ambientSound;
        elements.ambientVolumeControl.value = settings.ambientVolume;
        elements.dailyReminderTimeInput.value = settings.dailyReminderTime;

        if (settings.customBackground) {
            document.body.style.backgroundImage = `url(${settings.customBackground})`;
            document.body.style.backgroundSize = 'cover';
            document.body.style.backgroundAttachment = 'fixed';
            document.body.style.backgroundPosition = 'center center';
        } else {
            document.body.style.backgroundImage = '';
        }

        updateVolumeNodes(); // Update gain node values
        startAmbientSound(settings.ambientSound); // Restart ambient sound if active
    }

    function saveSettings() {
        settings.theme = elements.themeSelector.value;
        settings.bellSound = elements.bellSoundToggle.checked;
        settings.bellVolume = parseFloat(elements.bellVolumeControl.value);
        settings.ambientSound = elements.ambientSoundSelector.value;
        settings.ambientVolume = parseFloat(elements.ambientVolumeControl.value);
        settings.dailyReminderTime = elements.dailyReminderTimeInput.value;

        saveData('settings', settings);
        applySettings();
        showToast('Settings saved!', 'info');
    }

    function setDailyReminder() {
        if (!settings.dailyReminderTime) {
            showToast('Please select a time for the reminder.', 'error');
            return;
        }
        if (!('Notification' in window)) {
            showToast('This browser does not support desktop notifications.', 'error');
            return;
        }
        if (Notification.permission === 'default') {
            Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                    scheduleReminder();
                } else {
                    showToast('Notification permission denied. Cannot set reminder.', 'warning');
                }
            });
        } else if (Notification.permission === 'granted') {
            scheduleReminder();
        } else { // Permission denied
            showToast('Notification permission blocked. Please enable it in browser settings.', 'warning');
        }
    }

    let reminderIntervalId = null;
    function scheduleReminder() {
        // Clear existing interval if any
        if (reminderIntervalId) {
            clearInterval(reminderIntervalId);
        }

        const [hour, minute] = settings.dailyReminderTime.split(':').map(Number);

        reminderIntervalId = setInterval(() => {
            const now = new Date();
            if (now.getHours() === hour && now.getMinutes() === minute && now.getSeconds() === 0) {
                new Notification('Mystic Vision', {
                    body: 'Time for your daily meditation!',
                    icon: './img/icon.png' // Add a small app icon for notifications
                });
            }
        }, 1000); // Check every second

        showToast(`Daily meditation reminder set for ${settings.dailyReminderTime}.`, 'success');
    }

    function clearDailyReminder() {
        if (reminderIntervalId) {
            clearInterval(reminderIntervalId);
            reminderIntervalId = null;
        }
        settings.dailyReminderTime = '';
        saveData('settings', settings);
        elements.dailyReminderTimeInput.value = '';
        showToast('Daily reminder cleared.', 'info');
    }

    function exportData() {
        const data = {
            meditationSessions: meditationSessions,
            books: books,
            goals: goals,
            settings: settings,
            achievementsList: achievementsList.map(a => ({ id: a.id, unlocked: a.unlocked }))
        };
        const filename = `mystic_vision_data_${new Date().toISOString().slice(0, 10)}.json`;
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast('Data exported successfully!', 'success');
    }

    function importData(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const importedData = JSON.parse(e.target.result);
                showConfirmationModal('Are you sure you want to import data? This will OVERWRITE your current data!', () => {
                    if (importedData.meditationSessions) meditationSessions = importedData.meditationSessions;
                    if (importedData.books) books = importedData.books;
                    if (importedData.goals) goals = importedData.goals;
                    if (importedData.settings) settings = importedData.settings;
                    if (importedData.achievementsList) {
                        achievementsList.forEach(localAch => {
                            const importedAch = importedData.achievementsList.find(ia => ia.id === localAch.id);
                            if (importedAch) localAch.unlocked = importedAch.unlocked;
                        });
                    }

                    saveData('meditationSessions', meditationSessions);
                    saveData('books', books);
                    saveData('goals', goals);
                    saveData('settings', settings);
                    saveData('achievementsList', achievementsList.map(a => ({ id: a.id, unlocked: a.unlocked })));

                    initializeApp();
                    showToast('Data imported successfully!', 'success');
                    closeModal(elements.confirmationModal);
                });
            } catch (error) {
                showToast('Error importing data: Invalid JSON file. ' + error.message, 'error');
                console.error('Import error:', error);
            }
        };
        reader.readAsText(file);
    }

    function clearAllData() {
        showConfirmationModal('Are you absolutely sure you want to clear ALL your data? This action cannot be undone!', () => {
            localStorage.clear();
            meditationSessions = [];
            books = [];
            goals = [];
            settings = { theme: 'light', bellSound: true, bellVolume: 0.5, ambientSound: 'none', ambientVolume: 0.5, dailyReminderTime: null, customBackground: null };
            achievementsList.forEach(a => a.unlocked = false); // Reset achievements
            initializeApp();
            showToast('All data cleared!', 'success');
            closeModal(elements.confirmationModal);
        });
    }

    function showConfirmationModal(message, onConfirm) {
        elements.confirmationMessage.textContent = message;
        elements.confirmActionBtn.onclick = onConfirm;
        elements.cancelActionBtn.onclick = () => closeModal(elements.confirmationModal);
        openModal(elements.confirmationModal);
    }

    // --- UI Navigation ---
    function showSection(sectionId) {
        elements.appSections.forEach(section => {
            section.classList.remove('active-section');
        });
        document.getElementById(sectionId).classList.add('active-section');

        elements.navButtons.forEach(button => {
            if (button.dataset.section === sectionId) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
        });

        // Re-render relevant sections if they were just opened
        if (sectionId === 'dashboard-section') {
            updateDashboard();
        } else if (sectionId === 'meditation-section') {
            renderMeditationSessions();
        } else if (sectionId === 'books-section') {
            renderBooks();
            elements.bookSearchInput.value = ''; // Clear search on section change
        } else if (sectionId === 'statistics-section') {
            renderMeditationCharts();
            renderMeditationCalendar();
            updateBookStatistics(); // Updates book chart
        } else if (sectionId === 'goals-section') {
            renderGoals();
        } else if (sectionId === 'achievements-section') {
            renderAchievements();
        }
    }

    function updateDashboard() {
        // This will be mostly handled by updateMeditationStats and renderBooks etc.
        // Just ensures the right elements are updated.
        updateMeditationStats(); // Populates meditation stats and streaks on dashboard
        elements.dashBooksFinished.textContent = books.filter(b => b.status === 'Finished').length;
        renderMeditationSessions(); // Populates recent meditations on dashboard
        renderBooks(); // Populates currently reading on dashboard
    }

    // --- Event Listeners ---
    elements.startMeditationBtn.addEventListener('click', () => startMeditationTimer(0));
    elements.pauseMeditationBtn.addEventListener('click', pauseMeditationTimer);
    elements.stopMeditationBtn.addEventListener('click', stopMeditationTimer);
    elements.resetMeditationBtn.addEventListener('click', resetMeditationDisplay);

    elements.presetMeditationButtons.forEach(button => {
        button.addEventListener('click', (e) => {
            const minutes = parseInt(e.target.dataset.minutes, 10);
            resetMeditationDisplay();
            startMeditationTimer(minutes);
        });
    });

    elements.openIntervalTimerBtn.addEventListener('click', () => {
        elements.intervalStepsContainer.innerHTML = ''; // Clear existing steps
        addIntervalStep(); // Add first default step
        openModal(elements.intervalTimerModal);
    });
    elements.addIntervalStepBtn.addEventListener('click', addIntervalStep);
    elements.startIntervalMeditationBtn.addEventListener('click', () => {
        const steps = getIntervalStepsFromUI();
        if (steps.length > 0) {
            intervalTimerSteps = steps;
            resetMeditationDisplay();
            closeModal(elements.intervalTimerModal);
            startMeditationTimer(0, 'interval'); // Duration 0 as it's interval controlled
        } else {
            showToast('Please add at least one interval step.', 'warning');
        }
    });

    elements.journalMoodEmojis.forEach(emoji => {
        emoji.addEventListener('click', () => {
            elements.journalMoodEmojis.forEach(e => e.classList.remove('selected'));
            emoji.classList.add('selected');
        });
    });
    elements.journalEnergyLevel.addEventListener('input', (e) => {
        elements.journalEnergyValue.textContent = e.target.value;
    });

    elements.addBookBtn.addEventListener('click', addBook);
    elements.uploadBookCoverBtn.addEventListener('click', () => elements.newBookCoverInput.click());
    elements.newBookCoverInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onloadend = () => {
                newBookCoverBase64 = reader.result;
                elements.uploadBookCoverBtn.innerHTML = '<i class="fas fa-check"></i> Cover Ready';
                showToast('Book cover selected!', 'info');
            };
            reader.readAsDataURL(file);
        }
    });

    elements.bookSearchInput.addEventListener('input', (e) => renderBooks(e.target.value));
    elements.clearBookSearchBtn.addEventListener('click', () => {
        elements.bookSearchInput.value = '';
        renderBooks();
    });

    elements.addGoalBtn.addEventListener('click', addGoal);

    elements.navButtons.forEach(button => {
        button.addEventListener('click', () => {
            showSection(button.dataset.section);
        });
    });

    elements.closeButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
            closeModal(document.getElementById(e.currentTarget.dataset.modal));
        });
    });

    window.addEventListener('click', (event) => {
        if (event.target === elements.meditationJournalModal) closeModal(elements.meditationJournalModal);
        if (event.target === elements.bookDetailsModal) closeModal(elements.bookDetailsModal);
        if (event.target === elements.intervalTimerModal) closeModal(elements.intervalTimerModal);
        if (event.target === elements.confirmationModal) closeModal(elements.confirmationModal);
    });

    // Settings listeners
    elements.themeSelector.addEventListener('change', saveSettings);
    elements.bellSoundToggle.addEventListener('change', saveSettings);
    elements.bellVolumeControl.addEventListener('input', saveSettings);
    elements.ambientSoundSelector.addEventListener('change', saveSettings);
    elements.ambientVolumeControl.addEventListener('input', saveSettings);
    elements.setDailyReminderBtn.addEventListener('click', setDailyReminder);
    elements.clearDailyReminderBtn.addEventListener('click', clearDailyReminder);

    elements.uploadCustomBackgroundBtn.addEventListener('click', () => elements.customBackgroundFileInput.click());
    elements.customBackgroundFileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onloadend = () => {
                settings.customBackground = reader.result;
                saveSettings();
                showToast('Custom background applied!', 'success');
            };
            reader.readAsDataURL(file);
        }
    });
    elements.clearCustomBackgroundBtn.addEventListener('click', () => {
        settings.customBackground = null;
        saveSettings();
        showToast('Custom background cleared.', 'info');
    });

    elements.exportDataBtn.addEventListener('click', exportData);
    elements.importDataBtn.addEventListener('click', () => elements.importDataFile.click());
    elements.importDataFile.addEventListener('change', importData);
    elements.clearAllDataBtn.addEventListener('click', clearAllData);


    // --- Initialization ---
    async function initializeApp() {
        // Load all sounds first
        await loadSound(BELL_SOUND_URL, 'bell');
        await loadSound(AMBIENT_SOUND_URLS.rain, 'rain');
        await loadSound(AMBIENT_SOUND_URLS.forest, 'forest');
        await loadSound(AMBIENT_SOUND_URLS.ocean, 'ocean');
        await loadSound(AMBIENT_SOUND_URLS.chimes, 'chimes');
        
        applySettings();
        updateMeditationButtonStates(false, true, true);
        renderMeditationSessions();
        updateMeditationStats();
        renderBooks();
        updateBookStatistics(); // Call to initialize book charts
        renderGoals();
        updateGoals(); // Initial goal check
        renderAchievements();
        updateAchievements(); // Initial achievement check

        if (settings.dailyReminderTime) {
            setDailyReminder(); // Re-schedule reminder on load
        }

        showSection('dashboard-section'); // Show dashboard by default

        document.getElementById('current-year').textContent = new Date().getFullYear();
    }

    initializeApp();
});

--- END FILE: script.js ---

--- START FILE: style.css ---

/* --- Global & Root Variables --- */
:root {
    /* Light Theme (Serene) */
    --light-primary: #5b21b6; /* Deep Violet */
    --light-secondary: #7c3aed; /* Amethyst Purple */
    --light-accent: #f59e0b; /* Golden Amber */
    --light-bg-gradient-start: #f3e8ff; /* Very Light Purple */
    --light-bg-gradient-end: #e9d5ff; /* Light Purple */
    --light-text-color: #333;
    --light-light-text-color: #f0f0f0;
    --light-card-bg: #ffffff;
    --light-border-color: #d8b4fe;
    --light-shadow-light: rgba(0, 0, 0, 0.08);
    --light-shadow-medium: rgba(0, 0, 0, 0.15);
    --light-input-bg: #f9f4ff;

    /* General */
    --button-hover-darken: #4c1d95;
    --delete-color: #ef4444;
    --delete-hover: #dc2626;
    --success-color: #22c55e;
    --success-hover: #16a34a;
    --info-color: #3b82f6;
    --info-hover: #2563eb;
    --warning-color: #f59e0b;
    --warning-hover: #d97706;

    /* Modal */
    --modal-bg: rgba(0, 0, 0, 0.6);
    --modal-content-bg: #fff;

    /* Active Theme Variables (default to Light) */
    --primary-color: var(--light-primary);
    --secondary-color: var(--light-secondary);
    --accent-color: var(--light-accent);
    --background-gradient-start: var(--light-bg-gradient-start);
    --background-gradient-end: var(--light-bg-gradient-end);
    --text-color: var(--light-text-color);
    --light-text-color: var(--light-light-text-color);
    --card-background: var(--light-card-bg);
    --border-color: var(--light-border-color);
    --shadow-light: var(--light-shadow-light);
    --shadow-medium: var(--light-shadow-medium);
    --input-bg: var(--light-input-bg);
    --meditation-timer-bg: var(--light-bg-gradient-end);
    --stats-grid-bg: var(--light-bg-gradient-end);
    --list-item-bg: var(--light-bg-gradient-end);
    --toast-bg: rgba(0,0,0,0.8);
    --toast-text: #fff;
    --progress-bar-bg: #e0e0e0;
    --progress-bar-fill: var(--secondary-color);
}

/* --- Dark Theme (Mystic Night) --- */
body.dark-theme {
    --primary-color: #a78bfa;
    --secondary-color: #c4b5fd;
    --accent-color: #fde047;
    --background-gradient-start: #1e093d;
    --background-gradient-end: #3b0764;
    --text-color: #e0e0e0;
    --light-text-color: #f0f0f0;
    --card-background: #2c0b5e;
    --border-color: #5b21b6;
    --shadow-light: rgba(255, 255, 255, 0.05);
    --shadow-medium: rgba(255, 255, 255, 0.1);
    --input-bg: #3b0764;
    --meditation-timer-bg: #220546;
    --stats-grid-bg: #220546;
    --list-item-bg: #220546;
    --modal-content-bg: #3b0764;
    --progress-bar-bg: #4c1d95;
    --progress-bar-fill: var(--primary-color);
}

/* --- Cosmic Whisper Theme --- */
body.cosmic-theme {
    --primary-color: #6d28d9;
    --secondary-color: #8b5cf6;
    --accent-color: #fcd34d;
    --background-gradient-start: #0f031c; /* Deep Space */
    --background-gradient-end: #2a0e4d; /* Nebula Purple */
    --text-color: #e0e0e0;
    --light-text-color: #f0f0f0;
    --card-background: #1a082c;
    --border-color: #4b0d87;
    --shadow-light: rgba(255, 255, 255, 0.05);
    --shadow-medium: rgba(255, 255, 255, 0.1);
    --input-bg: #2a0e4d;
    --meditation-timer-bg: #11041b;
    --stats-grid-bg: #11041b;
    --list-item-bg: #11041b;
    --modal-content-bg: #2a0e4d;
    --progress-bar-bg: #3b0764;
    --progress-bar-fill: var(--secondary-color);
}

/* --- Forest Bloom Theme --- */
body.forest-theme {
    --primary-color: #166534; /* Dark Forest Green */
    --secondary-color: #4ade80; /* Light Green */
    --accent-color: #fbbf24; /* Yellow Sun */
    --background-gradient-start: #ecfdf5; /* Pale Green */
    --background-gradient-end: #d1fae5; /* Lighter Green */
    --text-color: #222;
    --light-text-color: #f0fdf5;
    --card-background: #ffffff;
    --border-color: #a7f3d0;
    --shadow-light: rgba(0, 0, 0, 0.07);
    --shadow-medium: rgba(0, 0, 0, 0.12);
    --input-bg: #d1fae5;
    --meditation-timer-bg: #a7f3d0;
    --stats-grid-bg: #a7f3d0;
    --list-item-bg: #a7f3d0;
    --modal-content-bg: #ffffff;
    --button-hover-darken: #115e3a;
    --progress-bar-bg: #cbf9e2;
    --progress-bar-fill: var(--secondary-color);
}


/* --- Global Styles --- */
body {
    font-family: 'Segoe UI', 'Roboto', sans-serif;
    margin: 0;
    padding: 0;
    background: linear-gradient(135deg, var(--background-gradient-start), var(--background-gradient-end));
    color: var(--text-color);
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    box-sizing: border-box;
    transition: background-color 0.5s ease, color 0.5s ease;
    overflow-y: scroll; /* Always show scrollbar to prevent layout jump */
}

/* Custom Scrollbar */
body::-webkit-scrollbar {
    width: 12px;
}

body::-webkit-scrollbar-track {
    background: var(--background-gradient-start);
}

body::-webkit-scrollbar-thumb {
    background-color: var(--secondary-color);
    border-radius: 6px;
    border: 3px solid var(--background-gradient-start);
}

body.modal-open {
    overflow: hidden; /* Prevent scrolling when modal is open */
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 0 1.5em;
}

header {
    background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
    color: var(--light-text-color);
    padding: 2em 0;
    text-align: center;
    box-shadow: 0 6px 15px var(--shadow-medium);
}

header h1 {
    margin: 0;
    font-size: 3.5em;
    letter-spacing: 2px;
    font-weight: 700;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
}

header p {
    margin: 0.5em 0 0;
    font-size: 1.3em;
    opacity: 0.9;
}

/* --- Navigation --- */
.main-nav {
    background-color: var(--card-background);
    padding: 1em 0;
    box-shadow: 0 3px 8px var(--shadow-light);
    margin-bottom: 2.5em;
    position: sticky;
    top: 0;
    z-index: 100;
    border-bottom: 1px solid var(--border-color);
}

.main-nav .container {
    display: flex;
    justify-content: center;
    gap: 1.2em;
    flex-wrap: wrap;
}

.nav-button {
    background-color: transparent;
    border: none;
    color: var(--primary-color);
    padding: 1em 1.8em;
    font-size: 1.2em;
    cursor: pointer;
    border-radius: 10px;
    transition: background-color 0.3s ease, color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
    display: flex;
    align-items: center;
    gap: 10px;
    white-space: nowrap;
    font-weight: 600;
}

.nav-button i {
    font-size: 1.3em;
}

.nav-button:hover {
    background-color: var(--background-gradient-end);
    transform: translateY(-3px);
    box-shadow: 0 4px 10px var(--shadow-light);
}

.nav-button.active {
    background-color: var(--secondary-color);
    color: var(--light-text-color);
    box-shadow: 0 4px 12px var(--shadow-medium);
    transform: translateY(-2px);
}

.nav-button.active:hover {
    background-color: var(--primary-color);
    transform: none;
    box-shadow: 0 2px 8px var(--shadow-light);
}

/* --- Main Content Layout --- */
main {
    flex-grow: 1;
    padding-bottom: 3em;
}

.app-section {
    display: none;
    opacity: 0;
    transform: translateY(30px);
    transition: opacity 0.6s ease, transform 0.6s ease;
}

.app-section.active-section {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); /* Flexible grid layout */
    gap: 2.5em;
    opacity: 1;
    transform: translateY(0);
}

/* Card Styles */
.card {
    background-color: var(--card-background);
    border-radius: 15px;
    box-shadow: 0 10px 25px var(--shadow-light);
    padding: 3em;
    border: 1px solid var(--border-color);
    transition: transform 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease;
    display: flex;
    flex-direction: column;
}

.card:hover {
    transform: translateY(-7px);
    box-shadow: 0 15px 35px var(--shadow-medium);
}

.card-full-width {
    grid-column: 1 / -1; /* Make card span full width in grid */
}


h2 {
    color: var(--primary-color);
    margin-top: 0;
    font-size: 2.5em;
    border-bottom: 2px solid var(--border-color);
    padding-bottom: 0.8em;
    margin-bottom: 1.5em;
    display: flex;
    align-items: center;
    font-weight: 700;
}

h2 i {
    margin-right: 15px;
    color: var(--accent-color);
    font-size: 1.2em;
}

h3 {
    color: var(--secondary-color);
    margin-top: 2em;
    margin-bottom: 1.5em;
    font-size: 1.8em;
    border-bottom: 1px dashed var(--border-color);
    padding-bottom: 0.6em;
    font-weight: 600;
}

/* --- Buttons --- */
button {
    background-color: var(--secondary-color);
    color: var(--light-text-color);
    border: none;
    padding: 1em 2em;
    border-radius: 30px;
    font-size: 1.1em;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    white-space: nowrap;
    font-weight: 500;
}

button:hover:not(:disabled) {
    background-color: var(--button-hover-darken);
    transform: translateY(-3px);
    box-shadow: 0 6px 15px var(--shadow-light);
}

button:active:not(:disabled) {
    transform: translateY(0);
    box-shadow: inset 0 3px 8px rgba(0,0,0,0.3);
}

button:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
    opacity: 0.6;
    box-shadow: none;
    transform: none;
}

.btn-sm {
    padding: 0.7em 1.4em;
    font-size: 0.95em;
    border-radius: 25px;
}

.btn-icon {
    padding: 0.7em 1em;
    font-size: 1.1em;
    border-radius: 50%;
    min-width: 40px;
    min-height: 40px;
}
.btn-icon i {
    margin: 0;
}

.delete-button { background-color: var(--delete-color); }
.delete-button:hover:not(:disabled) { background-color: var(--delete-hover); }

.export-button { background-color: var(--success-color); }
.export-button:hover { background-color: var(--success-hover); }

.import-button { background-color: var(--info-color); }
.import-button:hover { background-color: var(--info-hover); }

.secondary-button { background-color: #9ca3af; }
.secondary-button:hover { background-color: #6b7280; }

/* --- Forms & Inputs --- */
.input-field, select {
    flex-grow: 1;
    padding: 1em 1.2em;
    border: 1px solid var(--border-color);
    border-radius: 30px;
    font-size: 1em;
    outline: none;
    transition: border-color 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease, color 0.3s ease;
    background-color: var(--input-bg);
    color: var(--text-color);
    min-width: 150px;
}

.input-field:focus, select:focus {
    border-color: var(--secondary-color);
    box-shadow: 0 0 0 4px rgba(124, 58, 237, 0.2);
}

.small-input {
    min-width: unset;
    width: 120px;
    padding: 0.8em 1em;
    border-radius: 20px;
}

/* --- Lists (ul, li) --- */
ul {
    list-style: none;
    padding: 0;
    margin: 1.5em 0 0;
    flex-grow: 1; /* Make lists take available space */
}

ul li {
    background-color: var(--list-item-bg);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    margin-bottom: 1.2em;
    padding: 1.5em 2em;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 3px 10px rgba(0,0,0,0.05);
    transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
    flex-wrap: wrap;
    gap: 1em;
}

ul li:hover {
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.1);
}

ul li:last-child {
    margin-bottom: 0;
}

/* --- Meditation Specifics --- */
.meditation-timer-card {
    grid-column: span 1; /* Occupy single column */
}
.meditation-history-card {
    grid-column: span 1; /* Occupy single column */
}

.timer-display {
    font-size: 5.5em;
    font-weight: bold;
    color: var(--primary-color);
    text-align: center;
    margin: 1.5em 0;
    background-color: var(--meditation-timer-bg);
    padding: 0.8em 1.2em;
    border-radius: 15px;
    border: 2px solid var(--secondary-color);
    box-shadow: inset 0 3px 10px var(--shadow-light);
    transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
}

.preset-buttons, .timer-controls {
    display: flex;
    justify-content: center;
    gap: 1em;
    margin-bottom: 2em;
    flex-wrap: wrap;
}

.preset-meditation-time {
    background-color: var(--primary-color);
}
.preset-meditation-time:hover:not(:disabled) {
    background-color: var(--button-hover-darken);
}

.sound-controls {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 1em;
    margin-top: 1em;
    flex-wrap: wrap;
}
#ambient-volume {
    width: 150px;
    accent-color: var(--secondary-color);
    cursor: pointer;
}

.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 1.2em;
    background-color: var(--stats-grid-bg);
    padding: 1.8em;
    border-radius: 12px;
    border: 1px solid var(--border-color);
    box-shadow: inset 0 2px 8px var(--shadow-light);
    transition: background-color 0.3s ease, border-color 0.3s ease;
}

.stats-grid div {
    padding: 1em;
    border-bottom: 1px dashed var(--border-color);
    display: flex;
    flex-direction: column;
    gap: 0.3em;
}

.stats-grid div:nth-last-child(-n+2) { /* remove bottom border from last two items */
    border-bottom: none;
}
@media (max-width: 600px) { /* On smaller screens, single column */
    .stats-grid div:nth-last-child(-n+2) { border-bottom: 1px dashed var(--border-color); }
    .stats-grid div:last-child { border-bottom: none; }
}


.stats-grid strong {
    color: var(--primary-color);
    font-size: 1.1em;
    font-weight: 600;
}

/* --- Book Specifics --- */
.book-input-area, .search-input-area {
    display: flex;
    gap: 1em;
    margin-bottom: 1.8em;
    flex-wrap: wrap;
    align-items: center;
}
.book-input-area .input-field {
    flex: 1 1 180px; /* Allow fields to grow but have a base */
}
.book-input-area .small-input {
    flex: 0 0 100px; /* Fixed size for pages */
}
.book-input-area button {
    flex-shrink: 0;
}
.book-item-info {
    flex: 1 1 55%;
    display: flex;
    flex-direction: column;
    gap: 0.5em;
}

.book-item-info span {
    font-size: 0.95em;
    opacity: 0.85;
}
.book-item-info strong {
    font-size: 1.2em;
    color: var(--primary-color);
}

.book-item-controls {
    display: flex;
    gap: 0.8em;
    flex-wrap: wrap;
    justify-content: flex-end;
}

.book-item-controls button {
    padding: 0.7em 1.4em;
    font-size: 0.95em;
    border-radius: 25px;
}

.book-cover-thumbnail {
    width: 60px;
    height: 90px;
    object-fit: cover;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    margin-right: 1em;
    flex-shrink: 0;
}

/* --- Statistics Section --- */
.chart-container {
    padding: 1.5em;
    background-color: var(--background-gradient-start);
    border-radius: 10px;
    border: 1px solid var(--border-color);
    margin-top: 1.5em;
}

/* Meditation Calendar */
.meditation-calendar {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 5px;
    padding: 1em;
    border: 1px solid var(--border-color);
    border-radius: 10px;
    background-color: var(--stats-grid-bg);
}

.calendar-header {
    grid-column: 1 / -1;
    text-align: center;
    font-weight: bold;
    font-size: 1.2em;
    margin-bottom: 10px;
    color: var(--primary-color);
}

.calendar-day-name, .calendar-day {
    padding: 8px;
    text-align: center;
    border-radius: 5px;
    font-size: 0.9em;
    background-color: var(--card-background);
    border: 1px solid var(--border-color);
}

.calendar-day-name {
    font-weight: bold;
    background-color: var(--secondary-color);
    color: var(--light-text-color);
}

.calendar-day.empty {
    background-color: var(--background-gradient-start);
    border-color: transparent;
}

.calendar-day.meditated {
    background-color: var(--success-color); /* Green for meditated days */
    color: white;
    font-weight: bold;
    border-color: var(--success-hover);
    box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
}

.calendar-day.current-day {
    border: 2px solid var(--accent-color);
    box-shadow: 0 0 0 2px var(--accent-color);
}

/* --- Goals Section --- */
.goal-input-area {
    display: flex;
    gap: 1em;
    margin-bottom: 2em;
    flex-wrap: wrap;
    align-items: center;
}
.goal-input-area .input-field {
    flex: 1 1 150px;
}
.goal-input-area .small-input {
    flex: 0 0 100px;
}

.goal-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1em 1.5em;
    border-radius: 10px;
    background-color: var(--list-item-bg);
    border: 1px solid var(--border-color);
    margin-bottom: 1em;
    flex-wrap: wrap;
    gap: 1em;
}

.goal-item.completed {
    opacity: 0.7;
    text-decoration: line-through;
    background-color: var(--success-color);
    color: var(--light-text-color);
}

.goal-progress-bar-container {
    width: 100%;
    height: 8px;
    background-color: var(--progress-bar-bg);
    border-radius: 4px;
    margin-top: 0.5em;
    overflow: hidden;
}

.goal-progress-bar {
    height: 100%;
    background-color: var(--secondary-color);
    width: 0%;
    border-radius: 4px;
    transition: width 0.5s ease;
}
.goal-item.completed .goal-progress-bar {
    background-color: var(--light-text-color);
}

/* --- Achievements Section --- */
.achievements-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 1.5em;
    padding: 1em;
}

.achievement-card {
    background-color: var(--list-item-bg);
    border: 1px solid var(--border-color);
    border-radius: 15px;
    padding: 1.5em;
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 10px var(--shadow-light);
    transition: transform 0.2s ease, opacity 0.2s ease;
}

.achievement-card i {
    font-size: 3em;
    color: #ccc; /* Default grey for locked */
    margin-bottom: 0.5em;
}

.achievement-card.unlocked {
    background-color: var(--background-gradient-end);
    border-color: var(--accent-color);
    box-shadow: 0 4px 15px var(--warning-color);
}

.achievement-card.unlocked i {
    color: var(--accent-color);
    text-shadow: 0 0 10px var(--accent-color);
}

.achievement-card h4 {
    margin: 0.5em 0;
    color: var(--primary-color);
    font-size: 1.2em;
}

.achievement-card p {
    font-size: 0.9em;
    opacity: 0.8;
}

/* --- Settings Section --- */
.setting-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1em 0;
    border-bottom: 1px dashed var(--border-color);
    flex-wrap: wrap; /* Allow wrapping */
    gap: 0.5em;
}

.setting-item:last-of-type {
    border-bottom: none;
}

.setting-item span {
    font-size: 1.1em;
    color: var(--text-color);
    flex-shrink: 0;
}

.setting-item .input-field, .setting-item select, .setting-item button {
    margin-left: auto; /* Push input/button to the right */
    flex-shrink: 0;
}
.data-management-buttons button {
    margin-left: 0; /* Override margin-left: auto for row buttons */
}
.data-management-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 1em;
    justify-content: center;
}

/* Toggle Switch (reused) */
.switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 28px;
}
.switch input { opacity: 0; width: 0; height: 0; }
.slider {
    position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
    background-color: #ccc; -webkit-transition: .4s; transition: .4s; border-radius: 28px;
}
.slider:before {
    position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px;
    background-color: white; -webkit-transition: .4s; transition: .4s; border-radius: 50%;
}
input:checked + .slider { background-color: var(--secondary-color); }
input:focus + .slider { box-shadow: 0 0 1px var(--secondary-color); }
input:checked + .slider:before { -webkit-transform: translateX(22px); -ms-transform: translateX(22px); transform: translateX(22px); }

#bell-volume {
    width: 150px;
    accent-color: var(--secondary-color);
    cursor: pointer;
}

hr {
    border: none;
    border-top: 1px solid var(--border-color);
    margin: 2em 0;
}

/* --- Footer --- */
footer {
    text-align: center;
    padding: 1.8em;
    margin-top: 3em;
    background-color: var(--primary-color);
    color: var(--light-text-color);
    font-size: 0.9em;
    box-shadow: 0 -4px 12px var(--shadow-medium);
}

/* --- Modals --- */
.modal {
    display: none;
    position: fixed;
    z-index: 200;
    left: 0; top: 0;
    width: 100%; height: 100%;
    overflow: auto;
    background-color: var(--modal-bg);
    padding-top: 60px;
    animation: fadeIn 0.3s ease-out;
}

.modal-content {
    background-color: var(--modal-content-bg);
    margin: 3% auto;
    padding: 3em;
    border: 1px solid var(--border-color);
    border-radius: 20px;
    width: 90%;
    max-width: 700px;
    box-shadow: 0 15px 40px var(--shadow-medium);
    position: relative;
    animation: slideInTop 0.4s ease-out;
    color: var(--text-color);
    max-height: 90vh; /* Limit height to prevent overflow */
    overflow-y: auto; /* Scroll content if too tall */
}

.modal-content h2 {
    color: var(--primary-color);
    border-bottom: 2px solid var(--border-color);
    padding-bottom: 0.8em;
    margin-bottom: 1.5em;
}

.modal-content p {
    margin-bottom: 1em;
    line-height: 1.6;
}

.modal-content textarea {
    width: calc(100% - 24px);
    min-height: 100px;
    padding: 12px;
    border: 1px solid var(--border-color);
    border-radius: 10px;
    font-size: 1em;
    line-height: 1.5;
    resize: vertical;
    margin-bottom: 1.5em;
    background-color: var(--input-bg);
    color: var(--text-color);
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

.modal-content textarea:focus {
    border-color: var(--secondary-color);
    box-shadow: 0 0 0 3px rgba(124, 58, 237, 0.2);
}

.modal-content button {
    margin-top: 1.5em;
    width: auto;
    min-width: 150px;
}

.close-button {
    color: #aaa;
    float: right;
    font-size: 40px;
    font-weight: bold;
    position: absolute;
    right: 25px;
    top: 15px;
    cursor: pointer;
    transition: color 0.3s ease;
}

.close-button:hover {
    color: var(--primary-color);
}

.modal-actions {
    display: flex;
    justify-content: flex-end;
    gap: 1.5em;
    margin-top: 2em;
}

/* Journal Modal Specifics */
.journal-meta {
    display: flex;
    flex-wrap: wrap;
    gap: 2em;
    margin-bottom: 1.5em;
}
.mood-tracker, .energy-tracker {
    flex: 1 1 45%;
    min-width: 250px;
}
.mood-tracker h4, .energy-tracker h4 {
    margin-top: 0;
    margin-bottom: 0.8em;
    color: var(--secondary-color);
}
.mood-emojis {
    display: flex;
    gap: 0.8em;
    flex-wrap: wrap;
}
.mood-emojis .emoji {
    font-size: 2em;
    cursor: pointer;
    padding: 5px;
    border-radius: 8px;
    background-color: var(--input-bg);
    border: 1px solid var(--border-color);
    transition: transform 0.2s ease, background-color 0.2s ease;
}
.mood-emojis .emoji:hover {
    transform: scale(1.1);
    background-color: var(--background-gradient-end);
}
.mood-emojis .emoji.selected {
    background-color: var(--accent-color);
    border-color: var(--warning-hover);
    transform: scale(1.15);
    box-shadow: 0 0 10px rgba(245, 158, 11, 0.5);
}
.slider-energy {
    width: calc(100% - 40px);
    vertical-align: middle;
    accent-color: var(--secondary-color);
}
#energy-value {
    vertical-align: middle;
    font-weight: bold;
    color: var(--primary-color);
    margin-left: 10px;
}

/* Book Modal Specifics */
.book-modal-header {
    display: flex;
    gap: 1.5em;
    align-items: flex-start;
    margin-bottom: 2em;
    flex-wrap: wrap;
}
.modal-book-cover {
    width: 120px;
    height: 180px;
    object-fit: cover;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    flex-shrink: 0;
}
.book-modal-header h2 {
    margin-top: 0;
    font-size: 2em;
    border: none;
    padding: 0;
    margin-bottom: 0.5em;
}
.book-modal-header p {
    margin: 0.3em 0;
    font-size: 1.1em;
}
.book-rating .fa-star {
    color: #ccc;
    font-size: 1.5em;
    cursor: pointer;
}
.book-rating .fa-star.active {
    color: var(--accent-color);
}
.book-modal-progress {
    margin-bottom: 2em;
    padding-top: 1em;
    border-top: 1px dashed var(--border-color);
}
.progress-bar-container {
    width: 100%;
    height: 10px;
    background-color: var(--progress-bar-bg);
    border-radius: 5px;
    overflow: hidden;
    margin-top: 0.8em;
}
.progress-bar {
    height: 100%;
    background-color: var(--progress-bar-fill);
    width: 0%;
    border-radius: 5px;
    transition: width 0.5s ease;
}
#modal-book-notes-list li {
    background-color: var(--background-gradient-start);
    padding: 15px;
    margin-bottom: 10px;
    border-radius: 10px;
    border: 1px solid var(--border-color);
    gap: 0.8em;
}
#modal-book-notes-list li .note-content {
    flex-grow: 1;
    white-space: pre-wrap;
    word-break: break-word;
    font-size: 1em;
}
#modal-book-notes-list li .note-date {
    font-size: 0.8em;
    color: #777;
    text-align: right;
    width: 100%;
}
#modal-book-notes-list li .delete-note-btn {
    padding: 0.4em 0.8em;
    font-size: 0.8em;
    min-width: unset;
    margin-top: 0;
}

/* Interval Timer Modal Specifics */
.interval-step {
    display: flex;
    align-items: center;
    gap: 1em;
    margin-bottom: 1em;
    padding: 0.8em;
    border: 1px solid var(--border-color);
    border-radius: 10px;
    background-color: var(--input-bg);
    flex-wrap: wrap;
}
.interval-step label {
    font-weight: bold;
    color: var(--primary-color);
    flex-shrink: 0;
}
.interval-step input[type="number"], .interval-step select {
    width: 80px;
    padding: 0.6em;
    border-radius: 8px;
    flex-shrink: 0;
}
.interval-step .delete-step-btn {
    margin-left: auto; /* Push delete button to the right */
    padding: 0.5em 0.8em;
    font-size: 0.9em;
}
#interval-timer-modal button {
    margin-top: 1.5em;
}
#add-interval-step {
    background-color: var(--secondary-color);
}
#start-interval-meditation {
    background-color: var(--success-color);
    margin-left: 1em;
}

/* --- Toast Notifications --- */
#toast-container {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.toast {
    background-color: var(--toast-bg);
    color: var(--toast-text);
    padding: 15px 20px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    opacity: 0;
    transform: translateX(100%);
    transition: opacity 0.3s ease-out, transform 0.3s ease-out;
    min-width: 250px;
    max-width: 350px;
    display: flex;
    align-items: center;
    gap: 10px;
}

.toast.show {
    opacity: 1;
    transform: translateX(0);
}

.toast.hide {
    opacity: 0;
    transform: translateX(100%);
}

.toast i {
    font-size: 1.5em;
    color: var(--accent-color); /* Neutral color for icon */
}
.toast.success i { color: var(--success-color); }
.toast.error i { color: var(--delete-color); }
.toast.info i { color: var(--info-color); }


/* --- Keyframe Animations --- */
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes slideInTop { from { transform: translateY(-50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

/* --- Responsive Adjustments --- */
@media (max-width: 1200px) {
    .container {
        padding: 0 1em;
    }
    header h1 {
        font-size: 3em;
    }
    .main-nav .container {
        gap: 0.8em;
    }
    .nav-button {
        font-size: 1.1em;
        padding: 0.8em 1.2em;
    }
    .app-section.active-section {
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 2em;
    }
    .card {
        padding: 2.5em;
    }
    .timer-display {
        font-size: 5em;
    }
    h2 {
        font-size: 2.2em;
    }
    h3 {
        font-size: 1.6em;
    }
    .modal-content {
        max-width: 600px;
    }
}

@media (max-width: 768px) {
    header {
        padding: 1.5em 0;
    }
    header h1 {
        font-size: 2.5em;
    }
    header p {
        font-size: 1.1em;
    }
    .main-nav {
        margin-bottom: 1.5em;
        overflow-x: auto; /* Allow horizontal scrolling for many nav items */
        -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        justify-content: flex-start; /* Align to start for scrollable content */
    }
    .main-nav .container {
        flex-wrap: nowrap; /* Prevent wrapping in nav bar */
        justify-content: flex-start;
        padding: 0 1em;
        min-width: max-content; /* Ensure enough width for all buttons */
    }
    .nav-button {
        font-size: 1em;
        padding: 0.7em 1em;
    }
    .app-section.active-section {
        grid-template-columns: 1fr; /* Stack cards vertically */
        gap: 1.5em;
    }
    .card {
        padding: 2em;
    }
    .timer-display {
        font-size: 4em;
    }
    .preset-buttons, .timer-controls, .sound-controls {
        flex-direction: column;
        gap: 0.8em;
    }
    button {
        width: 100%;
        padding: 0.9em 1.5em;
        font-size: 1em;
    }
    .btn-icon {
        width: auto; /* Allow auto width for icons when stacked */
        border-radius: 30px; /* Make them pill-shaped when wider */
    }
    .book-input-area, .search-input-area {
        flex-direction: column;
        align-items: stretch; /* Stretch items to full width */
        gap: 0.8em;
    }
    .book-input-area .input-field, .search-input-area .input-field {
        width: 100%; /* Full width inputs */
    }
    .book-input-area .btn-icon, .search-input-area .btn-icon {
        width: 100%;
    }
    .book-item li {
        flex-direction: column;
        align-items: flex-start;
    }
    .book-item-controls {
        width: 100%;
        justify-content: center;
    }
    .stats-grid {
        grid-template-columns: 1fr;
    }
    .modal-content {
        width: 95%;
        padding: 2em;
        margin: 2% auto;
    }
    .close-button {
        font-size: 35px;
        right: 15px;
        top: 10px;
    }
    .journal-meta, .book-modal-header {
        flex-direction: column;
        align-items: center;
        text-align: center;
    }
    .mood-emojis {
        justify-content: center;
    }
    .setting-item {
        flex-direction: column;
        align-items: flex-start;
    }
    .setting-item span, .setting-item .input-field, .setting-item select, .setting-item button {
        margin-left: 0;
        width: 100%;
        text-align: left;
    }
    .setting-item .input-field.small-input {
        text-align: left;
    }
    .data-management-buttons {
        flex-direction: column;
    }
    #toast-container {
        top: unset;
        bottom: 20px;
        right: 10px;
        left: 10px;
    }
    .toast {
        max-width: unset;
        transform: translateY(100%);
    }
    .toast.show {
        transform: translateY(0);
    }
    .toast.hide {
        transform: translateY(100%);
    }
}

--- END FILE: style.css ---

---------------------------------------------------------------------------------------------

do the following : 

Improve the website significantly. In every aspect of it. The thing I want to tell you is that. The website in case of the CSS in case of the different themes in it. The color combination and. Texts in them. Are not well aligned and. And the default theme which is the light mode, the serene theme. The texts are not coming out great, so fix that. Whilst improving the website significantly in every aspect of it. And also guide me where can I find those sounds that you have inputted. Features. Add a timer option also. And do whatever you think is necessary in this website and. Make it look like a professional website that can be accessed through mobile phones and through desktops as well. And the main focus is mobile phones so. Users can use this website as a web application. That's all. Any other improvements you think do them? And send me the final update. Thank you.