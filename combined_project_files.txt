
--- START FILE: index.html ---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mystic Vision - Inner Journey Companion</title>
    <link rel="stylesheet" href="style.css">
    <!-- Font Awesome 6 for modern icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Chart.js for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<body>
    <header>
        <div class="container">
            <h1>Mystic Vision</h1>
            <p>Your Path to Inner Harmony & Wisdom</p>
        </div>
    </header>

    <nav class="main-nav">
        <div class="container">
            <button class="nav-button active" data-section="dashboard-section"><i class="fas fa-home"></i> Home</button>
            <button class="nav-button" data-section="meditation-section"><i class="fas fa-om"></i> Meditation</button>
            <button class="nav-button" data-section="books-section"><i class="fas fa-book-reader"></i> Books</button>
            <button class="nav-button" data-section="statistics-section"><i class="fas fa-chart-line"></i> Stats</button>
            <button class="nav-button" data-section="goals-section"><i class="fas fa-bullseye"></i> Goals</button>
            <button class="nav-button" data-section="achievements-section"><i class="fas fa-trophy"></i> Achievements</button>
            <button class="nav-button" data-section="settings-section"><i class="fas fa-cog"></i> Settings</button>
        </div>
    </nav>

    <main class="container">
        <!-- Dashboard Section -->
        <section id="dashboard-section" class="app-section active-section">
            <div class="card dashboard-welcome">
                <h2>Welcome, Seeker!</h2>
                <p class="card-description">A quick overview of your journey.</p>
                <div class="stats-grid">
                    <div><strong>Total Meditated:</strong> <span id="dash-total-med-time">0h 0m</span></div>
                    <div><strong>Sessions:</strong> <span id="dash-total-med-sessions">0</span></div>
                    <div><strong>Current Streak:</strong> <span id="dash-current-streak">0 days</span></div>
                    <div><strong>Books Read:</strong> <span id="dash-books-finished">0</span></div>
                </div>
            </div>
            <div class="card dashboard-recent-meds">
                <h3>Recent Meditations</h3>
                <ul id="dash-meditation-sessions-list" class="mini-list">
                    <!-- Recent sessions will be dynamically added here -->
                </ul>
                <button class="btn-sm" onclick="showSection('meditation-section')">View All Meditations</button>
            </div>
            <div class="card dashboard-recent-reads">
                <h3>Currently Reading</h3>
                <ul id="dash-current-reading-list" class="mini-list">
                    <!-- Currently reading books will be dynamically added here -->
                </ul>
                <button class="btn-sm" onclick="showSection('books-section')">View All Books</button>
            </div>
        </section>

        <!-- Meditation Section -->
        <section id="meditation-section" class="app-section">
            <div class="card meditation-timer-card">
                <h2><i class="fas fa-om"></i> Meditation Sanctuary</h2>
                <div class="timer-display" id="meditation-timer-display">00:00:00</div>
                <div class="meditation-controls-group">
                    <div class="preset-buttons">
                        <button class="preset-meditation-time btn-sm" data-minutes="5">5 min</button>
                        <button class="preset-meditation-time btn-sm" data-minutes="10">10 min</button>
                        <button class="preset-meditation-time btn-sm" data-minutes="20">20 min</button>
                        <button class="preset-meditation-time btn-sm" data-minutes="30">30 min</button>
                        <button id="open-interval-timer-btn" class="btn-sm"><i class="fas fa-clock"></i> Interval</button>
                    </div>
                    <div class="custom-timer-input">
                        <input type="number" id="custom-meditation-minutes" min="1" placeholder="Custom min" class="input-field small-input">
                        <button id="set-custom-meditation" class="btn-sm"><i class="fas fa-check"></i> Set</button>
                    </div>
                </div>
                
                <div class="timer-controls">
                    <button id="start-meditation"><i class="fas fa-play"></i> Start</button>
                    <button id="pause-meditation" disabled><i class="fas fa-pause"></i> Pause</button>
                    <button id="stop-meditation" disabled><i class="fas fa-stop"></i> Stop</button>
                    <button id="reset-meditation"><i class="fas fa-redo-alt"></i> Reset</button>
                </div>

                <h3>Ambient Sounds</h3>
                <div class="sound-controls">
                    <select id="ambient-sound-selector" class="input-field small-input">
                        <option value="none">None</option>
                        <option value="rain">Rain</option>
                        <option value="forest">Forest</option>
                        <option value="ocean">Ocean Waves</option>
                        <option value="chimes">Wind Chimes</option>
                    </select>
                    <input type="range" id="ambient-volume" min="0" max="1" step="0.05" value="0.5">
                </div>
            </div>

            <div class="card meditation-history-card">
                <h3><i class="fas fa-history"></i> Your Meditation Journey</h3>
                <ul id="meditation-sessions-list">
                    <!-- Meditation sessions will be dynamically added here -->
                </ul>
            </div>
        </section>

        <!-- Spiritual Books Section -->
        <section id="books-section" class="app-section">
            <div class="card card-full-width">
                <h2><i class="fas fa-book-reader"></i> Wisdom Scrolls</h2>
                <div class="book-input-area">
                    <input type="file" id="new-book-cover" accept="image/*" style="display: none;">
                    <button id="upload-book-cover-btn" class="btn-icon" title="Upload Cover Image"><i class="fas fa-image"></i></button>
                    <input type="text" id="new-book-title" placeholder="Book Title" class="input-field">
                    <input type="text" id="new-book-author" placeholder="Author (optional)" class="input-field">
                    <input type="number" id="new-book-pages" placeholder="Total Pages (optional)" class="input-field small-input">
                    <input type="text" id="new-book-genre" placeholder="Genre (optional, e.g., Spiritual, Philosophy)" class="input-field">
                    <button id="add-book"><i class="fas fa-plus"></i> Add Book</button>
                </div>
                <div class="search-input-area">
                    <input type="text" id="book-search-input" placeholder="Search books by title, author, or genre..." class="input-field">
                    <button id="clear-book-search" class="btn-icon"><i class="fas fa-times"></i></button>
                </div>
                <h3>Your Spiritual Library</h3>
                <ul id="books-list" class="book-list">
                    <!-- Books will be dynamically added here -->
                </ul>
            </div>
        </section>

        <!-- Statistics Section -->
        <section id="statistics-section" class="app-section">
            <div class="card card-full-width">
                <h2><i class="fas fa-chart-line"></i> Meditation Statistics</h2>
                <h3>Daily Meditation Time Trend</h3>
                <div class="chart-container"><canvas id="meditationTimeChart"></canvas></div>
                <h3>Meditation Session Count</h3>
                <div class="chart-container"><canvas id="meditationSessionsChart"></canvas></div>
                <h3>Mood Distribution</h3>
                <div class="chart-container"><canvas id="moodDistributionChart"></canvas></div>
                <h3>Top Meditation Tags</h3>
                <div class="chart-container"><canvas id="topTagsChart"></canvas></div>
            </div>
            <div class="card card-full-width">
                <h2><i class="fas fa-chart-pie"></i> Book Reading Statistics</h2>
                <h3>Reading Time by Book</h3>
                <div class="chart-container"><canvas id="bookReadingTimeChart"></canvas></div>
            </div>
            <div class="card card-full-width">
                <h2><i class="fas fa-calendar-alt"></i> Meditation Calendar</h2>
                <div id="meditation-calendar" class="meditation-calendar"></div>
            </div>
        </section>

        <!-- Goals Section -->
        <section id="goals-section" class="app-section">
            <div class="card card-full-width">
                <h2><i class="fas fa-bullseye"></i> Your Goals</h2>
                <div class="goal-input-area">
                    <select id="goal-type" class="input-field small-input">
                        <option value="meditation_duration">Meditation Duration</option>
                        <option value="meditation_days">Meditation Days</option>
                        <option value="books_finished">Books Finished</option>
                    </select>
                    <input type="number" id="goal-value" placeholder="Target Value" class="input-field small-input" min="1">
                    <select id="goal-period" class="input-field small-input">
                        <option value="week">Per Week</option>
                        <option value="month">Per Month</option>
                        <option value="overall">Overall</option>
                    </select>
                    <button id="add-goal"><i class="fas fa-plus"></i> Add Goal</button>
                </div>
                <h3>Active Goals</h3>
                <ul id="active-goals-list">
                    <!-- Active goals will be dynamically added here -->
                </ul>
                <h3>Completed Goals</h3>
                <ul id="completed-goals-list">
                    <!-- Completed goals will be dynamically added here -->
                </ul>
            </div>
        </section>

        <!-- Achievements Section -->
        <section id="achievements-section" class="app-section">
            <div class="card card-full-width">
                <h2><i class="fas fa-trophy"></i> Your Achievements</h2>
                <div id="achievements-grid" class="achievements-grid">
                    <!-- Achievements will be dynamically added here -->
                </div>
            </div>
        </section>

        <!-- Settings Section -->
        <section id="settings-section" class="app-section">
            <div class="card card-full-width">
                <h2><i class="fas fa-cog"></i> Settings</h2>
                <div class="setting-item">
                    <span>Theme:</span>
                    <select id="theme-selector" class="input-field small-input">
                        <option value="light">Light (Serene)</option>
                        <option value="dark">Dark (Mystic Night)</option>
                        <option value="cosmic">Cosmic Whisper</option>
                        <option value="forest">Forest Bloom</option>
                    </select>
                </div>
                <div class="setting-item">
                    <span>Custom Background Image:</span>
                    <div class="setting-buttons-group">
                        <input type="file" id="custom-background-file" accept="image/*" style="display: none;">
                        <button id="upload-custom-background-btn" class="btn-sm"><i class="fas fa-upload"></i> Upload Image</button>
                        <button id="clear-custom-background-btn" class="delete-button btn-sm"><i class="fas fa-times"></i> Clear</button>
                    </div>
                </div>
                <hr>
                <div class="setting-item">
                    <span>End Meditation Bell Sound:</span>
                    <label class="switch">
                        <input type="checkbox" id="bell-sound-toggle">
                        <span class="slider round"></span>
                    </label>
                </div>
                <div class="setting-item">
                    <span>Bell Volume:</span>
                    <input type="range" id="bell-volume" min="0" max="1" step="0.05" value="0.5">
                </div>
                <div class="setting-item">
                    <span>Daily Meditation Reminder:</span>
                    <div class="setting-buttons-group">
                        <input type="time" id="daily-reminder-time" class="input-field small-input">
                        <button id="set-daily-reminder-btn" class="btn-sm"><i class="fas fa-bell"></i> Set</button>
                        <button id="clear-daily-reminder-btn" class="delete-button btn-sm"><i class="fas fa-times"></i> Clear</button>
                    </div>
                </div>
                <hr>
                <div class="setting-item data-management-buttons">
                    <button id="export-data-btn" class="export-button"><i class="fas fa-download"></i> Export Data</button>
                    <input type="file" id="import-data-file" accept=".json" style="display: none;">
                    <button id="import-data-btn" class="import-button"><i class="fas fa-upload"></i> Import Data</button>
                    <button id="clear-all-data-btn" class="delete-button"><i class="fas fa-trash-alt"></i> Clear All Data</button>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; <span id="current-year"></span> Mystic Vision. All rights reserved.</p>
        </div>
    </footer>

    <!-- Modals -->

    <!-- Meditation Journal Modal -->
    <div id="meditation-journal-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" data-modal="meditation-journal-modal">&times;</span>
            <h2>Meditation Reflection</h2>
            <div class="journal-meta">
                <div class="mood-tracker">
                    <h4>Mood:</h4>
                    <div class="mood-emojis">
                        <span class="emoji" data-mood="calm" title="Calm">😌</span>
                        <span class="emoji" data-mood="focused" title="Focused">🧐</span>
                        <span class="emoji" data-mood="peaceful" title="Peaceful">🕊️</span>
                        <span class="emoji" data-mood="energetic" title="Energetic">⚡</span>
                        <span class="emoji" data-mood="tired" title="Tired">😴</span>
                        <span class="emoji" data-mood="anxious" title="Anxious">😟</span>
                        <span class="emoji" data-mood="happy" title="Happy">😊</span>
                    </div>
                </div>
                <div class="energy-tracker">
                    <h4>Energy Level: <span id="energy-value">5</span>/10</h4>
                    <input type="range" id="energy-level" min="0" max="10" value="5" class="slider-energy">
                </div>
            </div>
            <h4>Tags:</h4>
            <input type="text" id="journal-tags-input" placeholder="Add tags (e.g., stress, focus, morning)" class="input-field">
            <h4>Thoughts & Insights:</h4>
            <textarea id="journal-text" placeholder="Write down your thoughts, insights, or feelings..."></textarea>
            <h4>Gratitude:</h4>
            <textarea id="gratitude-text" placeholder="What are you grateful for today?"></textarea>
            <button id="save-journal-entry">Save Reflection</button>
        </div>
    </div>

    <!-- Book Details/Notes Modal -->
    <div id="book-details-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" data-modal="book-details-modal">&times;</span>
            <div class="book-modal-header">
                <img id="modal-book-cover-img" src="./img/default_book.png" alt="Book Cover" class="modal-book-cover">
                <div class="book-info-text">
                    <h2 id="modal-book-title"></h2>
                    <p><strong>Author:</strong> <span id="modal-book-author"></span></p>
                    <p><strong>Genre:</strong> <span id="modal-book-genre"></span></p>
                    <p><strong>Status:</strong> <span id="modal-book-status-container"></span></p>
                    <div class="book-rating" id="modal-book-rating">
                        <!-- Stars will be dynamically added here -->
                    </div>
                </div>
            </div>
            
            <div class="book-modal-progress">
                <p><strong>Total Pages:</strong> <span id="modal-book-total-pages"></span></p>
                <div class="page-input-group">
                    <label for="modal-book-current-page"><strong>Current Page:</strong></label>
                    <input type="number" id="modal-book-current-page" class="input-field small-input" min="0">
                </div>
                <p><strong>Progress:</strong> <span id="modal-book-progress">0%</span></p>
                <div class="progress-bar-container"><div class="progress-bar" id="modal-progress-bar"></div></div>
                <p><strong>Total Reading Time:</strong> <span id="modal-book-total-reading-time">0h 0m</span></p>
            </div>
            
            <h3>Notes</h3>
            <textarea id="modal-book-notes-input" placeholder="Add a new note..."></textarea>
            <button id="add-book-note-btn">Add Note</button>
            <ul id="modal-book-notes-list" class="notes-list">
                <!-- Book notes will be dynamically added here -->
            </ul>
        </div>
    </div>

    <!-- Interval Timer Setup Modal -->
    <div id="interval-timer-modal" class="modal">
        <div class="modal-content">
            <span class="close-button" data-modal="interval-timer-modal">&times;</span>
            <h2><i class="fas fa-clock"></i> Set Up Interval Meditation</h2>
            <div id="interval-steps-container">
                <!-- Interval steps will be dynamically added here -->
            </div>
            <button id="add-interval-step" class="btn-sm"><i class="fas fa-plus"></i> Add Step</button>
            <button id="start-interval-meditation" class="btn-success">Start Interval Meditation</button>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmation-modal" class="modal">
        <div class="modal-content modal-small">
            <span class="close-button" data-modal="confirmation-modal">&times;</span>
            <h2>Confirm Action</h2>
            <p id="confirmation-message"></p>
            <div class="modal-actions">
                <button id="confirm-action-btn" class="delete-button">Confirm</button>
                <button id="cancel-action-btn" class="secondary-button">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Toast Notifications Container -->
    <div id="toast-container"></div>

    <script src="script.js"></script>
</body>
</html>

--- END FILE: index.html ---

--- START FILE: README.md ---

Website link : https://mysticvision-meditation-companion-app.netlify.app/


--- END FILE: README.md ---

--- START FILE: script.js ---

document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements Cache ---
    const elements = {
        // Main Navigation
        navButtons: document.querySelectorAll('.nav-button'),
        appSections: document.querySelectorAll('.app-section'),

        // Dashboard
        dashTotalMedTime: document.getElementById('dash-total-med-time'),
        dashTotalMedSessions: document.getElementById('dash-total-med-sessions'),
        dashCurrentStreak: document.getElementById('dash-current-streak'),
        dashBooksFinished: document.getElementById('dash-books-finished'),
        dashMeditationSessionsList: document.getElementById('dash-meditation-sessions-list'),
        dashCurrentReadingList: document.getElementById('dash-current-reading-list'),

        // Meditation Section
        meditationTimerDisplay: document.getElementById('meditation-timer-display'),
        startMeditationBtn: document.getElementById('start-meditation'),
        pauseMeditationBtn: document.getElementById('pause-meditation'),
        stopMeditationBtn: document.getElementById('stop-meditation'),
        resetMeditationBtn: document.getElementById('reset-meditation'),
        presetMeditationButtons: document.querySelectorAll('.preset-meditation-time'),
        customMeditationMinutesInput: document.getElementById('custom-meditation-minutes'),
        setCustomMeditationBtn: document.getElementById('set-custom-meditation'),
        meditationSessionsList: document.getElementById('meditation-sessions-list'),
        openIntervalTimerBtn: document.getElementById('open-interval-timer-btn'),
        ambientSoundSelector: document.getElementById('ambient-sound-selector'),
        ambientVolumeControl: document.getElementById('ambient-volume'),

        // Book Section
        newBookCoverInput: document.getElementById('new-book-cover'),
        uploadBookCoverBtn: document.getElementById('upload-book-cover-btn'),
        newBookTitleInput: document.getElementById('new-book-title'),
        newBookAuthorInput: document.getElementById('new-book-author'),
        newBookPagesInput: document.getElementById('new-book-pages'),
        newBookGenreInput: document.getElementById('new-book-genre'),
        addBookBtn: document.getElementById('add-book'),
        booksList: document.getElementById('books-list'),
        bookSearchInput: document.getElementById('book-search-input'),
        clearBookSearchBtn: document.getElementById('clear-book-search'),

        // Statistics Section
        meditationTimeChartCanvas: document.getElementById('meditationTimeChart'),
        meditationSessionsChartCanvas: document.getElementById('meditationSessionsChart'),
        moodDistributionChartCanvas: document.getElementById('moodDistributionChart'),
        topTagsChartCanvas: document.getElementById('topTagsChart'),
        bookReadingTimeChartCanvas: document.getElementById('bookReadingTimeChart'),
        meditationCalendar: document.getElementById('meditation-calendar'),

        // Goals Section
        goalTypeSelect: document.getElementById('goal-type'),
        goalValueInput: document.getElementById('goal-value'),
        goalPeriodSelect: document.getElementById('goal-period'),
        addGoalBtn: document.getElementById('add-goal'),
        activeGoalsList: document.getElementById('active-goals-list'),
        completedGoalsList: document.getElementById('completed-goals-list'),

        // Achievements Section
        achievementsGrid: document.getElementById('achievements-grid'),

        // Settings Section
        themeSelector: document.getElementById('theme-selector'),
        customBackgroundFileInput: document.getElementById('custom-background-file'),
        uploadCustomBackgroundBtn: document.getElementById('upload-custom-background-btn'),
        clearCustomBackgroundBtn: document.getElementById('clear-custom-background-btn'),
        bellSoundToggle: document.getElementById('bell-sound-toggle'),
        bellVolumeControl: document.getElementById('bell-volume'),
        dailyReminderTimeInput: document.getElementById('daily-reminder-time'),
        setDailyReminderBtn: document.getElementById('set-daily-reminder-btn'),
        clearDailyReminderBtn: document.getElementById('clear-daily-reminder-btn'),
        exportDataBtn: document.getElementById('export-data-btn'),
        importDataFile: document.getElementById('import-data-file'),
        importDataBtn: document.getElementById('import-data-btn'),
        clearAllDataBtn: document.getElementById('clear-all-data-btn'),

        // Modals
        meditationJournalModal: document.getElementById('meditation-journal-modal'),
        journalMoodEmojis: document.querySelectorAll('.mood-emojis .emoji'),
        journalEnergyLevel: document.getElementById('energy-level'),
        journalEnergyValue: document.getElementById('energy-value'),
        journalTagsInput: document.getElementById('journal-tags-input'),
        journalTextInput: document.getElementById('journal-text'),
        gratitudeTextInput: document.getElementById('gratitude-text'),
        saveJournalEntryBtn: document.getElementById('save-journal-entry'),

        bookDetailsModal: document.getElementById('book-details-modal'),
        modalBookCoverImg: document.getElementById('modal-book-cover-img'),
        modalBookTitle: document.getElementById('modal-book-title'),
        modalBookAuthor: document.getElementById('modal-book-author'),
        modalBookGenre: document.getElementById('modal-book-genre'),
        modalBookStatusContainer: document.getElementById('modal-book-status-container'), // This will hold the select dropdown
        modalBookRating: document.getElementById('modal-book-rating'),
        modalBookTotalPages: document.getElementById('modal-book-total-pages'),
        modalBookCurrentPage: document.getElementById('modal-book-current-page'),
        modalBookProgress: document.getElementById('modal-book-progress'),
        modalProgressBar: document.getElementById('modal-progress-bar'),
        modalBookTotalReadingTime: document.getElementById('modal-book-total-reading-time'),
        modalBookNotesInput: document.getElementById('modal-book-notes-input'),
        addBookNoteBtn: document.getElementById('add-book-note-btn'),
        modalBookNotesList: document.getElementById('modal-book-notes-list'),

        intervalTimerModal: document.getElementById('interval-timer-modal'),
        intervalStepsContainer: document.getElementById('interval-steps-container'),
        addIntervalStepBtn: document.getElementById('add-interval-step'),
        startIntervalMeditationBtn: document.getElementById('start-interval-meditation'),

        confirmationModal: document.getElementById('confirmation-modal'),
        confirmationMessage: document.getElementById('confirmation-message'),
        confirmActionBtn: document.getElementById('confirm-action-btn'),
        cancelActionBtn: document.getElementById('cancel-action-btn'),

        closeButtons: document.querySelectorAll('.close-button'),
        toastContainer: document.getElementById('toast-container')
    };

    // --- Global State Variables ---
    let meditationTimerInterval;
    let meditationStartTime = 0;
    let meditationElapsedTime = 0;
    let meditationPaused = false;
    let meditationDurationTarget = 0; // In milliseconds, for presets & intervals
    let meditationType = 'standard'; // 'standard' or 'interval' or 'freestyle' (for 0 duration target)
    let currentIntervalIndex = 0;
    let intervalTimerSteps = []; // [{duration, sound, label}]

    let currentReadingBookId = null;
    let bookReadingTimerInterval;
    let bookReadingStartTime = 0;

    // --- Data Structures (Persisted in localStorage) ---
    // meditationSessions: [{ id, startTime, endTime, durationMs, date, journalEntry?, mood?, energy?, tags?, type? }]
    let meditationSessions = loadData('meditationSessions', []);

    // books: [{ id, title, author, totalPages, currentPage, readingSessions: [{ startTime, endTime, durationMs }], notes: [{ id, text, date }], coverImage?, status?, rating?, genre? }]
    let books = loadData('books', []);

    // goals: [{ id, type, value, period, currentProgress, completed, startDate, endDate? }]
    let goals = loadData('goals', []);

    // settings: { theme, bellSound, bellVolume, ambientSound, ambientVolume, dailyReminderTime, customBackground }
    let settings = loadData('settings', {
        theme: 'light',
        bellSound: true,
        bellVolume: 0.5,
        ambientSound: 'none',
        ambientVolume: 0.5,
        dailyReminderTime: '',
        customBackground: null
    });

    // achievementsList: [{ id, name, description, check(), unlocked, icon }] (stored without check function)
    const achievementsList = loadData('achievementsList', [
        { id: 'first_session', name: 'First Step', description: 'Complete your first meditation session.', unlocked: false, icon: 'fas fa-shoe-prints' },
        { id: 'seven_day_streak', name: '7-Day Streak', description: 'Meditate for 7 consecutive days.', unlocked: false, icon: 'fas fa-fire' },
        { id: '30_min_meditation', name: 'Deep Dive', description: 'Complete a meditation session of 30 minutes or more.', unlocked: false, icon: 'fas fa-mountain' },
        { id: '10_hours_meditated', name: 'Seasoned Seeker', description: 'Accumulate 10 hours of meditation.', unlocked: false, icon: 'fas fa-star' },
        { id: 'first_book_finished', name: 'Wisdom Gained', description: 'Mark your first spiritual book as "Finished".', unlocked: false, icon: 'fas fa-feather-alt' },
        { id: 'five_books_finished', name: 'Enlightened Library', description: 'Finish 5 spiritual books.', unlocked: false, icon: 'fas fa-book-sparkles' },
        { id: 'first_journal_entry', name: 'Inner Voice', description: 'Write your first meditation journal entry.', unlocked: false, icon: 'fas fa-pen-nib' },
        { id: 'first_book_note', name: 'Reflective Reader', description: 'Add your first note to a spiritual book.', unlocked: false, icon: 'fas fa-highlighter' },
    ]);


    // --- Audio Context & Buffers ---
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const soundBuffers = {}; // To store loaded audio buffers
    const ambientSoundSources = {}; // To store active ambient sound sources
    let bellSoundVolumeNode, ambientSoundVolumeNode;

    // Freesound.org URLs:
    // Please note: These are example URLs from Freesound.org.
    // Always check the specific license of each sound for your use case.
    // You can download these or similar sounds from freesound.org.
    // For Freesound, you usually need to create an account to download.
    const BELL_SOUND_URL = 'https://freesound.org/data/previews/203/203061_2112423-lq.mp3'; // Meditation Bell (user: tmk_sound)
    const AMBIENT_SOUND_URLS = {
        rain: 'https://freesound.org/data/previews/25/25010_25086-lq.mp3', // Rain (user: Herbert Boland)
        forest: 'https://freesound.org/data/previews/140/140645_1955038-lq.mp3', // Forest Birds (user: dobroide)
        ocean: 'https://freesound.org/data/previews/165/165780_2984100-lq.mp3', // Ocean Waves (user: Erdie)
        chimes: 'https://freesound.org/data/previews/131/131652_2415714-lq.mp3' // Wind Chimes (user: kyles)
    };

    // --- Charts ---
    let meditationTimeChart, meditationSessionsChart, moodDistributionChart, topTagsChart, bookReadingTimeChart;


    // --- Utility Functions ---

    /**
     * Loads data from localStorage or returns a default value.
     * @param {string} key
     * @param {any} defaultValue
     * @returns {any}
     */
    function loadData(key, defaultValue) {
        try {
            const data = localStorage.getItem(key);
            return data ? JSON.parse(data) : defaultValue;
        } catch (e) {
            console.error(`Error loading data for key ${key}:`, e);
            showToast('Error loading data: Local storage might be corrupted.', 'error');
            return defaultValue;
        }
    }

    /**
     * Saves data to localStorage.
     * @param {string} key
     * @param {any} data
     */
    function saveData(key, data) {
        try {
            localStorage.setItem(key, JSON.stringify(data));
        } catch (e) {
            console.error(`Error saving data for key ${key}:`, e);
            showToast('Not enough storage space. Please clear some data.', 'error');
        }
    }

    /**
     * Formats milliseconds into HH:MM:SS string.
     * @param {number} ms
     * @returns {string}
     */
    function formatTime(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        return [hours, minutes, seconds]
            .map(unit => String(unit).padStart(2, '0'))
            .join(':');
    }

    /**
     * Formats milliseconds into human-readable hours and minutes.
     * @param {number} ms
     * @returns {string}
     */
    function formatDuration(ms) {
        if (ms === 0) return '0m';
        const totalMinutes = Math.floor(ms / (1000 * 60));
        const hours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;
        if (hours > 0) {
            return `${hours}h ${minutes}m`;
        }
        return `${minutes}m`;
    }

    /**
     * Generates a unique ID.
     * @returns {string}
     */
    function generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
    }

    /**
     * Opens a modal.
     * @param {HTMLElement} modalElement
     */
    function openModal(modalElement) {
        modalElement.style.display = 'block';
        document.body.classList.add('modal-open');
    }

    /**
     * Closes a modal.
     * @param {HTMLElement} modalElement
     */
    function closeModal(modalElement) {
        modalElement.style.display = 'none';
        document.body.classList.remove('modal-open');
    }

    /**
     * Shows a toast notification.
     * @param {string} message
     * @param {string} type 'success', 'error', 'info', 'warning'
     */
    function showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        let icon = '';
        if (type === 'success') icon = '<i class="fas fa-check-circle"></i>';
        else if (type === 'error') icon = '<i class="fas fa-exclamation-triangle"></i>';
        else if (type === 'warning') icon = '<i class="fas fa-exclamation-circle"></i>';
        else icon = '<i class="fas fa-info-circle"></i>';

        toast.innerHTML = `${icon} <span>${message}</span>`;
        elements.toastContainer.appendChild(toast);

        // Allow reflow for transition
        void toast.offsetWidth; // Trigger reflow
        toast.classList.add('show');

        setTimeout(() => {
            toast.classList.remove('show');
            toast.classList.add('hide');
            toast.addEventListener('transitionend', () => toast.remove(), { once: true });
        }, 3000);
    }

    // --- Audio Functions ---
    async function loadSound(url, name) {
        try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            soundBuffers[name] = await audioContext.decodeAudioData(arrayBuffer);
            // console.log(`Sound ${name} loaded.`);
        } catch (error) {
            console.error(`Error loading sound ${name}:`, error);
            showToast(`Could not load sound: ${name}.`, 'error');
        }
    }

    function playSound(buffer, volumeNode, loop = false) {
        if (!buffer) {
            console.warn(`Attempted to play undefined sound buffer: ${buffer}`);
            return null;
        }
        if (audioContext.state === 'suspended') {
            audioContext.resume(); // Resume audio context if it's suspended (e.g., on first user interaction)
        }

        const source = audioContext.createBufferSource();
        source.buffer = buffer;
        source.loop = loop;
        source.connect(volumeNode);
        volumeNode.connect(audioContext.destination);
        source.start(0);
        return source;
    }

    function stopSound(source) {
        if (source) {
            try {
                source.stop();
                source.disconnect();
            } catch (e) {
                // Audio node might have already stopped or been disconnected
                // console.warn("Error stopping sound source (might already be stopped):", e);
            }
        }
    }

    function updateVolumeNodes() {
        if (!bellSoundVolumeNode) {
            bellSoundVolumeNode = audioContext.createGain();
            ambientSoundVolumeNode = audioContext.createGain();
        }
        bellSoundVolumeNode.gain.value = settings.bellSound ? settings.bellVolume : 0;
        ambientSoundVolumeNode.gain.value = settings.ambientVolume;
    }

    function stopAllAmbientSounds() {
        for (const key in ambientSoundSources) {
            stopSound(ambientSoundSources[key]);
            delete ambientSoundSources[key];
        }
    }

    function startAmbientSound(soundName) {
        stopAllAmbientSounds();
        if (soundName !== 'none' && soundBuffers[soundName]) {
            ambientSoundSources[soundName] = playSound(soundBuffers[soundName], ambientSoundVolumeNode, true);
        }
    }


    // --- Meditation Logic ---

    function startMeditationTimer(durationMinutes = 0, type = 'standard') {
        if (meditationTimerInterval) {
            showToast('Meditation already running!', 'warning');
            return;
        }

        meditationDurationTarget = durationMinutes * 60 * 1000;
        meditationType = type;

        if (!meditationPaused) {
            meditationStartTime = Date.now();
            meditationElapsedTime = 0;
            currentIntervalIndex = 0; // Reset for new session
        } else {
            meditationStartTime = Date.now() - meditationElapsedTime;
            meditationPaused = false;
        }

        updateMeditationButtonStates(true, false, false);
        startAmbientSound(settings.ambientSound);
        showToast('Meditation started.', 'info');

        meditationTimerInterval = setInterval(() => {
            meditationElapsedTime = Date.now() - meditationStartTime;
            elements.meditationTimerDisplay.textContent = formatTime(meditationElapsedTime);

            if (meditationType === 'standard' && meditationDurationTarget > 0 && meditationElapsedTime >= meditationDurationTarget) {
                stopMeditationTimer();
                playSound(soundBuffers['bell'], bellSoundVolumeNode);
                showToast('Meditation session completed!', 'success');
            } else if (meditationType === 'interval' && intervalTimerSteps.length > 0) {
                const totalIntervalDurationSoFar = intervalTimerSteps.slice(0, currentIntervalIndex + 1).reduce((sum, step) => sum + (step.duration * 1000), 0);

                if (meditationElapsedTime >= totalIntervalDurationSoFar) {
                    currentIntervalIndex++;
                    if (currentIntervalIndex < intervalTimerSteps.length) {
                        const nextStep = intervalTimerSteps[currentIntervalIndex];
                        playSound(soundBuffers[nextStep.sound], bellSoundVolumeNode);
                        showToast(`Next Interval: ${nextStep.label} (${nextStep.duration}s)`, 'info');
                    } else {
                        stopMeditationTimer();
                        playSound(soundBuffers['bell'], bellSoundVolumeNode);
                        showToast('Interval meditation completed!', 'success');
                    }
                }
            }
        }, 1000);
    }

    function pauseMeditationTimer() {
        if (!meditationTimerInterval) return;
        clearInterval(meditationTimerInterval);
        meditationTimerInterval = null;
        meditationPaused = true;
        updateMeditationButtonStates(false, true, false);
        stopAllAmbientSounds();
        showToast('Meditation paused.', 'info');
    }

    function stopMeditationTimer() {
        if (!meditationTimerInterval && !meditationPaused) return;

        clearInterval(meditationTimerInterval);
        meditationTimerInterval = null;
        stopAllAmbientSounds();

        const durationMs = meditationElapsedTime;

        if (durationMs > 5000) { // Only record sessions longer than 5 seconds
            const session = {
                id: generateId(),
                startTime: meditationStartTime,
                endTime: Date.now(),
                durationMs: durationMs,
                date: new Date(meditationStartTime).toDateString(),
                type: meditationType,
                mood: null,
                energy: null,
                tags: [],
                journalEntry: '',
                gratitudeEntry: ''
            };
            meditationSessions.push(session);
            saveData('meditationSessions', meditationSessions);
            renderMeditationSessions();
            updateMeditationStats();
            updateAchievements();
            updateGoals();
            openMeditationJournalModal(session.id);
            showToast('Meditation session recorded!', 'success');
        } else {
            showToast('Meditation session was too short to record (min 5s).', 'info');
        }

        resetMeditationDisplay();
    }

    function resetMeditationDisplay() {
        clearInterval(meditationTimerInterval);
        meditationTimerInterval = null;
        meditationStartTime = 0;
        meditationElapsedTime = 0;
        meditationPaused = false;
        meditationDurationTarget = 0;
        meditationType = 'standard';
        currentIntervalIndex = 0;
        stopAllAmbientSounds();
        elements.meditationTimerDisplay.textContent = '00:00:00';
        elements.customMeditationMinutesInput.value = ''; // Clear custom input
        updateMeditationButtonStates(false, true, true);
    }

    function updateMeditationButtonStates(isTimerRunning, isTimerPaused, isTimerReset) {
        elements.startMeditationBtn.disabled = isTimerRunning && !isTimerPaused;
        elements.pauseMeditationBtn.disabled = !isTimerRunning || isTimerPaused;
        elements.stopMeditationBtn.disabled = !isTimerRunning && !isTimerPaused;
        elements.resetMeditationBtn.disabled = !isTimerRunning && !isTimerPaused;
        elements.presetMeditationButtons.forEach(btn => btn.disabled = isTimerRunning);
        elements.openIntervalTimerBtn.disabled = isTimerRunning;
        elements.setCustomMeditationBtn.disabled = isTimerRunning;
        elements.customMeditationMinutesInput.disabled = isTimerRunning;
    }

    function renderMeditationSessions() {
        elements.meditationSessionsList.innerHTML = ''; // Clear all
        elements.dashMeditationSessionsList.innerHTML = ''; // Clear dashboard

        const sortedSessions = [...meditationSessions].sort((a, b) => b.startTime - a.startTime);

        if (sortedSessions.length === 0) {
            elements.meditationSessionsList.innerHTML = '<li class="info-message">No meditation sessions recorded yet. Start your journey!</li>';
        }

        sortedSessions.forEach(session => {
            const li = document.createElement('li');
            const date = new Date(session.startTime);
            const tags = session.tags && session.tags.length > 0 ? `<br><small>Tags: ${session.tags.join(', ')}</small>` : '';
            li.innerHTML = `
                <div>
                    <span class="session-date">${date.toLocaleDateString()} at ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>
                    <br><strong class="session-duration">${formatDuration(session.durationMs)}</strong> (${session.type === 'interval' ? 'Interval' : 'Standard'})
                    ${session.mood ? `<span class="session-mood-emoji" title="Mood: ${session.mood}"> ${getEmojiForMood(session.mood)}</span>` : ''}
                    ${tags}
                </div>
                <button class="view-journal-btn btn-sm" data-session-id="${session.id}" title="View/Edit Journal"><i class="fas fa-feather-alt"></i></button>
            `;
            elements.meditationSessionsList.appendChild(li);
        });

        // Dashboard recent sessions (limit to 3)
        if (sortedSessions.length > 0) {
            sortedSessions.slice(0, 3).forEach(session => {
                const li = document.createElement('li');
                const date = new Date(session.startTime);
                li.innerHTML = `
                    <span class="session-date">${date.toLocaleDateString()}: ${formatDuration(session.durationMs)}</span>
                    ${session.mood ? `<span class="session-mood-emoji" title="Mood: ${session.mood}"> ${getEmojiForMood(session.mood)}</span>` : ''}
                `;
                elements.dashMeditationSessionsList.appendChild(li);
            });
        } else {
            elements.dashMeditationSessionsList.innerHTML = '<li class="info-message">No recent meditations.</li>';
        }

        document.querySelectorAll('.view-journal-btn').forEach(btn => {
            btn.onclick = (e) => openMeditationJournalModal(e.currentTarget.dataset.sessionId);
        });
    }

    function updateMeditationStats() {
        const totalDurationMs = meditationSessions.reduce((sum, session) => sum + session.durationMs, 0);
        
        const { currentStreak, longestStreak } = calculateStreaks();

        // Update Dashboard Stats
        elements.dashTotalMedTime.textContent = formatDuration(totalDurationMs);
        elements.dashTotalMedSessions.textContent = meditationSessions.length;
        elements.dashCurrentStreak.textContent = `${currentStreak} days`;
        
        // Update Chart.js data and re-render
        renderMeditationCharts();
        renderMeditationCalendar();
    }

    function calculateStreaks() {
        if (meditationSessions.length === 0) {
            return { currentStreak: 0, longestStreak: 0 };
        }

        const uniqueDates = [...new Set(meditationSessions
            .map(session => {
                const d = new Date(session.startTime);
                return new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime(); // Normalize to midnight
            }))]
            .sort((a, b) => a - b); // Sort chronologically

        let currentStreak = 0;
        let longestStreak = 0;
        let tempCurrentStreak = 0;
        let lastDateMs = null;

        const todayMs = new Date();
        todayMs.setHours(0,0,0,0);
        const yesterdayMs = new Date(todayMs);
        yesterdayMs.setDate(todayMs.getDate() - 1);

        for (let i = 0; i < uniqueDates.length; i++) {
            const currentDateMs = uniqueDates[i];
            if (lastDateMs === null) {
                tempCurrentStreak = 1;
            } else {
                const dayDiff = (currentDateMs - lastDateMs) / (1000 * 60 * 60 * 24);
                if (dayDiff === 1) {
                    tempCurrentStreak++;
                } else if (dayDiff > 1) {
                    tempCurrentStreak = 1;
                }
            }
            longestStreak = Math.max(longestStreak, tempCurrentStreak);
            lastDateMs = currentDateMs;
        }

        // Calculate current streak based on today or yesterday
        currentStreak = 0;
        if (uniqueDates.includes(todayMs.getTime())) {
            currentStreak = tempCurrentStreak; // If today has a session, current streak is the last calculated one
        } else if (uniqueDates.includes(yesterdayMs.getTime())) {
            // If the last session was yesterday, current streak is the streak ending yesterday
            let streakEndingYesterday = 0;
            let tempDate = yesterdayMs.getTime();
            for (let i = uniqueDates.length - 1; i >= 0; i--) {
                if (uniqueDates[i] === tempDate) {
                    streakEndingYesterday++;
                    tempDate -= (1000 * 60 * 60 * 24);
                } else if (uniqueDates[i] < tempDate) {
                    break;
                }
            }
            currentStreak = streakEndingYesterday;
        }
        
        return { currentStreak, longestStreak };
    }

    function openMeditationJournalModal(sessionId) {
        const session = meditationSessions.find(s => s.id === sessionId);
        if (session) {
            // Reset mood selection
            elements.journalMoodEmojis.forEach(emoji => emoji.classList.remove('selected'));
            if (session.mood) {
                const selectedEmoji = document.querySelector(`.mood-emojis .emoji[data-mood="${session.mood}"]`);
                if (selectedEmoji) selectedEmoji.classList.add('selected');
            }

            elements.journalEnergyLevel.value = session.energy !== null ? session.energy : 5;
            elements.journalEnergyValue.textContent = elements.journalEnergyLevel.value;

            elements.journalTagsInput.value = session.tags ? session.tags.join(', ') : '';
            elements.journalTextInput.value = session.journalEntry || '';
            elements.gratitudeTextInput.value = session.gratitudeEntry || '';

            elements.saveJournalEntryBtn.onclick = () => {
                session.mood = document.querySelector('.mood-emojis .emoji.selected')?.dataset.mood || null;
                session.energy = parseInt(elements.journalEnergyLevel.value, 10);
                session.tags = elements.journalTagsInput.value.split(',').map(tag => tag.trim()).filter(tag => tag);
                session.journalEntry = elements.journalTextInput.value.trim();
                session.gratitudeEntry = elements.gratitudeTextInput.value.trim();

                saveData('meditationSessions', meditationSessions);
                closeModal(elements.meditationJournalModal);
                renderMeditationSessions(); // Re-render to show mood/tags
                updateMeditationStats(); // Re-render charts
                updateAchievements(); // Check for 'first_journal_entry' achievement
                showToast('Journal entry saved!', 'success');
            };
            openModal(elements.meditationJournalModal);
        }
    }

    function getEmojiForMood(mood) {
        switch (mood) {
            case 'calm': return '😌';
            case 'focused': return '🧐';
            case 'peaceful': return '🕊️';
            case 'energetic': return '⚡';
            case 'tired': return '😴';
            case 'anxious': return '😟';
            case 'happy': return '😊';
            default: return '';
        }
    }

    function addIntervalStep() {
        const stepCount = elements.intervalStepsContainer.children.length;
        const div = document.createElement('div');
        div.className = 'interval-step';
        div.innerHTML = `
            <label>Step ${stepCount + 1}:</label>
            <input type="number" value="60" min="5" placeholder="Seconds" data-type="duration" class="input-field small-input"><span>s</span>
            <select data-type="sound" class="input-field small-input">
                <option value="bell">Bell</option>
                <option value="chimes">Chimes</option>
            </select>
            <input type="text" placeholder="Label (e.g., Focus)" data-type="label" class="input-field">
            <button class="delete-step-btn delete-button btn-sm"><i class="fas fa-times"></i></button>
        `;
        elements.intervalStepsContainer.appendChild(div);
        div.querySelector('.delete-step-btn').onclick = (e) => e.target.closest('.interval-step').remove();
    }

    function getIntervalStepsFromUI() {
        const steps = [];
        elements.intervalStepsContainer.querySelectorAll('.interval-step').forEach(stepDiv => {
            const duration = parseInt(stepDiv.querySelector('[data-type="duration"]').value, 10);
            const sound = stepDiv.querySelector('[data-type="sound"]').value;
            const label = stepDiv.querySelector('[data-type="label"]').value || `Step ${steps.length + 1}`;
            if (!isNaN(duration) && duration > 0) {
                steps.push({ duration, sound, label });
            }
        });
        return steps;
    }

    // --- Book Tracking Logic ---

    let newBookCoverBase64 = null; // Store base64 of selected cover image

    function addBook() {
        const title = elements.newBookTitleInput.value.trim();
        const author = elements.newBookAuthorInput.value.trim();
        const totalPages = parseInt(elements.newBookPagesInput.value, 10);
        const genre = elements.newBookGenreInput.value.trim();

        if (!title) {
            showToast('Please enter a book title!', 'error');
            return;
        }

        books.push({
            id: generateId(),
            title: title,
            author: author || 'Unknown Author',
            totalPages: isNaN(totalPages) || totalPages < 0 ? 0 : totalPages,
            currentPage: 0,
            readingSessions: [],
            notes: [],
            coverImage: newBookCoverBase64,
            status: 'Want to Read',
            rating: 0,
            genre: genre
        });
        saveData('books', books);
        elements.newBookTitleInput.value = '';
        elements.newBookAuthorInput.value = '';
        elements.newBookPagesInput.value = '';
        elements.newBookGenreInput.value = '';
        newBookCoverBase64 = null; // Clear selected cover
        elements.uploadBookCoverBtn.innerHTML = '<i class="fas fa-image"></i>'; // Reset button icon
        renderBooks();
        updateBookStatistics();
        updateAchievements();
        updateGoals();
        showToast('Book added successfully!', 'success');
    }

    function startBookReading(bookId) {
        if (currentReadingBookId) {
            showToast('Please stop reading the current book before starting another.', 'info');
            return;
        }

        currentReadingBookId = bookId;
        bookReadingStartTime = Date.now();
        // Set book status to 'Reading' automatically
        const book = books.find(b => b.id === bookId);
        if (book && book.status !== 'Reading') {
            book.status = 'Reading';
            saveData('books', books);
            renderBooks();
        }
        updateBookButtonsState();
        showToast(`Started reading "${book.title}".`, 'info');
    }

    function stopBookReading(bookId) {
        if (currentReadingBookId !== bookId) return;

        clearInterval(bookReadingTimerInterval);
        const endTime = Date.now();
        const durationMs = endTime - bookReadingStartTime;

        const book = books.find(b => b.id === bookId);
        if (book && durationMs > 5000) { // Only record sessions longer than 5 seconds
            book.readingSessions.push({
                startTime: bookReadingStartTime,
                endTime: endTime,
                durationMs: durationMs
            });
            saveData('books', books);
            showToast(`Recorded ${formatDuration(durationMs)} for "${book.title}".`, 'success');
        } else if (durationMs <= 5000) {
            showToast('Reading session was too short to record (>5s required).', 'info');
        }

        currentReadingBookId = null;
        bookReadingStartTime = 0;
        updateBookButtonsState();
        renderBooks();
        updateBookStatistics();
    }

    function updateBookButtonsState() {
        document.querySelectorAll('.book-item').forEach(bookItem => {
            const bookId = bookItem.dataset.id;
            const startBtn = bookItem.querySelector('.start-reading');
            const stopBtn = bookItem.querySelector('.stop-reading');
            if (startBtn && stopBtn) {
                startBtn.disabled = currentReadingBookId !== null;
                stopBtn.disabled = currentReadingBookId !== bookId;
            }
        });
    }

    function renderBooks(filterText = '') {
        elements.booksList.innerHTML = '';
        elements.dashCurrentReadingList.innerHTML = ''; // Clear dashboard current reading

        const filteredBooks = books.filter(book => {
            const lowerCaseFilter = filterText.toLowerCase();
            return book.title.toLowerCase().includes(lowerCaseFilter) ||
                   book.author.toLowerCase().includes(lowerCaseFilter) ||
                   book.genre.toLowerCase().includes(lowerCaseFilter);
        });

        if (filteredBooks.length === 0 && filterText === '') {
            elements.booksList.innerHTML = '<li class="info-message">No spiritual books added yet. Add your first scroll of wisdom!</li>';
        } else if (filteredBooks.length === 0 && filterText !== '') {
            elements.booksList.innerHTML = `<li class="info-message">No books matching "${filterText}".</li>`;
        }

        filteredBooks.forEach(book => {
            const li = document.createElement('li');
            li.className = 'book-item';
            li.dataset.id = book.id;

            const totalReadingMs = book.readingSessions.reduce((sum, session) => sum + session.durationMs, 0);
            const progress = book.totalPages > 0 ? ((book.currentPage / book.totalPages) * 100).toFixed(1) : 0;
            const coverSrc = book.coverImage || './img/default_book.png'; // Fallback to default image

            li.innerHTML = `
                <img src="${coverSrc}" alt="Book Cover" class="book-cover-thumbnail">
                <div class="book-item-info">
                    <strong>${book.title}</strong>
                    <span>by ${book.author} | ${book.genre || 'N/A'}</span>
                    <span>Status: ${book.status} | Progress: ${book.currentPage}/${book.totalPages} (${progress}%)</span>
                    <span>Total Read: ${formatDuration(totalReadingMs)}</span>
                </div>
                <div class="book-item-controls">
                    <button class="start-reading" data-book-id="${book.id}" title="Start Reading">
                        <i class="fas fa-play"></i>
                    </button>
                    <button class="stop-reading" data-book-id="${book.id}" title="Stop Reading">
                        <i class="fas fa-stop"></i>
                    </button>
                    <button class="view-book-details btn-sm" data-book-id="${book.id}" title="View Details & Notes">
                        <i class="fas fa-info-circle"></i>
                    </button>
                    <button class="delete-book delete-button btn-sm" data-book-id="${book.id}" title="Delete Book">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                </div>
            `;
            elements.booksList.appendChild(li);
        });

        // Dashboard: Currently Reading (limit to 2)
        const currentlyReadingBooks = books.filter(book => book.status === 'Reading').slice(0, 2);
        if (currentlyReadingBooks.length > 0) {
            currentlyReadingBooks.forEach(book => {
                const li = document.createElement('li');
                const progress = book.totalPages > 0 ? ((book.currentPage / book.totalPages) * 100).toFixed(1) : 0;
                li.innerHTML = `
                    <span><strong>${book.title}</strong> by ${book.author}</span>
                    <span>Progress: ${progress}%</span>
                `;
                elements.dashCurrentReadingList.appendChild(li);
            });
        } else {
            elements.dashCurrentReadingList.innerHTML = '<li class="info-message">No books currently being read.</li>';
        }

        updateBookButtonsState(); // Set initial button states after rendering
    }

    function deleteBook(bookId) {
        if (currentReadingBookId === bookId) {
            showToast('Cannot delete a book while it is being read. Please stop the timer first.', 'error');
            return;
        }
        showConfirmationModal('Are you sure you want to delete this book and all its reading records?', () => {
            books = books.filter(book => book.id !== bookId);
            saveData('books', books);
            renderBooks();
            updateBookStatistics();
            updateAchievements();
            updateGoals();
            showToast('Book deleted successfully!', 'success');
            closeModal(elements.confirmationModal);
        });
    }

    function openBookDetailsModal(bookId) {
        const book = books.find(b => b.id === bookId);
        if (!book) return;

        elements.modalBookCoverImg.src = book.coverImage || './img/default_book.png';
        elements.modalBookTitle.textContent = book.title;
        elements.modalBookAuthor.textContent = book.author;
        elements.modalBookGenre.textContent = book.genre || 'N/A';
        
        elements.modalBookTotalPages.textContent = book.totalPages;
        elements.modalBookCurrentPage.value = book.currentPage;

        const totalReadingMs = book.readingSessions.reduce((sum, s) => sum + s.durationMs, 0);
        elements.modalBookTotalReadingTime.textContent = formatDuration(totalReadingMs);

        // Update progress bar and text
        const updateProgressDisplay = () => {
            const progress = book.totalPages > 0 ? ((book.currentPage / book.totalPages) * 100).toFixed(1) : 0;
            elements.modalBookProgress.textContent = `${progress}%`;
            elements.modalProgressBar.style.width = `${progress}%`;
            elements.modalProgressBar.ariaValueNow = progress; // For accessibility
        };
        updateProgressDisplay();

        elements.modalBookCurrentPage.onchange = (e) => {
            const newPage = parseInt(e.target.value, 10);
            if (!isNaN(newPage) && newPage >= 0 && newPage <= book.totalPages) {
                book.currentPage = newPage;
                saveData('books', books);
                updateProgressDisplay();
                renderBooks(); // Re-render main list to update progress
                updateAchievements();
                updateGoals();
            } else {
                e.target.value = book.currentPage; // Revert to previous valid page
                showToast('Invalid page number! Must be between 0 and total pages.', 'error');
            }
        };

        // Render Rating Stars
        elements.modalBookRating.innerHTML = '';
        for (let i = 1; i <= 5; i++) {
            const star = document.createElement('i');
            star.className = `fas fa-star ${i <= book.rating ? 'active' : ''}`;
            star.dataset.rating = i;
            star.onclick = () => {
                book.rating = i;
                saveData('books', books);
                openBookDetailsModal(bookId); // Re-render stars
                showToast(`Rated "${book.title}" ${i} stars.`, 'info');
            };
            elements.modalBookRating.appendChild(star);
        }

        // Dropdown for Status
        const statusSelect = document.createElement('select');
        statusSelect.className = 'input-field small-input';
        ['Reading', 'Finished', 'Want to Read'].forEach(status => {
            const option = document.createElement('option');
            option.value = status;
            option.textContent = status;
            if (book.status === status) option.selected = true;
            statusSelect.appendChild(option);
        });
        statusSelect.onchange = (e) => {
            book.status = e.target.value;
            saveData('books', books);
            renderBooks(); // Update status in main list
            updateAchievements(); // Check for 'Books Finished' achievement
            updateGoals();
            showToast(`Status for "${book.title}" changed to "${book.status}".`, 'info');
        };
        elements.modalBookStatusContainer.innerHTML = ''; // Clear previous content
        elements.modalBookStatusContainer.appendChild(statusSelect);


        elements.modalBookNotesInput.value = ''; // Clear input for new note
        renderBookNotes(book);

        elements.addBookNoteBtn.onclick = () => {
            const noteText = elements.modalBookNotesInput.value.trim();
            if (noteText) {
                book.notes.push({ id: generateId(), text: noteText, date: new Date().toISOString() });
                saveData('books', books);
                elements.modalBookNotesInput.value = '';
                renderBookNotes(book);
                showToast('Note added!', 'success');
            } else {
                showToast('Note cannot be empty!', 'warning');
            }
        };

        openModal(elements.bookDetailsModal);
    }

    function renderBookNotes(book) {
        elements.modalBookNotesList.innerHTML = '';
        if (book.notes.length === 0) {
            elements.modalBookNotesList.innerHTML = '<li class="info-message">No notes yet. Add your insights!</li>';
            return;
        }

        book.notes.sort((a,b) => new Date(b.date) - new Date(a.date)).forEach(note => { // Newest first
            const li = document.createElement('li');
            li.className = 'note-item';
            li.innerHTML = `
                <div class="note-content">${note.text}</div>
                <span class="note-date">${new Date(note.date).toLocaleDateString()} ${new Date(note.date).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>
                <button class="delete-note-btn delete-button btn-sm" data-note-id="${note.id}"><i class="fas fa-times"></i></button>
            `;
            elements.modalBookNotesList.appendChild(li);
        });

        elements.modalBookNotesList.querySelectorAll('.delete-note-btn').forEach(btn => {
            btn.onclick = (e) => {
                const noteId = e.currentTarget.dataset.noteId;
                book.notes = book.notes.filter(n => n.id !== noteId);
                saveData('books', books);
                renderBookNotes(book);
                showToast('Note deleted.', 'info');
            };
        });
    }

    // --- Statistics & Charts ---

    function createOrUpdateChart(chartVar, canvasId, type, data, options) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        if (chartVar) {
            chartVar.destroy(); // Destroy previous chart instance
        }
        return new Chart(ctx, { type, data, options });
    }

    function renderMeditationCharts() {
        // Common chart options
        const commonOptions = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { labels: { color: getComputedStyle(document.body).getPropertyValue('--text-color') } },
            },
            scales: {
                x: {
                    type: 'time',
                    time: { unit: 'day', tooltipFormat: 'MMM d, yyyy' },
                    title: { display: true, text: 'Date', color: getComputedStyle(document.body).getPropertyValue('--primary-color') },
                    ticks: { color: getComputedStyle(document.body).getPropertyValue('--text-color') },
                    grid: { color: getComputedStyle(document.body).getPropertyValue('--border-color') }
                },
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Value', color: getComputedStyle(document.body).getPropertyValue('--primary-color') },
                    ticks: { color: getComputedStyle(document.body).getPropertyValue('--text-color') },
                    grid: { color: getComputedStyle(document.body).getPropertyValue('--border-color') }
                }
            }
        };

        // Data for Meditation Time Trend (Daily)
        const dailyMedTime = {};
        meditationSessions.forEach(session => {
            const date = new Date(session.startTime).toISOString().slice(0, 10);
            dailyMedTime[date] = (dailyMedTime[date] || 0) + session.durationMs;
        });
        const sortedDates = Object.keys(dailyMedTime).sort();
        const medTimeData = sortedDates.map(date => ({ x: date, y: dailyMedTime[date] / (1000 * 60) })); // Minutes

        meditationTimeChart = createOrUpdateChart(meditationTimeChart, 'meditationTimeChart', 'line', {
            datasets: [{
                label: 'Daily Meditation Time (minutes)',
                data: medTimeData,
                borderColor: getComputedStyle(document.body).getPropertyValue('--secondary-color'),
                tension: 0.3,
                fill: true,
                backgroundColor: 'rgba(124, 58, 237, 0.2)', // Light fill for line chart
                pointRadius: 3,
                pointHoverRadius: 6
            }]
        }, { ...commonOptions, scales: { ...commonOptions.scales, y: { ...commonOptions.scales.y, title: { display: true, text: 'Minutes' } } } });

        // Data for Meditation Session Count
        const dailySessionCount = {};
        meditationSessions.forEach(session => {
            const date = new Date(session.startTime).toISOString().slice(0, 10);
            dailySessionCount[date] = (dailySessionCount[date] || 0) + 1;
        });
        const sessionCountData = sortedDates.map(date => ({ x: date, y: dailySessionCount[date] }));

        meditationSessionsChart = createOrUpdateChart(meditationSessionsChart, 'meditationSessionsChart', 'bar', {
            datasets: [{
                label: 'Daily Meditation Sessions',
                data: sessionCountData,
                backgroundColor: getComputedStyle(document.body).getPropertyValue('--primary-color'),
                borderColor: getComputedStyle(document.body).getPropertyValue('--primary-color'),
                borderWidth: 1
            }]
        }, { ...commonOptions, scales: { ...commonOptions.scales, y: { ...commonOptions.scales.y, title: { display: true, text: 'Sessions' }, ticks: { precision: 0 } } } });

        // Mood Distribution Chart
        const moodCounts = {};
        meditationSessions.forEach(session => {
            if (session.mood) {
                moodCounts[session.mood] = (moodCounts[session.mood] || 0) + 1;
            }
        });
        const moodLabels = Object.keys(moodCounts);
        const moodData = Object.values(moodCounts);
        const moodColors = moodLabels.map(mood => { // Assign consistent colors
            switch (mood) {
                case 'calm': return '#81C784'; // Greenish
                case 'focused': return '#64B5F6'; // Blueish
                case 'peaceful': return '#BA68C8'; // Purplish
                case 'energetic': return '#FFEB3B'; // Yellowish
                case 'tired': return '#90A4AE'; // Greyish
                case 'anxious': return '#EF5350'; // Reddish
                case 'happy': return '#FFD54F'; // Orangeish
                default: return '#CCCCCC';
            }
        });

        moodDistributionChart = createOrUpdateChart(moodDistributionChart, 'moodDistributionChart', 'pie', {
            labels: moodLabels,
            datasets: [{
                data: moodData,
                backgroundColor: moodColors,
                borderColor: getComputedStyle(document.body).getPropertyValue('--card-background'),
                borderWidth: 2
            }]
        }, {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'top', labels: { color: getComputedStyle(document.body).getPropertyValue('--text-color') } },
                title: { display: true, text: 'Mood Distribution', color: getComputedStyle(document.body).getPropertyValue('--primary-color') },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            let label = context.label || '';
                            if (label) {
                                label += ': ';
                            }
                            if (context.parsed !== null) {
                                label += context.parsed;
                                const total = context.dataset.data.reduce((sum, val) => sum + val, 0);
                                const percentage = ((context.parsed / total) * 100).toFixed(1) + '%';
                                label += ` (${percentage})`;
                            }
                            return label;
                        }
                    }
                }
            }
        });

        // Top Tags Chart
        const tagCounts = {};
        meditationSessions.forEach(session => {
            if (session.tags) {
                session.tags.forEach(tag => {
                    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                });
            }
        });
        const sortedTags = Object.entries(tagCounts).sort(([, a], [, b]) => b - a).slice(0, 10); // Top 10
        const tagLabels = sortedTags.map(([tag]) => tag);
        const tagData = sortedTags.map(([, count]) => count);

        topTagsChart = createOrUpdateChart(topTagsChart, 'topTagsChart', 'bar', {
            labels: tagLabels,
            datasets: [{
                label: 'Tag Usage',
                data: tagData,
                backgroundColor: getComputedStyle(document.body).getPropertyValue('--accent-color'),
                borderColor: getComputedStyle(document.body).getPropertyValue('--accent-color'),
                borderWidth: 1
            }]
        }, {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y', // Horizontal bars
            plugins: {
                legend: { labels: { color: getComputedStyle(document.body).getPropertyValue('--text-color') } },
                title: { display: true, text: 'Top Meditation Tags', color: getComputedStyle(document.body).getPropertyValue('--primary-color') }
            },
            scales: {
                x: {
                    beginAtZero: true,
                    title: { display: true, text: 'Count', color: getComputedStyle(document.body).getPropertyValue('--primary-color') },
                    ticks: { precision: 0, color: getComputedStyle(document.body).getPropertyValue('--text-color') },
                    grid: { color: getComputedStyle(document.body).getPropertyValue('--border-color') }
                },
                y: {
                    title: { display: true, text: 'Tag', color: getComputedStyle(document.body).getPropertyValue('--primary-color') },
                    ticks: { color: getComputedStyle(document.body).getPropertyValue('--text-color') },
                    grid: { color: getComputedStyle(document.body).getPropertyValue('--border-color') }
                }
            }
        });
    }

    function updateBookStatistics() {
        // Book Reading Time Chart
        const bookReadingTotals = {};
        books.forEach(book => {
            bookReadingTotals[book.title] = book.readingSessions.reduce((sum, s) => sum + s.durationMs, 0) / (1000 * 60 * 60); // Hours
        });
        const sortedBookData = Object.entries(bookReadingTotals).sort(([, a], [, b]) => b - a).filter(([, time]) => time > 0);
        const bookLabels = sortedBookData.map(([title]) => title);
        const bookData = sortedBookData.map(([, time]) => time);

        bookReadingTimeChart = createOrUpdateChart(bookReadingTimeChart, 'bookReadingTimeChart', 'bar', {
            labels: bookLabels,
            datasets: [{
                label: 'Total Reading Time (hours)',
                data: bookData,
                backgroundColor: getComputedStyle(document.body).getPropertyValue('--secondary-color'),
                borderColor: getComputedStyle(document.body).getPropertyValue('--secondary-color'),
                borderWidth: 1
            }]
        }, {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { labels: { color: getComputedStyle(document.body).getPropertyValue('--text-color') } },
                title: { display: true, text: 'Book Reading Time by Book', color: getComputedStyle(document.body).getPropertyValue('--primary-color') }
            },
            scales: {
                x: {
                    beginAtZero: true,
                    title: { display: true, text: 'Book Title', color: getComputedStyle(document.body).getPropertyValue('--primary-color') },
                    ticks: { color: getComputedStyle(document.body).getPropertyValue('--text-color') },
                    grid: { color: getComputedStyle(document.body).getPropertyValue('--border-color') }
                },
                y: {
                    title: { display: true, text: 'Hours', color: getComputedStyle(document.body).getPropertyValue('--primary-color') },
                    ticks: { color: getComputedStyle(document.body).getPropertyValue('--text-color') },
                    grid: { color: getComputedStyle(document.body).getPropertyValue('--border-color') }
                }
            }
        });
    }

    function renderMeditationCalendar() {
        elements.meditationCalendar.innerHTML = '';
        const meditatedDays = new Set(meditationSessions.map(s => new Date(s.startTime).toDateString()));

        const today = new Date();
        today.setHours(0,0,0,0);

        const now = new Date();
        const currentYear = now.getFullYear();
        const currentMonth = now.getMonth();

        // Header for the current month
        const header = document.createElement('div');
        header.className = 'calendar-header';
        header.textContent = new Date(currentYear, currentMonth).toLocaleString('default', { month: 'long', year: 'numeric' });
        elements.meditationCalendar.appendChild(header);

        // Day names
        const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        dayNames.forEach(day => {
            const div = document.createElement('div');
            div.className = 'calendar-day-name';
            div.textContent = day;
            elements.meditationCalendar.appendChild(div);
        });

        // Days of the month
        const firstDayOfMonth = new Date(currentYear, currentMonth, 1);
        const lastDayOfMonth = new Date(currentYear, currentMonth + 1, 0);
        const startDayOfWeek = firstDayOfMonth.getDay(); // 0 for Sunday, 1 for Monday...

        // Empty cells for days before the 1st
        for (let i = 0; i < startDayOfWeek; i++) {
            const div = document.createElement('div');
            div.className = 'calendar-day empty';
            elements.meditationCalendar.appendChild(div);
        }

        for (let day = 1; day <= lastDayOfMonth.getDate(); day++) {
            const date = new Date(currentYear, currentMonth, day);
            date.setHours(0,0,0,0);
            const dateString = date.toDateString();
            const div = document.createElement('div');
            div.className = 'calendar-day';
            div.textContent = day;

            if (meditatedDays.has(dateString)) {
                div.classList.add('meditated');
            }
            if (date.getTime() === today.getTime()) {
                div.classList.add('current-day');
            }
            elements.meditationCalendar.appendChild(div);
        }
    }


    // --- Goals Logic ---

    const GOAL_TYPES = {
        meditation_duration: { label: 'Meditation Duration', unit: 'minutes', getProgress: () => meditationSessions.reduce((sum, s) => sum + s.durationMs, 0) / (1000 * 60) },
        meditation_days: { label: 'Meditation Days', unit: 'days', getProgress: () => new Set(meditationSessions.map(s => s.date)).size },
        books_finished: { label: 'Books Finished', unit: 'books', getProgress: () => books.filter(b => b.status === 'Finished').length }
    };

    function addGoal() {
        const type = elements.goalTypeSelect.value;
        const value = parseInt(elements.goalValueInput.value, 10);
        const period = elements.goalPeriodSelect.value;

        if (isNaN(value) || value <= 0) {
            showToast('Please enter a valid target value for your goal (must be a positive number).', 'error');
            return;
        }

        const newGoal = {
            id: generateId(),
            type: type,
            targetValue: value,
            period: period,
            currentProgress: 0, // Will be calculated by updateGoals
            completed: false,
            startDate: new Date().toISOString(),
            lastUpdate: new Date().toISOString()
        };
        goals.push(newGoal);
        saveData('goals', goals);
        elements.goalValueInput.value = '';
        renderGoals();
        updateGoals();
        showToast('Goal added successfully!', 'success');
    }

    function updateGoals() {
        const now = new Date();
        goals.forEach(goal => {
            if (goal.completed) return; // Don't update completed goals

            let currentProgress = 0;
            let relevantMeditations = [];
            let relevantBooks = [];

            if (goal.period === 'week') {
                const startOfWeek = new Date(now);
                startOfWeek.setDate(now.getDate() - now.getDay()); // Sunday (adjust if your week starts on Monday)
                startOfWeek.setHours(0,0,0,0);
                relevantMeditations = meditationSessions.filter(s => new Date(s.startTime) >= startOfWeek);
                // For books, we'll continue to count finished books overall for simplicity, as per-week finished books is complex
                relevantBooks = books; 
            } else if (goal.period === 'month') {
                const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
                relevantMeditations = meditationSessions.filter(s => new Date(s.startTime) >= startOfMonth);
                relevantBooks = books;
            } else { // 'overall'
                relevantMeditations = meditationSessions;
                relevantBooks = books;
            }

            if (goal.type === 'meditation_duration') {
                currentProgress = relevantMeditations.reduce((sum, s) => sum + s.durationMs, 0) / (1000 * 60);
            } else if (goal.type === 'meditation_days') {
                currentProgress = new Set(relevantMeditations.map(s => new Date(s.startTime).toDateString())).size;
            } else if (goal.type === 'books_finished') {
                currentProgress = relevantBooks.filter(b => b.status === 'Finished').length;
            }

            goal.currentProgress = currentProgress;
            if (goal.currentProgress >= goal.targetValue) {
                goal.completed = true;
                goal.lastUpdate = new Date().toISOString(); // Mark completion date
                showToast(`Goal Completed: ${GOAL_TYPES[goal.type].label} of ${goal.targetValue} ${GOAL_TYPES[goal.type].unit} ${goal.period === 'overall' ? '' : 'per ' + goal.period}!`, 'success');
            }
        });
        saveData('goals', goals);
        renderGoals();
    }

    function renderGoals() {
        elements.activeGoalsList.innerHTML = '';
        elements.completedGoalsList.innerHTML = '';

        const activeGoals = goals.filter(g => !g.completed);
        const completedGoals = goals.filter(g => g.completed);

        if (activeGoals.length === 0 && completedGoals.length === 0) {
            elements.activeGoalsList.innerHTML = '<li class="info-message">No goals set yet. Set a goal to start tracking your progress!</li>';
            return;
        }

        activeGoals.forEach(goal => {
            const li = document.createElement('li');
            li.className = 'goal-item';
            const progress = Math.min(100, (goal.currentProgress / goal.targetValue) * 100).toFixed(1);
            li.innerHTML = `
                <div>
                    <strong>${GOAL_TYPES[goal.type].label}: ${goal.currentProgress.toFixed(1)} / ${goal.targetValue} ${GOAL_TYPES[goal.type].unit} ${goal.period === 'overall' ? '' : 'per ' + goal.period}</strong>
                    <div class="goal-progress-bar-container" role="progressbar" aria-valuenow="${progress}" aria-valuemin="0" aria-valuemax="100">
                        <div class="goal-progress-bar" style="width: ${progress}%"></div>
                    </div>
                    <span>Progress: ${progress}%</span>
                </div>
                <button class="delete-goal-btn delete-button btn-sm" data-id="${goal.id}" title="Delete Goal"><i class="fas fa-trash-alt"></i></button>
            `;
            elements.activeGoalsList.appendChild(li);
        });

        completedGoals.forEach(goal => {
            const li = document.createElement('li');
            li.className = 'goal-item completed';
            li.innerHTML = `
                <div>
                    <strong>${GOAL_TYPES[goal.type].label}: ${goal.targetValue} ${GOAL_TYPES[goal.type].unit} ${goal.period === 'overall' ? '' : 'per ' + goal.period}</strong>
                    <div class="goal-progress-bar-container" role="progressbar" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100">
                        <div class="goal-progress-bar" style="width: 100%"></div>
                    </div>
                    <span>Completed on: ${new Date(goal.lastUpdate).toLocaleDateString()}</span>
                </div>
                <button class="delete-goal-btn delete-button btn-sm" data-id="${goal.id}" title="Delete Goal"><i class="fas fa-trash-alt"></i></button>
            `;
            elements.completedGoalsList.appendChild(li);
        });

        document.querySelectorAll('.delete-goal-btn').forEach(btn => {
            btn.onclick = (e) => deleteGoal(e.currentTarget.dataset.id);
        });
    }

    function deleteGoal(goalId) {
        showConfirmationModal('Are you sure you want to delete this goal?', () => {
            goals = goals.filter(g => g.id !== goalId);
            saveData('goals', goals);
            renderGoals();
            showToast('Goal deleted.', 'info');
            closeModal(elements.confirmationModal);
        });
    }


    // --- Achievements Logic ---

    // Define check functions dynamically to allow for data updates
    const achievementCheckFunctions = {
        'first_session': () => meditationSessions.length >= 1,
        'seven_day_streak': () => calculateStreaks().longestStreak >= 7,
        '30_min_meditation': () => meditationSessions.some(s => s.durationMs >= 30 * 60 * 1000),
        '10_hours_meditated': () => meditationSessions.reduce((sum, s) => sum + s.durationMs, 0) >= 10 * 60 * 60 * 1000,
        'first_book_finished': () => books.some(b => b.status === 'Finished'),
        'five_books_finished': () => books.filter(b => b.status === 'Finished').length >= 5,
        'first_journal_entry': () => meditationSessions.some(s => s.journalEntry && s.journalEntry.length > 0),
        'first_book_note': () => books.some(b => b.notes && b.notes.length > 0),
    };


    function updateAchievements() {
        let changed = false;
        achievementsList.forEach(achievement => {
            // Apply the check function from the map
            if (!achievement.unlocked && achievementCheckFunctions[achievement.id] && achievementCheckFunctions[achievement.id]()) {
                achievement.unlocked = true;
                changed = true;
                showToast(`Achievement Unlocked: ${achievement.name}!`, 'success');
            }
        });
        if (changed) {
            saveData('achievementsList', achievementsList.map(a => ({ id: a.id, unlocked: a.unlocked }))); // Save only id and unlocked status
            renderAchievements();
        }
    }

    function renderAchievements() {
        elements.achievementsGrid.innerHTML = '';
        // Use the globally defined achievementsList which should have its unlocked status updated
        achievementsList.forEach(achievement => {
            const card = document.createElement('div');
            card.className = `achievement-card ${achievement.unlocked ? 'unlocked' : ''}`;
            card.innerHTML = `
                <i class="${achievement.icon}"></i>
                <h4>${achievement.name}</h4>
                <p>${achievement.description}</p>
            `;
            elements.achievementsGrid.appendChild(card);
        });
    }

    // --- Settings Logic ---

    function applySettings() {
        document.body.className = `${settings.theme}-theme`; // Set theme class
        elements.themeSelector.value = settings.theme;
        elements.bellSoundToggle.checked = settings.bellSound;
        elements.bellVolumeControl.value = settings.bellVolume;
        elements.ambientSoundSelector.value = settings.ambientSound;
        elements.ambientVolumeControl.value = settings.ambientVolume;
        elements.dailyReminderTimeInput.value = settings.dailyReminderTime;

        if (settings.customBackground) {
            document.body.style.backgroundImage = `url(${settings.customBackground})`;
            document.body.style.backgroundSize = 'cover';
            document.body.style.backgroundAttachment = 'fixed';
            document.body.style.backgroundPosition = 'center center';
        } else {
            document.body.style.backgroundImage = '';
        }

        updateVolumeNodes(); // Update gain node values
        startAmbientSound(settings.ambientSound); // Restart ambient sound if active
    }

    function saveSettings() {
        settings.theme = elements.themeSelector.value;
        settings.bellSound = elements.bellSoundToggle.checked;
        settings.bellVolume = parseFloat(elements.bellVolumeControl.value);
        settings.ambientSound = elements.ambientSoundSelector.value;
        settings.ambientVolume = parseFloat(elements.ambientVolumeControl.value);
        settings.dailyReminderTime = elements.dailyReminderTimeInput.value;

        saveData('settings', settings);
        applySettings();
        showToast('Settings saved!', 'info');
    }

    let reminderIntervalId = null;

    function setDailyReminder() {
        // Clear existing interval if any
        if (reminderIntervalId) {
            clearInterval(reminderIntervalId);
            reminderIntervalId = null;
        }

        if (!settings.dailyReminderTime) {
            showToast('Please select a time for the reminder.', 'error');
            return;
        }

        if (!('Notification' in window)) {
            showToast('This browser does not support desktop notifications.', 'error');
            return;
        }

        if (Notification.permission === 'default') {
            Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                    scheduleReminder();
                } else {
                    showToast('Notification permission denied. Cannot set reminder.', 'warning');
                }
            });
        } else if (Notification.permission === 'granted') {
            scheduleReminder();
        } else { // Permission denied or blocked
            showToast('Notification permission blocked. Please enable it in browser settings.', 'warning');
        }
    }

    function scheduleReminder() {
        const [hour, minute] = settings.dailyReminderTime.split(':').map(Number);

        // Schedule the initial notification
        const now = new Date();
        let nextReminder = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hour, minute, 0, 0);

        if (nextReminder.getTime() <= now.getTime()) {
            // If the time has already passed today, schedule for tomorrow
            nextReminder.setDate(nextReminder.getDate() + 1);
        }

        const timeUntilNextReminder = nextReminder.getTime() - now.getTime();

        // Use setTimeout for the first notification, then setInterval for daily repeats
        reminderIntervalId = setTimeout(() => {
            new Notification('Mystic Vision', {
                body: 'Time for your daily meditation!',
                icon: './img/icon.png' // Ensure you have an icon.png in your img folder
            });

            // Set interval for subsequent daily reminders (every 24 hours)
            reminderIntervalId = setInterval(() => {
                new Notification('Mystic Vision', {
                    body: 'Time for your daily meditation!',
                    icon: './img/icon.png'
                });
            }, 24 * 60 * 60 * 1000); // 24 hours
        }, timeUntilNextReminder);

        showToast(`Daily meditation reminder set for ${settings.dailyReminderTime}.`, 'success');
    }


    function clearDailyReminder() {
        if (reminderIntervalId) {
            clearInterval(reminderIntervalId);
            clearTimeout(reminderIntervalId); // Clear both in case it's the initial timeout
            reminderIntervalId = null;
        }
        settings.dailyReminderTime = '';
        saveData('settings', settings);
        elements.dailyReminderTimeInput.value = '';
        showToast('Daily reminder cleared.', 'info');
    }

    function exportData() {
        const data = {
            meditationSessions: meditationSessions,
            books: books,
            goals: goals,
            settings: settings,
            achievementsList: achievementsList.map(a => ({ id: a.id, unlocked: a.unlocked }))
        };
        const filename = `mystic_vision_data_${new Date().toISOString().slice(0, 10)}.json`;
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast('Data exported successfully!', 'success');
    }

    function importData(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const importedData = JSON.parse(e.target.result);
                showConfirmationModal('Are you sure you want to import data? This will OVERWRITE your current data!', () => {
                    if (importedData.meditationSessions) meditationSessions = importedData.meditationSessions;
                    if (importedData.books) books = importedData.books;
                    if (importedData.goals) goals = importedData.goals;
                    if (importedData.settings) settings = importedData.settings;
                    if (importedData.achievementsList) {
                        importedData.achievementsList.forEach(importedAch => {
                            const localAch = achievementsList.find(la => la.id === importedAch.id);
                            if (localAch) localAch.unlocked = importedAch.unlocked;
                        });
                    }

                    saveData('meditationSessions', meditationSessions);
                    saveData('books', books);
                    saveData('goals', goals);
                    saveData('settings', settings);
                    saveData('achievementsList', achievementsList.map(a => ({ id: a.id, unlocked: a.unlocked })));

                    initializeApp();
                    showToast('Data imported successfully! The page will refresh.', 'success');
                    closeModal(elements.confirmationModal);
                    // A full page reload might be necessary for all changes to take effect due to global state
                    setTimeout(() => window.location.reload(), 1000); 
                });
            } catch (error) {
                showToast('Error importing data: Invalid JSON file. ' + error.message, 'error');
                console.error('Import error:', error);
            } finally {
                event.target.value = ''; // Clear the file input
            }
        };
        reader.readAsText(file);
    }

    function clearAllData() {
        showConfirmationModal('Are you absolutely sure you want to clear ALL your data? This action cannot be undone!', () => {
            localStorage.clear();
            meditationSessions = [];
            books = [];
            goals = [];
            settings = { theme: 'light', bellSound: true, bellVolume: 0.5, ambientSound: 'none', ambientVolume: 0.5, dailyReminderTime: '', customBackground: null };
            achievementsList.forEach(a => a.unlocked = false); // Reset achievements
            initializeApp();
            showToast('All data cleared! The page will refresh.', 'success');
            closeModal(elements.confirmationModal);
            setTimeout(() => window.location.reload(), 1000); // Full page reload for complete reset
        });
    }

    function showConfirmationModal(message, onConfirm) {
        elements.confirmationMessage.textContent = message;
        elements.confirmActionBtn.onclick = onConfirm;
        elements.cancelActionBtn.onclick = () => closeModal(elements.confirmationModal);
        openModal(elements.confirmationModal);
    }

    // --- UI Navigation ---
    function showSection(sectionId) {
        elements.appSections.forEach(section => {
            section.classList.remove('active-section');
        });
        document.getElementById(sectionId).classList.add('active-section');

        elements.navButtons.forEach(button => {
            if (button.dataset.section === sectionId) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
        });

        // Re-render relevant sections if they were just opened
        if (sectionId === 'dashboard-section') {
            updateDashboard();
        } else if (sectionId === 'meditation-section') {
            renderMeditationSessions();
        } else if (sectionId === 'books-section') {
            renderBooks();
            elements.bookSearchInput.value = ''; // Clear search on section change
        } else if (sectionId === 'statistics-section') {
            renderMeditationCharts();
            updateBookStatistics(); // Updates book chart
            renderMeditationCalendar();
        } else if (sectionId === 'goals-section') {
            renderGoals();
        } else if (sectionId === 'achievements-section') {
            renderAchievements();
        }
    }

    function updateDashboard() {
        updateMeditationStats(); // Populates meditation stats and streaks on dashboard
        elements.dashBooksFinished.textContent = books.filter(b => b.status === 'Finished').length;
        renderMeditationSessions(); // Populates recent meditations on dashboard
        renderBooks(); // Populates currently reading on dashboard
    }

    // --- Event Listeners ---
    elements.startMeditationBtn.addEventListener('click', () => {
        const customMinutes = parseInt(elements.customMeditationMinutesInput.value, 10);
        if (!isNaN(customMinutes) && customMinutes > 0) {
            startMeditationTimer(customMinutes);
        } else {
            // If no custom minutes are set or it's 0, treat as freestyle
            startMeditationTimer(0, 'freestyle');
        }
    });

    elements.setCustomMeditationBtn.addEventListener('click', () => {
        const customMinutes = parseInt(elements.customMeditationMinutesInput.value, 10);
        if (isNaN(customMinutes) || customMinutes <= 0) {
            showToast('Please enter a valid custom duration in minutes (e.g., 15).', 'error');
            return;
        }
        showToast(`Custom meditation set for ${customMinutes} minutes. Click Start when ready!`, 'info');
    });

    elements.pauseMeditationBtn.addEventListener('click', pauseMeditationTimer);
    elements.stopMeditationBtn.addEventListener('click', stopMeditationTimer);
    elements.resetMeditationBtn.addEventListener('click', resetMeditationDisplay);

    elements.presetMeditationButtons.forEach(button => {
        button.addEventListener('click', (e) => {
            const minutes = parseInt(e.target.dataset.minutes, 10);
            elements.customMeditationMinutesInput.value = minutes; // Set custom input field
            showToast(`Meditation preset set for ${minutes} minutes. Click Start when ready!`, 'info');
        });
    });

    elements.openIntervalTimerBtn.addEventListener('click', () => {
        elements.intervalStepsContainer.innerHTML = ''; // Clear existing steps
        addIntervalStep(); // Add first default step
        openModal(elements.intervalTimerModal);
    });
    elements.addIntervalStepBtn.addEventListener('click', addIntervalStep);
    elements.startIntervalMeditationBtn.addEventListener('click', () => {
        const steps = getIntervalStepsFromUI();
        if (steps.length > 0) {
            intervalTimerSteps = steps;
            resetMeditationDisplay();
            closeModal(elements.intervalTimerModal);
            startMeditationTimer(0, 'interval'); // Duration 0 as it's interval controlled
        } else {
            showToast('Please add at least one interval step.', 'warning');
        }
    });

    elements.journalMoodEmojis.forEach(emoji => {
        emoji.addEventListener('click', () => {
            elements.journalMoodEmojis.forEach(e => e.classList.remove('selected'));
            emoji.classList.add('selected');
        });
    });
    elements.journalEnergyLevel.addEventListener('input', (e) => {
        elements.journalEnergyValue.textContent = e.target.value;
    });

    elements.addBookBtn.addEventListener('click', addBook);
    elements.uploadBookCoverBtn.addEventListener('click', () => elements.newBookCoverInput.click());
    elements.newBookCoverInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            if (file.size > 500 * 1024) { // 500 KB limit
                showToast('Image size too large! Max 500KB.', 'error');
                e.target.value = ''; // Clear the input
                newBookCoverBase64 = null;
                elements.uploadBookCoverBtn.innerHTML = '<i class="fas fa-image"></i>';
                return;
            }
            const reader = new FileReader();
            reader.onloadend = () => {
                newBookCoverBase64 = reader.result;
                elements.uploadBookCoverBtn.innerHTML = '<i class="fas fa-check"></i> Cover Ready';
                showToast('Book cover selected!', 'info');
            };
            reader.readAsDataURL(file);
        }
    });

    // Event delegation for book actions (start, stop, details, delete)
    elements.booksList.addEventListener('click', (e) => {
        const bookItem = e.target.closest('.book-item');
        if (!bookItem) return;
        const bookId = bookItem.dataset.id;

        if (e.target.classList.contains('start-reading') || e.target.closest('.start-reading')) {
            startBookReading(bookId);
        } else if (e.target.classList.contains('stop-reading') || e.target.closest('.stop-reading')) {
            stopBookReading(bookId);
        } else if (e.target.classList.contains('view-book-details') || e.target.closest('.view-book-details')) {
            openBookDetailsModal(bookId);
        } else if (e.target.classList.contains('delete-book') || e.target.closest('.delete-book')) {
            deleteBook(bookId);
        }
    });


    elements.bookSearchInput.addEventListener('input', (e) => renderBooks(e.target.value));
    elements.clearBookSearchBtn.addEventListener('click', () => {
        elements.bookSearchInput.value = '';
        renderBooks();
    });

    elements.addGoalBtn.addEventListener('click', addGoal);

    elements.navButtons.forEach(button => {
        button.addEventListener('click', () => {
            showSection(button.dataset.section);
        });
    });

    elements.closeButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
            closeModal(document.getElementById(e.currentTarget.dataset.modal));
        });
    });

    window.addEventListener('click', (event) => {
        if (event.target === elements.meditationJournalModal) closeModal(elements.meditationJournalModal);
        if (event.target === elements.bookDetailsModal) closeModal(elements.bookDetailsModal);
        if (event.target === elements.intervalTimerModal) closeModal(elements.intervalTimerModal);
        if (event.target === elements.confirmationModal) closeModal(elements.confirmationModal);
    });

    // Settings listeners
    elements.themeSelector.addEventListener('change', saveSettings);
    elements.bellSoundToggle.addEventListener('change', saveSettings);
    elements.bellVolumeControl.addEventListener('input', saveSettings);
    elements.ambientSoundSelector.addEventListener('change', saveSettings);
    elements.ambientVolumeControl.addEventListener('input', saveSettings);
    elements.setDailyReminderBtn.addEventListener('click', setDailyReminder);
    elements.clearDailyReminderBtn.addEventListener('click', clearDailyReminder);

    elements.uploadCustomBackgroundBtn.addEventListener('click', () => elements.customBackgroundFileInput.click());
    elements.customBackgroundFileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            if (file.size > 1024 * 1024) { // 1 MB limit for background
                showToast('Image size too large! Max 1MB.', 'error');
                e.target.value = '';
                return;
            }
            const reader = new FileReader();
            reader.onloadend = () => {
                settings.customBackground = reader.result;
                saveSettings();
                showToast('Custom background applied!', 'success');
            };
            reader.readAsDataURL(file);
        }
    });
    elements.clearCustomBackgroundBtn.addEventListener('click', () => {
        settings.customBackground = null;
        saveSettings();
        showToast('Custom background cleared.', 'info');
    });

    elements.exportDataBtn.addEventListener('click', exportData);
    elements.importDataBtn.addEventListener('click', () => elements.importDataFile.click());
    elements.importDataFile.addEventListener('change', importData);
    elements.clearAllDataBtn.addEventListener('click', clearAllData);


    // --- Initialization ---
    async function initializeApp() {
        // Load all sounds first
        await loadSound(BELL_SOUND_URL, 'bell');
        await loadSound(AMBIENT_SOUND_URLS.rain, 'rain');
        await loadSound(AMBIENT_SOUND_URLS.forest, 'forest');
        await loadSound(AMBIENT_SOUND_URLS.ocean, 'ocean');
        await loadSound(AMBIENT_SOUND_URLS.chimes, 'chimes');
        
        applySettings();
        updateMeditationButtonStates(false, true, true);
        renderMeditationSessions();
        updateMeditationStats();
        renderBooks();
        updateBookStatistics(); // Call to initialize book charts
        renderGoals();
        updateGoals(); // Initial goal check
        // Achievements should be updated *after* other data, then rendered
        updateAchievements(); 
        renderAchievements();

        if (settings.dailyReminderTime) {
            setDailyReminder(); // Re-schedule reminder on load
        }

        showSection('dashboard-section'); // Show dashboard by default

        document.getElementById('current-year').textContent = new Date().getFullYear();
    }

    initializeApp();
});

--- END FILE: script.js ---

--- START FILE: style.css ---

/* --- Global & Root Variables (Defaulting to Light Theme) --- */
:root {
    /* Light Theme (Serene) - Refined Palette */
    --primary-color: #5c6bc0; /* Indigo Blue */
    --secondary-color: #7986cb; /* Lighter Indigo */
    --accent-color: #ffb300; /* Amber */
    --background-gradient-start: #e8eaf6; /* Light Lavender */
    --background-gradient-end: #c5cae9; /* Medium Lavender */
    --text-color: #212121; /* Main text color for readability on light backgrounds */
    --inverted-text-color: #ffffff; /* Text color for elements with primary/secondary backgrounds (e.g., header, buttons) */
    --card-background: #ffffff;
    --border-color: #9fa8da; /* Muted Blue-grey */
    --shadow-light: rgba(0, 0, 0, 0.07);
    --shadow-medium: rgba(0, 0, 0, 0.12);
    --input-bg: #f5f5f5; /* Very light grey */
    --meditation-timer-bg: #e0e0e0; /* Slightly darker than input-bg, but still light */
    --stats-grid-bg: #f5f5f5;
    --list-item-bg: #f5f5f5;
    --modal-content-bg: #ffffff;
    --progress-bar-bg: #e0e0e0;
    --progress-bar-fill: var(--secondary-color);
    --secondary-color-alpha: rgba(121, 134, 203, 0.2); /* Alpha version of secondary for shadows */
    --button-hover-darken: #4b5a99; /* Specific darken for light theme primary */

    /* General fixed colors (not theme-dependent) */
    --delete-color: #ef4444; /* Red */
    --delete-hover: #dc2626;
    --success-color: #22c55e; /* Green */
    --success-hover: #16a34a;
    --info-color: #3b82f6; /* Blue */
    --info-hover: #2563eb;
    --warning-color: #f59e0b; /* Orange */
    --warning-hover: #d97706;
    --warning-color-rgb: 245, 158, 11; /* For rgba shadows */

    /* Modal general styles */
    --modal-bg: rgba(0, 0, 0, 0.65);
    /* Toast notifications */
    --toast-bg: rgba(33,33,33,0.9);
    --toast-text: #fff;
}

/* --- Theme Overrides --- */

/* Light Theme (Serene) - Explicitly set for clarity, though already defaults in :root */
body.light-theme {
    --primary-color: #5c6bc0;
    --secondary-color: #7986cb;
    --accent-color: #ffb300;
    --background-gradient-start: #e8eaf6;
    --background-gradient-end: #c5cae9;
    --text-color: #212121; /* Dark grey for light backgrounds */
    --inverted-text-color: #ffffff; /* White for dark backgrounds */
    --card-background: #ffffff;
    --border-color: #9fa8da;
    --shadow-light: rgba(0, 0, 0, 0.07);
    --shadow-medium: rgba(0, 0, 0, 0.12);
    --input-bg: #f5f5f5;
    --meditation-timer-bg: #e0e0e0;
    --stats-grid-bg: #f5f5f5;
    --list-item-bg: #f5f5f5;
    --modal-content-bg: #ffffff;
    --progress-bar-bg: #e0e0e0;
    --progress-bar-fill: var(--secondary-color);
    --secondary-color-alpha: rgba(121, 134, 203, 0.2);
    --button-hover-darken: #4b5a99; /* Specific darken for light theme primary */
}

/* Dark Theme (Mystic Night) */
body.dark-theme {
    --primary-color: #b39ddb; /* Deep Lilac */
    --secondary-color: #e0b0ff; /* Light Lavender */
    --accent-color: #ffd54f; /* Yellow Amber */
    --background-gradient-start: #1c0032; /* Very Dark Purple */
    --background-gradient-end: #38006b; /* Dark Purple */
    --text-color: #e0e0e0; /* Light grey for dark backgrounds */
    --inverted-text-color: #ffffff; /* White for dark backgrounds */
    --card-background: #2a004a;
    --border-color: #5d0087;
    --shadow-light: rgba(255, 255, 255, 0.05);
    --shadow-medium: rgba(255, 255, 255, 0.1);
    --input-bg: #3d006f;
    --meditation-timer-bg: #2a004a;
    --stats-grid-bg: #2a004a;
    --list-item-bg: #2a004a;
    --modal-content-bg: #2a004a;
    --button-hover-darken: #9a76cc;
    --progress-bar-bg: #4d0087;
    --progress-bar-fill: var(--primary-color);
    --secondary-color-alpha: rgba(224, 176, 255, 0.2);
    --toast-bg: rgba(0,0,0,0.9);
}

/* Cosmic Whisper Theme */
body.cosmic-theme {
    --primary-color: #6a05ad; /* Deep Violet */
    --secondary-color: #9d52d2; /* Lighter Violet */
    --accent-color: #f7b731; /* Golden Yellow */
    --background-gradient-start: #0a011a; /* Black-Blue Space */
    --background-gradient-end: #1e0539; /* Deep Purple Space */
    --text-color: #d1c4e9; /* Light Purple-grey */
    --inverted-text-color: #ffffff; /* White for dark backgrounds */
    --card-background: #15022e;
    --border-color: #3b0a68;
    --shadow-light: rgba(255, 255, 255, 0.05);
    --shadow-medium: rgba(255, 255, 255, 0.1);
    --input-bg: #28084f;
    --meditation-timer-bg: #15022e;
    --stats-grid-bg: #15022e;
    --list-item-bg: #15022e;
    --modal-content-bg: #1e0539;
    --button-hover-darken: #570494;
    --progress-bar-bg: #3b0a68;
    --progress-bar-fill: var(--secondary-color);
    --secondary-color-alpha: rgba(157, 82, 210, 0.2);
    --toast-bg: rgba(0,0,0,0.9);
}

/* Forest Bloom Theme */
body.forest-theme {
    --primary-color: #2e7d32; /* Deep Green */
    --secondary-color: #66bb6a; /* Medium Green */
    --accent-color: #ffa000; /* Dark Orange */
    --background-gradient-start: #e8f5e9; /* Very Light Green */
    --background-gradient-end: #c8e6c9; /* Light Green */
    --text-color: #388e3c; /* Darker Green text */
    --inverted-text-color: #ffffff; /* White for dark backgrounds */
    --card-background: #ffffff;
    --border-color: #a5d6a7;
    --shadow-light: rgba(0, 0, 0, 0.07);
    --shadow-medium: rgba(0, 0, 0, 0.12);
    --input-bg: #f1f8e9; /* Off-white green tint */
    --meditation-timer-bg: #c8e6c9;
    --stats-grid-bg: #f1f8e9;
    --list-item-bg: #f1f8e9;
    --modal-content-bg: #ffffff;
    --button-hover-darken: #246328;
    --progress-bar-bg: #dcedc8;
    --progress-bar-fill: var(--secondary-color);
    --secondary-color-alpha: rgba(102, 187, 106, 0.2);
    --toast-bg: rgba(0,0,0,0.85);
}


/* --- Global Styles --- */
html {
    scroll-behavior: smooth;
}

body {
    font-family: 'Segoe UI', 'Roboto', sans-serif;
    margin: 0;
    padding: 0;
    background: linear-gradient(135deg, var(--background-gradient-start), var(--background-gradient-end));
    color: var(--text-color); /* This applies the main text color */
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    box-sizing: border-box;
    transition: background-color 0.5s ease, color 0.5s ease, background-image 0.5s ease;
    overflow-y: scroll; /* Always show scrollbar to prevent layout jump */
    -webkit-font-smoothing: antialiased; /* Smoother fonts */
    -moz-osx-font-smoothing: grayscale; /* Smoother fonts */
}

/* Custom Scrollbar */
body::-webkit-scrollbar {
    width: 12px;
}

body::-webkit-scrollbar-track {
    background: var(--background-gradient-start);
}

body::-webkit-scrollbar-thumb {
    background-color: var(--secondary-color);
    border-radius: 6px;
    border: 3px solid var(--background-gradient-start);
}

body.modal-open {
    overflow: hidden; /* Prevent scrolling when modal is open */
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 0 1.5em;
}

header {
    background: linear-gradient(45deg, var(--primary-color), var(--secondary-color));
    color: var(--inverted-text-color); /* Uses the inverted text color */
    padding: 2.5em 0 1.5em;
    text-align: center;
    box-shadow: 0 6px 15px var(--shadow-medium);
    border-bottom-left-radius: 20px;
    border-bottom-right-radius: 20px;
}

header h1 {
    margin: 0;
    font-size: clamp(2.5em, 5vw, 3.8em); /* Responsive font size */
    letter-spacing: 2px;
    font-weight: 700;
    text-shadow: 2px 2px 5px rgba(0,0,0,0.3);
}

header p {
    margin: 0.5em 0 0;
    font-size: clamp(1em, 2.5vw, 1.4em); /* Responsive font size */
    opacity: 0.95;
    font-weight: 300;
}

/* --- Navigation --- */
.main-nav {
    background-color: var(--card-background);
    padding: 1em 0;
    box-shadow: 0 3px 8px var(--shadow-light);
    margin-bottom: 2.5em;
    position: sticky;
    top: 0;
    z-index: 100;
    border-bottom: 1px solid var(--border-color);
    border-top: 1px solid var(--border-color);
    display: flex; /* For horizontal scrolling container */
    overflow-x: auto; /* Allow horizontal scrolling */
    -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
}

.main-nav::-webkit-scrollbar {
    height: 6px; /* Smaller scrollbar for nav */
}
.main-nav::-webkit-scrollbar-track {
    background: var(--card-background);
}
.main-nav::-webkit-scrollbar-thumb {
    background-color: var(--border-color);
    border-radius: 3px;
}


.main-nav .container {
    display: flex;
    justify-content: center;
    gap: 1.2em;
    flex-wrap: nowrap; /* Prevent wrapping for horizontal scroll */
    padding: 0 1.5em; /* Ensure padding on ends for scroll */
    min-width: max-content; /* Ensure container is wide enough for all buttons */
}

.nav-button {
    background-color: transparent;
    border: 1px solid transparent; /* Consistent border for smooth transition */
    color: var(--primary-color);
    padding: 1em 1.8em;
    font-size: 1.15em;
    cursor: pointer;
    border-radius: 10px;
    transition: background-color 0.3s ease, color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease, border-color 0.3s ease;
    display: flex;
    align-items: center;
    gap: 10px;
    white-space: nowrap;
    font-weight: 600;
    flex-shrink: 0; /* Prevent shrinking in nav scroll */
}

.nav-button i {
    font-size: 1.2em;
}

.nav-button:hover:not(:disabled) {
    background-color: var(--background-gradient-end);
    transform: translateY(-3px);
    box-shadow: 0 4px 10px var(--shadow-light);
    border-color: var(--secondary-color);
}

.nav-button.active {
    background-color: var(--secondary-color);
    color: var(--inverted-text-color); /* Uses the inverted text color */
    box-shadow: 0 4px 12px var(--shadow-medium);
    transform: translateY(-2px);
    border-color: var(--secondary-color);
}

.nav-button.active:hover {
    background-color: var(--primary-color);
    transform: none;
    box-shadow: 0 2px 8px var(--shadow-light);
}

/* --- Main Content Layout --- */
main {
    flex-grow: 1;
    padding-bottom: 3em;
}

.app-section {
    display: none;
    opacity: 0;
    transform: translateY(30px);
    transition: opacity 0.6s ease, transform 0.6s ease;
}

.app-section.active-section {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); /* Flexible grid layout */
    gap: 2.5em;
    opacity: 1;
    transform: translateY(0);
}

/* Card Styles */
.card {
    background-color: var(--card-background);
    border-radius: 18px;
    box-shadow: 0 10px 25px var(--shadow-light);
    padding: 2.8em;
    border: 1px solid var(--border-color);
    transition: transform 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease, border-color 0.3s ease;
    display: flex;
    flex-direction: column;
}

.card:hover {
    transform: translateY(-7px);
    box-shadow: 0 15px 35px var(--shadow-medium);
}

.card-full-width {
    grid-column: 1 / -1; /* Make card span full width in grid */
}


h2 {
    color: var(--primary-color);
    margin-top: 0;
    font-size: clamp(1.8em, 4vw, 2.5em); /* Responsive font size */
    border-bottom: 2px solid var(--border-color);
    padding-bottom: 0.8em;
    margin-bottom: 1.5em;
    display: flex;
    align-items: center;
    font-weight: 700;
}

h2 i {
    margin-right: 15px;
    color: var(--accent-color);
    font-size: 1.2em;
}

h3 {
    color: var(--secondary-color);
    margin-top: 2em;
    margin-bottom: 1.5em;
    font-size: clamp(1.4em, 3vw, 1.8em); /* Responsive font size */
    border-bottom: 1px dashed var(--border-color);
    padding-bottom: 0.6em;
    font-weight: 600;
}

.card-description {
    font-size: 1.1em;
    color: var(--text-color);
    opacity: 0.9;
    margin-bottom: 1.8em;
    line-height: 1.5;
}

/* --- Buttons --- */
button {
    background-color: var(--secondary-color);
    color: var(--inverted-text-color); /* Uses the inverted text color */
    border: none;
    padding: 1em 2em;
    border-radius: 30px;
    font-size: 1.1em;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease, opacity 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    white-space: nowrap;
    font-weight: 500;
    box-shadow: 0 3px 10px rgba(0,0,0,0.1);
}

button:hover:not(:disabled) {
    background-color: var(--button-hover-darken);
    transform: translateY(-3px);
    box-shadow: 0 6px 15px var(--shadow-light);
}

button:active:not(:disabled) {
    transform: translateY(0);
    box-shadow: inset 0 3px 8px rgba(0,0,0,0.3);
}

button:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
    opacity: 0.5;
    box-shadow: none;
    transform: none;
}

.btn-sm {
    padding: 0.7em 1.4em;
    font-size: 0.95em;
    border-radius: 25px;
}

.btn-icon {
    padding: 0.7em 1em;
    font-size: 1.1em;
    border-radius: 50%;
    min-width: 44px; /* Larger touch target */
    min-height: 44px; /* Larger touch target */
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}
.btn-icon i {
    margin: 0;
}
.btn-success { background-color: var(--success-color); }
.btn-success:hover:not(:disabled) { background-color: var(--success-hover); }

.delete-button { background-color: var(--delete-color); }
.delete-button:hover:not(:disabled) { background-color: var(--delete-hover); }

.export-button { background-color: var(--success-color); }
.export-button:hover:not(:disabled) { background-color: var(--success-hover); }

.import-button { background-color: var(--info-color); }
.import-button:hover:not(:disabled) { background-color: var(--info-hover); }

.secondary-button { background-color: #9ca3af; }
.secondary-button:hover:not(:disabled) { background-color: #6b7280; }

/* --- Forms & Inputs --- */
.input-field, select {
    flex-grow: 1;
    padding: 1em 1.2em;
    border: 1px solid var(--border-color);
    border-radius: 30px;
    font-size: 1em;
    outline: none;
    transition: border-color 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease, color 0.3s ease;
    background-color: var(--input-bg);
    color: var(--text-color); /* Uses the main text color */
    min-width: 150px;
    appearance: none; /* Remove default select arrow */
    -webkit-appearance: none; /* Remove default select arrow for Safari */
}

select {
    background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%237986cb%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13.6-6.4H18.9c-5%200-9.6%202-13.6%206.4-4%204-6.4%209.6-6.4%2015.6%200%206%202.4%2011.6%206.4%2015.6l127.3%20127.3c4%204%209.6%206.4%2015.6%206.4s11.6-2.4%2015.6-6.4L287%20100.6c4-4%206.4-9.6%206.4-15.6-.2-6-2.5-11.6-6.4-15.6z%22%2F%3E%3C%2Fsvg%3E');
    background-repeat: no-repeat;
    background-position: right 1em top 50%;
    background-size: 0.8em auto;
}

.input-field:focus, select:focus {
    border-color: var(--secondary-color);
    box-shadow: 0 0 0 4px var(--secondary-color-alpha); /* Use alpha for a softer glow */
}

.small-input {
    min-width: unset;
    width: 120px;
    padding: 0.8em 1em;
    border-radius: 20px;
}

/* --- Lists (ul, li) --- */
ul {
    list-style: none;
    padding: 0;
    margin: 1.5em 0 0;
    flex-grow: 1; /* Make lists take available space */
}

ul li {
    background-color: var(--list-item-bg);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    margin-bottom: 1.2em;
    padding: 1.5em 2em;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 3px 10px rgba(0,0,0,0.03);
    transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease, border-color 0.3s ease;
    flex-wrap: wrap;
    gap: 1em;
}

ul li:hover {
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.08);
}

ul li:last-child {
    margin-bottom: 0;
}

.info-message {
    text-align: center;
    font-style: italic;
    color: var(--text-color);
    opacity: 0.7;
    padding: 1em;
}

.mini-list li { /* For dashboard recent items */
    padding: 0.8em 1.2em;
    font-size: 0.9em;
    box-shadow: none;
    border: none;
    border-bottom: 1px dashed var(--border-color);
    border-radius: 0;
    background-color: transparent;
}
.mini-list li:hover {
    transform: none;
    background-color: var(--input-bg);
}
.mini-list li:last-child {
    border-bottom: none;
}
.mini-list li .session-date, .mini-list li .session-duration {
    font-weight: 500;
}


/* --- Meditation Specifics --- */
.meditation-timer-card {
    grid-column: span 1; /* Occupy single column */
}
.meditation-history-card {
    grid-column: span 1; /* Occupy single column */
}

.timer-display {
    font-size: clamp(3.5em, 8vw, 5.5em); /* Responsive font size */
    font-weight: bold;
    color: var(--primary-color);
    text-align: center;
    margin: 1.5em 0 2em;
    background-color: var(--meditation-timer-bg);
    padding: 0.8em 1.2em;
    border-radius: 15px;
    border: 2px solid var(--secondary-color);
    box-shadow: inset 0 3px 10px var(--shadow-light);
    transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    letter-spacing: 1px;
}

.meditation-controls-group {
    display: flex;
    flex-direction: column;
    gap: 1.5em;
    margin-bottom: 2em;
}

.preset-buttons {
    display: flex;
    justify-content: center;
    gap: 1em;
    flex-wrap: wrap;
}

.preset-meditation-time {
    background-color: var(--primary-color);
    min-width: 80px; /* Ensure buttons don't get too small */
}
.preset-meditation-time:hover:not(:disabled) {
    background-color: var(--button-hover-darken);
}

.custom-timer-input {
    display: flex;
    gap: 0.8em;
    justify-content: center;
    align-items: center;
}
.custom-timer-input .input-field {
    max-width: 150px;
    text-align: center;
}
.custom-timer-input button {
    flex-shrink: 0;
}

.timer-controls {
    display: flex;
    justify-content: center;
    gap: 1em;
    margin-bottom: 2em;
    flex-wrap: wrap;
}
.timer-controls button {
    flex: 1 1 120px; /* Allow buttons to grow */
    max-width: 180px;
}
.timer-controls #start-meditation { background-color: var(--success-color); }
.timer-controls #start-meditation:hover:not(:disabled) { background-color: var(--success-hover); }

.sound-controls {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 1em;
    margin-top: 1em;
    flex-wrap: wrap;
}
#ambient-volume {
    width: 150px;
    accent-color: var(--secondary-color);
    cursor: pointer;
}

.session-mood-emoji {
    font-size: 1.2em;
    margin-left: 0.5em;
}

/* Dashboard Specifics */
.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: 1.2em;
    background-color: var(--stats-grid-bg);
    padding: 1.8em;
    border-radius: 12px;
    border: 1px solid var(--border-color);
    box-shadow: inset 0 2px 8px var(--shadow-light);
    transition: background-color 0.3s ease, border-color 0.3s ease;
}

.stats-grid div {
    padding: 0.8em;
    border-bottom: 1px dashed var(--border-color);
    display: flex;
    flex-direction: column;
    gap: 0.3em;
}

.stats-grid div:nth-child(odd) {
    border-right: 1px dashed var(--border-color); /* Separator for columns */
}
.stats-grid div:last-child,
.stats-grid div:nth-last-child(2):nth-child(odd) {
    border-bottom: none; /* Remove bottom border for last row */
}

@media (max-width: 600px) { /* On smaller screens, single column */
    .stats-grid div { border-right: none; border-bottom: 1px dashed var(--border-color); }
    .stats-grid div:last-child { border-bottom: none; }
}


.stats-grid strong {
    color: var(--primary-color);
    font-size: 1.05em;
    font-weight: 600;
}

/* --- Book Specifics --- */
.book-input-area, .search-input-area {
    display: flex;
    gap: 1em;
    margin-bottom: 1.8em;
    flex-wrap: wrap;
    align-items: center;
}
.book-input-area .input-field {
    flex: 1 1 180px; /* Allow fields to grow but have a base */
}
.book-input-area .small-input {
    flex: 0 0 100px; /* Fixed size for pages */
}
.book-input-area button {
    flex-shrink: 0;
}
.book-list li {
    padding: 1.2em 1.8em; /* Slightly less padding */
}
.book-item-info {
    flex: 1 1 50%;
    display: flex;
    flex-direction: column;
    gap: 0.5em;
}

.book-item-info span {
    font-size: 0.9em;
    opacity: 0.85;
}
.book-item-info strong {
    font-size: 1.15em;
    color: var(--primary-color);
}

.book-item-controls {
    display: flex;
    gap: 0.8em;
    flex-wrap: wrap;
    justify-content: flex-end;
}

.book-item-controls button {
    padding: 0.6em 1.2em;
    font-size: 0.9em;
    border-radius: 20px;
}

.book-cover-thumbnail {
    width: 60px;
    height: 90px;
    object-fit: cover;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    margin-right: 1em;
    flex-shrink: 0;
    border: 1px solid var(--border-color);
}

/* --- Statistics Section --- */
.chart-container {
    padding: 1.5em;
    background-color: var(--list-item-bg); /* Use list-item-bg for charts too */
    border-radius: 10px;
    border: 1px solid var(--border-color);
    margin-top: 1.5em;
    margin-bottom: 2em; /* Spacing between charts */
}

/* Meditation Calendar */
.meditation-calendar {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 5px;
    padding: 1em;
    border: 1px solid var(--border-color);
    border-radius: 10px;
    background-color: var(--list-item-bg);
}

.calendar-header {
    grid-column: 1 / -1;
    text-align: center;
    font-weight: bold;
    font-size: 1.2em;
    margin-bottom: 10px;
    color: var(--primary-color);
}

.calendar-day-name, .calendar-day {
    padding: 8px;
    text-align: center;
    border-radius: 5px;
    font-size: 0.9em;
    background-color: var(--card-background);
    border: 1px solid var(--border-color);
    min-height: 35px; /* Ensure consistent height */
    display: flex;
    align-items: center;
    justify-content: center;
}

.calendar-day-name {
    font-weight: bold;
    background-color: var(--secondary-color);
    color: var(--inverted-text-color); /* Uses the inverted text color */
    border-color: var(--primary-color);
}

.calendar-day.empty {
    background-color: var(--background-gradient-start);
    border-color: transparent;
    opacity: 0.6;
}

.calendar-day.meditated {
    background-color: var(--success-color); /* Green for meditated days */
    color: white;
    font-weight: bold;
    border-color: var(--success-hover);
    box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
}

.calendar-day.current-day {
    border: 2px solid var(--accent-color);
    box-shadow: 0 0 0 2px var(--accent-color);
    font-weight: bold;
}

/* --- Goals Section --- */
.goal-input-area {
    display: flex;
    gap: 1em;
    margin-bottom: 2em;
    flex-wrap: wrap;
    align-items: center;
}
.goal-input-area .input-field {
    flex: 1 1 150px;
}
.goal-input-area .small-input {
    flex: 0 0 100px;
}

.goal-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1em 1.5em;
    border-radius: 10px;
    background-color: var(--list-item-bg);
    border: 1px solid var(--border-color);
    margin-bottom: 1em;
    flex-wrap: wrap;
    gap: 1em;
}

.goal-item.completed {
    opacity: 0.8;
    background-color: var(--success-color);
    color: var(--inverted-text-color); /* Uses the inverted text color */
    border-color: var(--success-hover);
    box-shadow: 0 3px 10px rgba(0,0,0,0.1);
}
.goal-item.completed strong {
    color: var(--inverted-text-color); /* Uses the inverted text color */
}
.goal-item.completed span {
    color: rgba(255,255,255,0.8);
}

.goal-progress-bar-container {
    width: 100%;
    height: 8px;
    background-color: var(--progress-bar-bg);
    border-radius: 4px;
    margin-top: 0.5em;
    overflow: hidden;
}

.goal-progress-bar {
    height: 100%;
    background-color: var(--progress-bar-fill);
    width: 0%;
    border-radius: 4px;
    transition: width 0.5s ease;
}
.goal-item.completed .goal-progress-bar {
    background-color: var(--inverted-text-color); /* White progress bar for completed goals */
}

/* --- Achievements Section --- */
.achievements-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap: 1.5em;
    padding: 1em;
}

.achievement-card {
    background-color: var(--list-item-bg);
    border: 1px solid var(--border-color);
    border-radius: 15px;
    padding: 1.5em;
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 10px var(--shadow-light);
    transition: transform 0.2s ease, opacity 0.2s ease, background-color 0.3s ease, border-color 0.3s ease;
    min-height: 160px; /* Ensure consistent card height */
}

.achievement-card i {
    font-size: 3em;
    color: #a0a0a0; /* Default grey for locked */
    margin-bottom: 0.5em;
    transition: color 0.3s ease, text-shadow 0.3s ease;
}

.achievement-card.unlocked {
    background-color: var(--background-gradient-end);
    border-color: var(--accent-color);
    box-shadow: 0 4px 15px rgba(var(--warning-color-rgb), 0.3); /* Use RGB for shadow */
}

.achievement-card.unlocked i {
    color: var(--accent-color);
    text-shadow: 0 0 12px rgba(var(--warning-color-rgb), 0.7);
}

.achievement-card h4 {
    margin: 0.5em 0;
    color: var(--primary-color);
    font-size: 1.2em;
}

.achievement-card p {
    font-size: 0.9em;
    opacity: 0.8;
}

/* --- Settings Section --- */
.setting-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1em 0;
    border-bottom: 1px dashed var(--border-color);
    flex-wrap: wrap; /* Allow wrapping */
    gap: 0.8em;
}

.setting-item:last-of-type {
    border-bottom: none;
}

.setting-item span {
    font-size: 1.1em;
    color: var(--text-color); /* Uses the main text color */
    flex-shrink: 0;
}

.setting-item .input-field, .setting-item select {
    margin-left: auto; /* Push input/select to the right */
    flex-shrink: 0;
}
.setting-buttons-group {
    display: flex;
    gap: 0.8em;
    flex-wrap: wrap;
    margin-left: auto;
}
.setting-buttons-group button {
    flex-shrink: 0;
}
.data-management-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 1em;
    justify-content: center;
    margin-top: 2em;
}
.data-management-buttons button {
    flex: 1 1 140px; /* Allow buttons to grow and wrap */
}


/* Toggle Switch (reused) */
.switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 28px;
    margin-left: auto; /* Push to right */
    flex-shrink: 0;
}
.switch input { opacity: 0; width: 0; height: 0; }
.slider {
    position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
    background-color: #ccc; -webkit-transition: .4s; transition: .4s; border-radius: 28px;
}
.slider:before {
    position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px;
    background-color: white; -webkit-transition: .4s; transition: .4s; border-radius: 50%;
}
input:checked + .slider { background-color: var(--secondary-color); }
input:focus-visible + .slider { box-shadow: 0 0 0 3px var(--secondary-color-alpha); } /* Focus outline for keyboard nav */
input:checked + .slider:before { -webkit-transform: translateX(22px); -ms-transform: translateX(22px); transform: translateX(22px); }

#bell-volume {
    width: 150px;
    accent-color: var(--secondary-color);
    cursor: pointer;
    margin-left: auto;
    flex-shrink: 0;
}
#daily-reminder-time {
    width: 100px;
}

hr {
    border: none;
    border-top: 1px solid var(--border-color);
    margin: 2em 0;
}

/* --- Footer --- */
footer {
    text-align: center;
    padding: 1.8em;
    margin-top: 3em;
    background-color: var(--primary-color);
    color: var(--inverted-text-color); /* Uses the inverted text color */
    font-size: 0.9em;
    box-shadow: 0 -4px 12px var(--shadow-medium);
    border-top-left-radius: 20px;
    border-top-right-radius: 20px;
}

/* --- Modals --- */
.modal {
    display: none;
    position: fixed;
    z-index: 200;
    left: 0; top: 0;
    width: 100%; height: 100%;
    overflow: auto;
    background-color: var(--modal-bg);
    padding: 20px 0; /* Add some vertical padding */
    animation: fadeIn 0.3s ease-out;
    display: flex; /* Use flex to center content */
    align-items: center;
    justify-content: center;
}

.modal-content {
    background-color: var(--modal-content-bg);
    margin: auto; /* Center with flex */
    padding: 3em;
    border: 1px solid var(--border-color);
    border-radius: 20px;
    width: 90%;
    max-width: 700px;
    box-shadow: 0 15px 40px var(--shadow-medium);
    position: relative;
    animation: slideInTop 0.4s ease-out;
    color: var(--text-color); /* Uses the main text color */
    max-height: 95vh; /* Limit height to prevent overflow on very small screens */
    overflow-y: auto; /* Scroll content if too tall */
    display: flex; /* Make content itself a flex container for column layout */
    flex-direction: column;
}
.modal-content.modal-small {
    max-width: 450px; /* Smaller width for confirmation modal */
}

.modal-content h2 {
    color: var(--primary-color);
    border-bottom: 2px solid var(--border-color);
    padding-bottom: 0.8em;
    margin-bottom: 1.5em;
    font-size: clamp(1.6em, 3.5vw, 2.2em);
}

.modal-content h3 {
    font-size: clamp(1.2em, 2.5vw, 1.6em);
}

.modal-content p {
    margin-bottom: 1em;
    line-height: 1.6;
}

.modal-content textarea {
    width: calc(100% - 24px); /* Account for padding */
    min-height: 100px;
    padding: 12px;
    border: 1px solid var(--border-color);
    border-radius: 10px;
    font-size: 1em;
    line-height: 1.5;
    resize: vertical;
    margin-bottom: 1.5em;
    background-color: var(--input-bg);
    color: var(--text-color); /* Uses the main text color */
    transition: border-color 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease;
}

.modal-content textarea:focus {
    border-color: var(--secondary-color);
    box-shadow: 0 0 0 3px var(--secondary-color-alpha);
}

.modal-content button {
    margin-top: 1.5em;
    width: auto;
    min-width: 150px;
    align-self: flex-end; /* Push button to right */
}

.close-button {
    color: #aaa;
    float: right;
    font-size: 40px;
    font-weight: bold;
    position: absolute;
    right: 25px;
    top: 15px;
    cursor: pointer;
    transition: color 0.3s ease;
}

.close-button:hover {
    color: var(--primary-color);
}

.modal-actions {
    display: flex;
    justify-content: flex-end;
    gap: 1.5em;
    margin-top: 2em;
    flex-wrap: wrap;
}
.modal-actions button {
    margin-top: 0; /* Override default button margin-top */
    flex: 1 1 120px; /* Make buttons flexible */
    max-width: 180px;
}


/* Journal Modal Specifics */
.journal-meta {
    display: flex;
    flex-wrap: wrap;
    gap: 2em;
    margin-bottom: 1.5em;
    width: 100%;
}
.mood-tracker, .energy-tracker {
    flex: 1 1 45%;
    min-width: 280px;
}
.mood-tracker h4, .energy-tracker h4 {
    margin-top: 0;
    margin-bottom: 0.8em;
    color: var(--secondary-color);
    font-size: 1.2em;
}
.mood-emojis {
    display: flex;
    gap: 0.8em;
    flex-wrap: wrap;
}
.mood-emojis .emoji {
    font-size: 2.2em;
    cursor: pointer;
    padding: 8px;
    border-radius: 10px;
    background-color: var(--input-bg);
    border: 1px solid var(--border-color);
    transition: transform 0.2s ease, background-color 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    user-select: none; /* Prevent text selection */
    min-width: 44px; /* Ensure touch target */
    text-align: center;
}
.mood-emojis .emoji:hover {
    transform: scale(1.1);
    background-color: var(--background-gradient-end);
}
.mood-emojis .emoji.selected {
    background-color: var(--accent-color);
    border-color: var(--warning-hover);
    transform: scale(1.15);
    box-shadow: 0 0 12px rgba(var(--warning-color-rgb), 0.5);
    color: white; /* Ensure visibility for darker emojis */
}
.slider-energy {
    width: calc(100% - 60px); /* Adjust width */
    vertical-align: middle;
    accent-color: var(--secondary-color);
    height: 8px;
    cursor: pointer;
    margin-right: 10px;
}
#energy-value {
    vertical-align: middle;
    font-weight: bold;
    color: var(--primary-color);
}

/* Book Modal Specifics */
.book-modal-header {
    display: flex;
    gap: 1.5em;
    align-items: flex-start;
    margin-bottom: 2em;
    flex-wrap: wrap;
}
.modal-book-cover {
    width: 120px;
    height: 180px;
    object-fit: cover;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    flex-shrink: 0;
    border: 1px solid var(--border-color);
}
.book-info-text {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}
.book-modal-header h2 {
    margin-top: 0;
    font-size: 2em;
    border: none;
    padding: 0;
    margin-bottom: 0.5em;
    color: var(--primary-color);
}
.book-modal-header p {
    margin: 0.3em 0;
    font-size: 1.05em;
}
.book-rating .fa-star {
    color: #ccc;
    font-size: 1.6em;
    cursor: pointer;
    transition: color 0.2s ease, transform 0.1s ease;
}
.book-rating .fa-star:hover {
    transform: scale(1.1);
}
.book-rating .fa-star.active {
    color: var(--accent-color);
}
.book-modal-progress {
    margin-bottom: 2em;
    padding-top: 1em;
    border-top: 1px dashed var(--border-color);
}
.page-input-group {
    display: flex;
    align-items: center;
    gap: 0.8em;
    margin-bottom: 1em;
}
.page-input-group label strong {
    font-size: 1.05em;
    color: var(--primary-color);
}
.page-input-group input {
    max-width: 100px;
    text-align: center;
}
.progress-bar-container {
    width: 100%;
    height: 10px;
    background-color: var(--progress-bar-bg);
    border-radius: 5px;
    overflow: hidden;
    margin-top: 0.8em;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
}
.progress-bar {
    height: 100%;
    background-color: var(--progress-bar-fill);
    width: 0%;
    border-radius: 5px;
    transition: width 0.5s ease;
}
.notes-list {
    margin-top: 1.5em;
}
.notes-list .note-item {
    background-color: var(--background-gradient-start);
    padding: 15px;
    margin-bottom: 10px;
    border-radius: 10px;
    border: 1px solid var(--border-color);
    display: flex;
    flex-direction: column; /* Stack content and date */
    align-items: flex-start;
    gap: 0.5em;
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}
.notes-list .note-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}
.notes-list .note-item .note-content {
    flex-grow: 1;
    white-space: pre-wrap;
    word-break: break-word;
    font-size: 1em;
    color: var(--text-color); /* Uses the main text color */
}
.notes-list .note-item .note-date {
    font-size: 0.8em;
    color: var(--text-color); /* Uses the main text color */
    opacity: 0.7;
    text-align: right;
    width: 100%;
}
.notes-list .note-item .delete-note-btn {
    padding: 0.4em 0.8em;
    font-size: 0.8em;
    min-width: unset;
    margin-top: 0.5em;
    align-self: flex-end; /* Align delete button to bottom right */
}

/* Interval Timer Modal Specifics */
.interval-step {
    display: flex;
    align-items: center;
    gap: 1em;
    margin-bottom: 1em;
    padding: 0.8em;
    border: 1px solid var(--border-color);
    border-radius: 10px;
    background-color: var(--input-bg);
    flex-wrap: wrap;
}
.interval-step label {
    font-weight: bold;
    color: var(--primary-color);
    flex-shrink: 0;
    font-size: 0.95em;
}
.interval-step input[type="number"], .interval-step select {
    width: 80px;
    padding: 0.6em;
    border-radius: 8px;
    flex-shrink: 0;
}
.interval-step .delete-step-btn {
    margin-left: auto; /* Push delete button to the right */
    padding: 0.5em 0.8em;
    font-size: 0.9em;
}
#interval-timer-modal button {
    margin-top: 1.5em;
}
#add-interval-step {
    background-color: var(--secondary-color);
}
#start-interval-meditation {
    background-color: var(--success-color);
    margin-left: 1em;
}

/* --- Toast Notifications --- */
#toast-container {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.toast {
    background-color: var(--toast-bg);
    color: var(--toast-text);
    padding: 15px 20px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    opacity: 0;
    transform: translateX(120%); /* Start further right */
    transition: opacity 0.4s ease-out, transform 0.4s ease-out;
    min-width: 280px;
    max-width: 380px;
    display: flex;
    align-items: center;
    gap: 12px;
}

.toast.show {
    opacity: 1;
    transform: translateX(0);
}

.toast.hide {
    opacity: 0;
    transform: translateX(120%);
}

.toast i {
    font-size: 1.6em;
    color: var(--accent-color); /* Neutral color for icon */
}
.toast.success i { color: var(--success-color); }
.toast.error i { color: var(--delete-color); }
.toast.info i { color: var(--info-color); }
.toast.warning i { color: var(--warning-color); }


/* --- Keyframe Animations --- */
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes slideInTop { from { transform: translateY(-50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

/* --- Responsive Adjustments --- */
@media (max-width: 1200px) {
    .container {
        padding: 0 1em;
    }
    .app-section.active-section {
        gap: 2em;
    }
    .card {
        padding: 2.2em;
    }
}

@media (max-width: 768px) {
    header {
        padding: 1.8em 0 1em;
        border-bottom-left-radius: 10px;
        border-bottom-right-radius: 10px;
    }
    header h1 {
        font-size: 2.2em;
    }
    header p {
        font-size: 1em;
    }
    .main-nav {
        margin-bottom: 1.5em;
        border-radius: 0; /* Full width on mobile */
    }
    .main-nav .container {
        padding: 0 0.8em; /* Reduced padding for more space */
        gap: 0.6em;
    }
    .nav-button {
        font-size: 0.95em;
        padding: 0.8em 1em;
        gap: 8px;
    }
    .nav-button i {
        font-size: 1em;
    }
    .app-section.active-section {
        grid-template-columns: 1fr; /* Stack cards vertically */
        gap: 1.5em;
    }
    .card {
        padding: 1.8em;
        border-radius: 12px;
    }
    h2 {
        font-size: 1.8em;
        margin-bottom: 1em;
        padding-bottom: 0.6em;
    }
    h3 {
        font-size: 1.4em;
        margin-top: 1.5em;
        margin-bottom: 1em;
        padding-bottom: 0.5em;
    }
    .card-description {
        font-size: 0.95em;
        margin-bottom: 1.5em;
    }
    .timer-display {
        font-size: 3.2em;
        margin: 1em 0 1.5em;
        padding: 0.6em 0.8em;
    }
    .meditation-controls-group {
        gap: 1em;
        margin-bottom: 1.5em;
    }
    .preset-buttons, .timer-controls, .sound-controls {
        flex-direction: column;
        gap: 0.8em;
    }
    button {
        width: 100%;
        padding: 0.9em 1.5em;
        font-size: 1em;
    }
    .btn-icon {
        width: auto; /* Allow auto width for icons when stacked */
        border-radius: 30px; /* Make them pill-shaped when wider */
    }
    .custom-timer-input .input-field {
        max-width: none; /* Full width */
        width: 100%;
    }
    .custom-timer-input button {
        width: 100%;
    }

    .book-input-area, .search-input-area {
        flex-direction: column;
        align-items: stretch; /* Stretch items to full width */
        gap: 0.8em;
    }
    .book-input-area .input-field, .search-input-area .input-field {
        width: 100%; /* Full width inputs */
    }
    .book-input-area .btn-icon, .search-input-area .btn-icon {
        width: 100%;
    }
    .book-list li {
        flex-direction: column;
        align-items: flex-start;
        padding: 1.2em 1.5em;
    }
    .book-cover-thumbnail {
        margin-right: 0; /* No margin on smaller screens */
        margin-bottom: 1em; /* Add space below image */
        align-self: center; /* Center image */
    }
    .book-item-info {
        width: 100%; /* Full width */
        text-align: center;
    }
    .book-item-controls {
        width: 100%;
        justify-content: center;
    }
    .stats-grid div { border-right: none; border-bottom: 1px dashed var(--border-color); }
    .stats-grid div:last-child { border-bottom: none; }

    .modal {
        padding: 0; /* No padding, modal takes full height */
    }
    .modal-content {
        width: 100%;
        min-height: 100vh; /* Make modal almost full screen */
        border-radius: 0; /* No border radius */
        padding: 1.5em;
        margin: 0;
        box-shadow: none;
        max-height: unset; /* Remove max height constraint */
    }
    .modal-content.modal-small {
        min-height: unset; /* Restore min-height for small modal */
        border-radius: 12px;
        padding: 1.5em;
        max-width: 90%;
        margin: auto;
    }

    .close-button {
        font-size: 30px;
        right: 15px;
        top: 15px;
        background-color: var(--card-background);
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    .journal-meta, .book-modal-header {
        flex-direction: column;
        align-items: center;
        text-align: center;
    }
    .mood-emojis {
        justify-content: center;
    }
    .setting-item {
        flex-direction: column;
        align-items: flex-start;
    }
    .setting-item span {
        margin-left: 0;
        width: 100%;
        text-align: left;
    }
    .setting-item .input-field, .setting-item select, .setting-item button {
        margin-left: 0;
        width: 100%;
        text-align: left;
    }
    .setting-item .input-field.small-input {
        text-align: left;
    }
    .setting-buttons-group, .data-management-buttons {
        flex-direction: column;
        width: 100%;
    }
    #bell-volume, #ambient-volume {
        width: 100%;
        margin-left: 0;
    }
    #daily-reminder-time {
        width: 100%;
    }
    #toast-container {
        top: unset;
        bottom: 15px;
        right: 10px;
        left: 10px;
    }
    .toast {
        max-width: unset;
        transform: translateY(120%);
    }
    .toast.show {
        transform: translateY(0);
    }
    .toast.hide {
        transform: translateY(120%);
    }
    footer {
        padding: 1.5em;
        margin-top: 2em;
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
    }
}

/* Landscape orientation for mobile devices */
@media (max-width: 900px) and (orientation: landscape) {
    .main-nav .container {
        padding: 0 1em;
    }
    .modal-content {
        width: 90%;
        max-height: 90vh;
        border-radius: 12px;
        margin: auto;
        padding: 2em;
    }
    .modal-content.modal-small {
        min-height: unset;
    }
    .journal-meta, .book-modal-header {
        flex-direction: row; /* Allow side-by-side again if space permits */
        text-align: left;
    }
    .mood-emojis {
        justify-content: flex-start;
    }
    .timer-display {
        font-size: 4em;
    }
    .timer-controls {
        flex-direction: row;
    }
    .timer-controls button {
        width: auto;
    }
}

--- END FILE: style.css ---

----------------------------------------------------------------------------------------------------------------------------------------------------

do the following : 

1. fix all the bugs and glitches on this website.
2. focus on making it fully for mobile devices. make it responsive that way.
3. remove ambient sounds and bell sounds from the site.
4. rename the app "yogify".
5. upgrade the theme and overall design of the website.
6. guide me fully.
7. improve the visual appeal and attractiveness.
8. make the interface of this site mobile friendly so that mobile users can access all its features well.