
--- START FILE: index.html ---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yogify - Inner Journey Companion</title>
    <link rel="stylesheet" href="style.css">
    <!-- Font Awesome 6 for modern icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Chart.js for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<body>
    <header>
        <div class="container">
            <h1>Yogify</h1>
            <p>Your Path to Inner Harmony & Wisdom</p>
        </div>
    </header>

    <nav class="main-nav" aria-label="Main Navigation">
        <div class="container">
            <button class="nav-button active" data-section="dashboard-section" aria-label="Home"><i class="fas fa-home"></i> Home</button>
            <button class="nav-button" data-section="meditation-section" aria-label="Meditation"><i class="fas fa-om"></i> Meditation</button>
            <button class="nav-button" data-section="books-section" aria-label="Books"><i class="fas fa-book-reader"></i> Books</button>
            <button class="nav-button" data-section="statistics-section" aria-label="Statistics"><i class="fas fa-chart-line"></i> Stats</button>
            <button class="nav-button" data-section="goals-section" aria-label="Goals"><i class="fas fa-bullseye"></i> Goals</button>
            <button class="nav-button" data-section="achievements-section" aria-label="Achievements"><i class="fas fa-trophy"></i> Achievements</button>
            <button class="nav-button" data-section="settings-section" aria-label="Settings"><i class="fas fa-cog"></i> Settings</button>
        </div>
    </nav>

    <main class="container">
        <!-- Dashboard Section -->
        <section id="dashboard-section" class="app-section active-section" aria-labelledby="dashboard-heading">
            <div class="card dashboard-welcome">
                <h2 id="dashboard-heading">Welcome, Seeker!</h2>
                <p class="card-description">A quick overview of your journey.</p>
                <div class="stats-grid">
                    <div><strong>Total Meditated:</strong> <span id="dash-total-med-time">0h 0m</span></div>
                    <div><strong>Sessions:</strong> <span id="dash-total-med-sessions">0</span></div>
                    <div><strong>Current Streak:</strong> <span id="dash-current-streak">0 days</span></div>
                    <div><strong>Books Read:</strong> <span id="dash-books-finished">0</span></div>
                </div>
            </div>
            <div class="card dashboard-recent-meds">
                <h3>Recent Meditations</h3>
                <ul id="dash-meditation-sessions-list" class="mini-list">
                    <!-- Recent sessions will be dynamically added here -->
                </ul>
                <button class="btn-sm" onclick="showSection('meditation-section')" aria-label="View All Meditations">View All Meditations</button>
            </div>
            <div class="card dashboard-recent-reads">
                <h3>Currently Reading</h3>
                <ul id="dash-current-reading-list" class="mini-list">
                    <!-- Currently reading books will be dynamically added here -->
                </ul>
                <button class="btn-sm" onclick="showSection('books-section')" aria-label="View All Books">View All Books</button>
            </div>
        </section>

        <!-- Meditation Section -->
        <section id="meditation-section" class="app-section" aria-labelledby="meditation-heading">
            <div class="card meditation-timer-card">
                <h2 id="meditation-heading"><i class="fas fa-om"></i> Meditation Sanctuary</h2>
                <p class="card-description">Choose a preset, set a custom duration, or start freestyle.</p>
                <div class="timer-display" id="meditation-timer-display">00:00:00</div>
                <div class="meditation-controls-group">
                    <div class="preset-buttons">
                        <button class="preset-meditation-time btn-sm" data-minutes="5">5 min</button>
                        <button class="preset-meditation-time btn-sm" data-minutes="10">10 min</button>
                        <button class="preset-meditation-time btn-sm" data-minutes="20">20 min</button>
                        <button class="preset-meditation-time btn-sm" data-minutes="30">30 min</button>
                        <button id="open-interval-timer-btn" class="btn-sm" aria-label="Open Interval Timer"><i class="fas fa-clock"></i> Interval</button>
                    </div>
                    <div class="custom-timer-input">
                        <input type="number" id="custom-meditation-minutes" min="1" placeholder="Custom min" class="input-field small-input" aria-label="Custom meditation minutes">
                        <button id="set-custom-meditation" class="btn-sm" aria-label="Set Custom Meditation"><i class="fas fa-check"></i> Set</button>
                    </div>
                </div>
                
                <div class="timer-controls">
                    <button id="start-meditation" aria-label="Start Meditation"><i class="fas fa-play"></i> Start</button>
                    <button id="pause-meditation" disabled aria-label="Pause Meditation"><i class="fas fa-pause"></i> Pause</button>
                    <button id="stop-meditation" disabled aria-label="Stop Meditation"><i class="fas fa-stop"></i> Stop</button>
                    <button id="reset-meditation" aria-label="Reset Meditation"><i class="fas fa-redo-alt"></i> Reset</button>
                </div>
            </div>

            <!-- Custom Countdown Meditation Card -->
            <div class="card custom-countdown-card">
                <h2><i class="fas fa-hourglass-start"></i> Custom Countdown Meditation</h2>
                <p class="card-description">Set a specific countdown duration for your practice.</p>
                <div class="timer-input-group">
                    <input type="number" id="countdown-hours" min="0" max="23" placeholder="H" class="input-field tiny-input" aria-label="Countdown hours" value="00">
                    <span class="colon">:</span>
                    <input type="number" id="countdown-minutes" min="0" max="59" placeholder="M" class="input-field tiny-input" aria-label="Countdown minutes" value="00">
                    <span class="colon">:</span>
                    <input type="number" id="countdown-seconds" min="0" max="59" placeholder="S" class="input-field tiny-input" aria-label="Countdown seconds" value="00">
                </div>
                <div class="countdown-display" id="general-countdown-display">00:00:00</div>
                <div class="countdown-controls">
                    <button id="start-countdown" aria-label="Start Countdown Meditation"><i class="fas fa-play"></i> Start</button>
                    <button id="pause-countdown" disabled aria-label="Pause Countdown Meditation"><i class="fas fa-pause"></i> Pause</button>
                    <button id="stop-countdown" disabled aria-label="Stop Countdown Meditation"><i class="fas fa-stop"></i> Stop</button>
                    <button id="reset-countdown" aria-label="Reset Countdown Meditation"><i class="fas fa-redo-alt"></i> Reset</button>
                </div>
                <div class="countdown-options">
                    <input type="text" id="countdown-label" placeholder="e.g., Deep Breathing, Body Scan" class="input-field" aria-label="Optional countdown label">
                    <div class="notification-toggle">
                        <span>Notify on Finish:</span>
                        <label class="switch" aria-label="Toggle notification on finish">
                            <input type="checkbox" id="countdown-notification-toggle">
                            <span class="slider round"></span>
                        </label>
                    </div>
                </div>
            </div>

            <div class="card meditation-history-card">
                <h3><i class="fas fa-history"></i> Your Meditation Journey</h3>
                <ul id="meditation-sessions-list">
                    <!-- Meditation sessions will be dynamically added here -->
                </ul>
            </div>
        </section>

        <!-- Spiritual Books Section -->
        <section id="books-section" class="app-section" aria-labelledby="books-heading">
            <div class="card card-full-width">
                <h2 id="books-heading"><i class="fas fa-book-reader"></i> Wisdom Scrolls</h2>
                <div class="book-input-area">
                    <input type="file" id="new-book-cover" accept="image/*" style="display: none;" aria-label="Upload book cover image">
                    <button id="upload-book-cover-btn" class="btn-icon" title="Upload Cover Image" aria-label="Upload Cover Image"><i class="fas fa-image"></i> Upload Cover Image</button>
                    <input type="text" id="new-book-title" placeholder="Book Title" class="input-field" aria-label="Book Title" required>
                    <input type="text" id="new-book-author" placeholder="Author (optional)" class="input-field" aria-label="Author">
                    <input type="number" id="new-book-pages" placeholder="Total Pages (optional)" class="input-field small-input" min="0" aria-label="Total Pages">
                    <input type="text" id="new-book-genre" placeholder="Genre (optional, e.g., Spiritual, Philosophy)" class="input-field" aria-label="Genre">
                    <button id="add-book" aria-label="Add Book"><i class="fas fa-plus"></i> Add Book</button>
                </div>
                <div class="search-input-area">
                    <input type="text" id="book-search-input" placeholder="Search books by title, author, or genre..." class="input-field" aria-label="Search books">
                    <button id="clear-book-search" class="btn-icon" aria-label="Clear Search"><i class="fas fa-times"></i></button>
                </div>
                <h3>Your Spiritual Library</h3>
                <ul id="books-list" class="book-list" aria-live="polite">
                    <!-- Books will be dynamically added here -->
                </ul>
            </div>
        </section>

        <!-- Statistics Section -->
        <section id="statistics-section" class="app-section" aria-labelledby="statistics-heading">
            <div class="card card-full-width">
                <h2 id="statistics-heading"><i class="fas fa-chart-line"></i> Meditation Statistics</h2>
                <h3>Daily Meditation Time Trend</h3>
                <div class="chart-container"><canvas id="meditationTimeChart" role="img" aria-label="Daily Meditation Time Trend Chart"></canvas></div>
                <h3>Meditation Session Count</h3>
                <div class="chart-container"><canvas id="meditationSessionsChart" role="img" aria-label="Meditation Session Count Chart"></canvas></div>
                <h3>Mood Distribution</h3>
                <div class="chart-container"><canvas id="moodDistributionChart" role="img" aria-label="Mood Distribution Chart"></canvas></div>
                <h3>Top Meditation Tags</h3>
                <div class="chart-container"><canvas id="topTagsChart" role="img" aria-label="Top Meditation Tags Chart"></canvas></div>
            </div>
            <div class="card card-full-width">
                <h2><i class="fas fa-chart-pie"></i> Book Reading Statistics</h2>
                <h3>Reading Time by Book</h3>
                <div class="chart-container"><canvas id="bookReadingTimeChart" role="img" aria-label="Book Reading Time by Book Chart"></canvas></div>
            </div>
            <div class="card card-full-width">
                <h2><i class="fas fa-calendar-alt"></i> Meditation Calendar</h2>
                <div id="meditation-calendar" class="meditation-calendar" aria-label="Meditation Calendar"></div>
            </div>
        </section>

        <!-- Goals Section -->
        <section id="goals-section" class="app-section" aria-labelledby="goals-heading">
            <div class="card card-full-width">
                <h2 id="goals-heading"><i class="fas fa-bullseye"></i> Your Goals</h2>
                <div class="goal-input-area">
                    <select id="goal-type" class="input-field small-input" aria-label="Goal Type">
                        <option value="meditation_duration">Meditation Duration</option>
                        <option value="meditation_days">Meditation Days</option>
                        <option value="books_finished">Books Finished</option>
                    </select>
                    <input type="number" id="goal-value" placeholder="Target Value" class="input-field small-input" min="1" aria-label="Target Value">
                    <select id="goal-period" class="input-field small-input" aria-label="Goal Period">
                        <option value="week">Per Week</option>
                        <option value="month">Per Month</option>
                        <option value="overall">Overall</option>
                    </select>
                    <button id="add-goal" aria-label="Add Goal"><i class="fas fa-plus"></i> Add Goal</button>
                </div>
                <h3>Active Goals</h3>
                <ul id="active-goals-list" aria-live="polite">
                    <!-- Active goals will be dynamically added here -->
                </ul>
                <h3>Completed Goals</h3>
                <ul id="completed-goals-list" aria-live="polite">
                    <!-- Completed goals will be dynamically added here -->
                </ul>
            </div>
        </section>

        <!-- Achievements Section -->
        <section id="achievements-section" class="app-section" aria-labelledby="achievements-heading">
            <div class="card card-full-width">
                <h2 id="achievements-heading"><i class="fas fa-trophy"></i> Your Achievements</h2>
                <div id="achievements-grid" class="achievements-grid" aria-live="polite">
                    <!-- Achievements will be dynamically added here -->
                </div>
            </div>
        </section>

        <!-- Settings Section -->
        <section id="settings-section" class="app-section" aria-labelledby="settings-heading">
            <div class="card card-full-width">
                <h2 id="settings-heading"><i class="fas fa-cog"></i> Settings</h2>
                <div class="setting-item">
                    <span>Theme:</span>
                    <select id="theme-selector" class="input-field small-input" aria-label="Select Theme">
                        <option value="yogify-serene">Yogify Serene</option>
                        <option value="yogify-nightfall">Yogify Nightfall</option>
                        <option value="yogify-stellar">Yogify Stellar</option>
                        <option value="yogify-verdant">Yogify Verdant</option>
                    </select>
                </div>
                <div class="setting-item">
                    <span>Custom Background Image:</span>
                    <div class="setting-buttons-group">
                        <input type="file" id="custom-background-file" accept="image/*" style="display: none;" aria-label="Upload custom background image">
                        <button id="upload-custom-background-btn" class="btn-sm" aria-label="Upload Image"><i class="fas fa-upload"></i> Upload Image</button>
                        <button id="clear-custom-background-btn" class="delete-button btn-sm" aria-label="Clear Custom Background"><i class="fas fa-times"></i> Clear</button>
                    </div>
                </div>
                <hr>
                <div class="setting-item">
                    <span>Daily Meditation Reminder:</span>
                    <div class="setting-buttons-group">
                        <input type="time" id="daily-reminder-time" class="input-field small-input" aria-label="Set daily reminder time">
                        <button id="set-daily-reminder-btn" class="btn-sm" aria-label="Set Daily Reminder"><i class="fas fa-bell"></i> Set</button>
                        <button id="clear-daily-reminder-btn" class="delete-button btn-sm" aria-label="Clear Daily Reminder"><i class="fas fa-times"></i> Clear</button>
                    </div>
                </div>
                <hr>
                <div class="setting-item data-management-buttons">
                    <button id="export-data-btn" class="export-button" aria-label="Export Data"><i class="fas fa-download"></i> Export Data</button>
                    <input type="file" id="import-data-file" accept=".json" style="display: none;" aria-label="Import data file">
                    <button id="import-data-btn" class="import-button" aria-label="Import Data"><i class="fas fa-upload"></i> Import Data</button>
                    <button id="clear-all-data-btn" class="delete-button" aria-label="Clear All Data"><i class="fas fa-trash-alt"></i> Clear All Data</button>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; <span id="current-year"></span> Yogify. All rights reserved.</p>
        </div>
    </footer>

    <!-- Modals -->

    <!-- Meditation Journal Modal -->
    <div id="meditation-journal-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="journal-modal-heading">
        <div class="modal-content">
            <span class="close-button" data-modal="meditation-journal-modal" aria-label="Close Journal Modal">&times;</span>
            <h2 id="journal-modal-heading">Meditation Reflection</h2>
            <div class="journal-meta">
                <div class="mood-tracker">
                    <h4>Mood:</h4>
                    <div class="mood-emojis" role="radiogroup" aria-label="Select Mood">
                        <span class="emoji" data-mood="calm" title="Calm" role="radio" aria-checked="false" tabindex="0">😌</span>
                        <span class="emoji" data-mood="focused" title="Focused" role="radio" aria-checked="false" tabindex="0">🧐</span>
                        <span class="emoji" data-mood="peaceful" title="Peaceful" role="radio" aria-checked="false" tabindex="0">🕊️</span>
                        <span class="emoji" data-mood="energetic" title="Energetic" role="radio" aria-checked="false" tabindex="0">⚡</span>
                        <span class="emoji" data-mood="tired" title="Tired" role="radio" aria-checked="false" tabindex="0">😴</span>
                        <span class="emoji" data-mood="anxious" title="Anxious" role="radio" aria-checked="false" tabindex="0">😟</span>
                        <span class="emoji" data-mood="happy" title="Happy" role="radio" aria-checked="false" tabindex="0">😊</span>
                    </div>
                </div>
                <div class="energy-tracker">
                    <h4>Energy Level: <span id="energy-value">5</span>/10</h4>
                    <input type="range" id="energy-level" min="0" max="10" value="5" class="slider-energy" aria-label="Energy Level">
                </div>
            </div>
            <h4>Tags:</h4>
            <input type="text" id="journal-tags-input" placeholder="Add tags (e.g., stress, focus, morning)" class="input-field" aria-label="Meditation Tags">
            <h4>Thoughts & Insights:</h4>
            <textarea id="journal-text" placeholder="Write down your thoughts, insights, or feelings..." aria-label="Thoughts and Insights"></textarea>
            <h4>Gratitude:</h4>
            <textarea id="gratitude-text" placeholder="What are you grateful for today?" aria-label="Gratitude Entry"></textarea>
            <button id="save-journal-entry" aria-label="Save Reflection">Save Reflection</button>
        </div>
    </div>

    <!-- Book Details/Notes Modal -->
    <div id="book-details-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="book-details-modal-heading">
        <div class="modal-content">
            <span class="close-button" data-modal="book-details-modal" aria-label="Close Book Details Modal">&times;</span>
            <div class="book-modal-header">
                <img id="modal-book-cover-img" src="./img/default_book.png" alt="Book Cover" class="modal-book-cover">
                <div class="book-info-text">
                    <h2 id="modal-book-title"></h2>
                    <p><strong>Author:</strong> <span id="modal-book-author"></span></p>
                    <p><strong>Genre:</strong> <span id="modal-book-genre"></span></p>
                    <p><strong>Status:</strong> <span id="modal-book-status-container"></span></p>
                    <div class="book-rating" id="modal-book-rating" role="radiogroup" aria-label="Book Rating">
                        <!-- Stars will be dynamically added here -->
                    </div>
                </div>
            </div>
            
            <div class="book-modal-progress">
                <p><strong>Total Pages:</strong> <span id="modal-book-total-pages"></span></p>
                <div class="page-input-group">
                    <label for="modal-book-current-page"><strong>Current Page:</strong></label>
                    <input type="number" id="modal-book-current-page" class="input-field small-input" min="0" aria-label="Current Page">
                </div>
                <p><strong>Progress:</strong> <span id="modal-book-progress">0%</span></p>
                <div class="progress-bar-container" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                    <div class="progress-bar" id="modal-progress-bar"></div>
                </div>
                <p><strong>Total Reading Time:</strong> <span id="modal-book-total-reading-time">0h 0m</span></p>
            </div>
            
            <h3>Notes</h3>
            <textarea id="modal-book-notes-input" placeholder="Add a new note..." aria-label="Add book note"></textarea>
            <button id="add-book-note-btn" aria-label="Add Note">Add Note</button>
            <ul id="modal-book-notes-list" class="notes-list">
                <!-- Book notes will be dynamically added here -->
            </ul>
        </div>
    </div>

    <!-- Interval Timer Setup Modal -->
    <div id="interval-timer-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="interval-modal-heading">
        <div class="modal-content">
            <span class="close-button" data-modal="interval-timer-modal" aria-label="Close Interval Timer Modal">&times;</span>
            <h2 id="interval-modal-heading"><i class="fas fa-clock"></i> Set Up Interval Meditation</h2>
            <div id="interval-steps-container">
                <!-- Interval steps will be dynamically added here -->
            </div>
            <button id="add-interval-step" class="btn-sm" aria-label="Add Interval Step"><i class="fas fa-plus"></i> Add Step</button>
            <button id="start-interval-meditation" class="btn-success" aria-label="Start Interval Meditation">Start Interval Meditation</button>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmation-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="confirmation-modal-heading">
        <div class="modal-content modal-small">
            <span class="close-button" data-modal="confirmation-modal" aria-label="Close Confirmation Modal">&times;</span>
            <h2 id="confirmation-modal-heading">Confirm Action</h2>
            <p id="confirmation-message"></p>
            <div class="modal-actions">
                <button id="confirm-action-btn" class="delete-button" aria-label="Confirm">Confirm</button>
                <button id="cancel-action-btn" class="secondary-button" aria-label="Cancel">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Toast Notifications Container -->
    <div id="toast-container" aria-live="polite" aria-atomic="true"></div>

    <script src="script.js"></script>
</body>
</html>

--- END FILE: index.html ---

--- START FILE: README.md ---

Website link : https://mysticvision-meditation-companion-app.netlify.app/

# Yogify - Inner Journey Companion

Yogify is a personal companion app designed to help you cultivate inner harmony and wisdom through meditation and spiritual reading. Track your meditation sessions, log your reading progress, set personal goals, and unlock achievements on your path to self-discovery.

**Features:**
*   **Meditation Timer:** Set custom or preset meditation durations, including interval meditations.
*   **Journaling:** Reflect on your sessions, track mood and energy levels, and add tags for insights.
*   **Book Tracker:** Manage your spiritual reading list, log pages, add notes, and track reading time.
*   **Statistics:** Visualize your meditation trends, mood distribution, and reading habits with interactive charts.
*   **Goals:** Set personal goals for meditation duration, days meditated, and books finished.
*   **Achievements:** Unlock milestones as you progress on your journey.
*   **Settings:** Customize your experience with multiple refined themes and daily meditation reminders.
*   **Data Management:** Export and import your data for backup and transfer.

This app is designed with a clean, responsive, and mobile-friendly interface to support your practice wherever you are.

--- END FILE: README.md ---

--- START FILE: script.js ---

document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements Cache ---
    const elements = {
        // Main Navigation
        navButtons: document.querySelectorAll('.nav-button'),
        appSections: document.querySelectorAll('.app-section'),

        // Dashboard
        dashTotalMedTime: document.getElementById('dash-total-med-time'),
        dashTotalMedSessions: document.getElementById('dash-total-med-sessions'),
        dashCurrentStreak: document.getElementById('dash-current-streak'),
        dashBooksFinished: document.getElementById('dash-books-finished'),
        dashMeditationSessionsList: document.getElementById('dash-meditation-sessions-list'),
        dashCurrentReadingList: document.getElementById('dash-current-reading-list'),

        // Meditation Section
        meditationTimerDisplay: document.getElementById('meditation-timer-display'),
        startMeditationBtn: document.getElementById('start-meditation'),
        pauseMeditationBtn: document.getElementById('pause-meditation'),
        stopMeditationBtn: document.getElementById('stop-meditation'),
        resetMeditationBtn: document.getElementById('reset-meditation'),
        presetMeditationButtons: document.querySelectorAll('.preset-meditation-time'),
        customMeditationMinutesInput: document.getElementById('custom-meditation-minutes'),
        setCustomMeditationBtn: document.getElementById('set-custom-meditation'),
        meditationSessionsList: document.getElementById('meditation-sessions-list'),
        openIntervalTimerBtn: document.getElementById('open-interval-timer-btn'),

        // Custom Countdown Meditation (formerly General Countdown Timer)
        countdownHoursInput: document.getElementById('countdown-hours'),
        countdownMinutesInput: document.getElementById('countdown-minutes'),
        countdownSecondsInput: document.getElementById('countdown-seconds'),
        generalCountdownDisplay: document.getElementById('general-countdown-display'),
        startCountdownBtn: document.getElementById('start-countdown'),
        pauseCountdownBtn: document.getElementById('pause-countdown'),
        stopCountdownBtn: document.getElementById('stop-countdown'),
        resetCountdownBtn: document.getElementById('reset-countdown'),
        countdownLabelInput: document.getElementById('countdown-label'),
        countdownNotificationToggle: document.getElementById('countdown-notification-toggle'),

        // Book Section
        newBookCoverInput: document.getElementById('new-book-cover'),
        uploadBookCoverBtn: document.getElementById('upload-book-cover-btn'),
        newBookTitleInput: document.getElementById('new-book-title'),
        newBookAuthorInput: document.getElementById('new-book-author'),
        newBookPagesInput: document.getElementById('new-book-pages'),
        newBookGenreInput: document.getElementById('new-book-genre'),
        addBookBtn: document.getElementById('add-book'),
        booksList: document.getElementById('books-list'),
        bookSearchInput: document.getElementById('book-search-input'),
        clearBookSearchBtn: document.getElementById('clear-book-search'),

        // Statistics Section
        meditationTimeChartCanvas: document.getElementById('meditationTimeChart'),
        meditationSessionsChartCanvas: document.getElementById('meditationSessionsChart'),
        moodDistributionChartCanvas: document.getElementById('moodDistributionChart'),
        topTagsChartCanvas: document.getElementById('topTagsChart'),
        bookReadingTimeChartCanvas: document.getElementById('bookReadingTimeChart'),
        meditationCalendar: document.getElementById('meditation-calendar'),

        // Goals Section
        goalTypeSelect: document.getElementById('goal-type'),
        goalValueInput: document.getElementById('goal-value'),
        goalPeriodSelect: document.getElementById('goal-period'),
        addGoalBtn: document.getElementById('add-goal'),
        activeGoalsList: document.getElementById('active-goals-list'),
        completedGoalsList: document.getElementById('completed-goals-list'),

        // Achievements Section
        achievementsGrid: document.getElementById('achievements-grid'),

        // Settings Section
        themeSelector: document.getElementById('theme-selector'),
        customBackgroundFileInput: document.getElementById('custom-background-file'),
        uploadCustomBackgroundBtn: document.getElementById('upload-custom-background-btn'),
        clearCustomBackgroundBtn: document.getElementById('clear-custom-background-btn'),
        dailyReminderTimeInput: document.getElementById('daily-reminder-time'),
        setDailyReminderBtn: document.getElementById('set-daily-reminder-btn'),
        clearDailyReminderBtn: document.getElementById('clear-daily-reminder-btn'),
        exportDataBtn: document.getElementById('export-data-btn'),
        importDataFile: document.getElementById('import-data-file'),
        importDataBtn: document.getElementById('import-data-btn'),
        clearAllDataBtn: document.getElementById('clear-all-data-btn'),

        // Modals
        meditationJournalModal: document.getElementById('meditation-journal-modal'),
        journalMoodEmojis: document.querySelectorAll('.mood-emojis .emoji'),
        journalEnergyLevel: document.getElementById('energy-level'),
        journalEnergyValue: document.getElementById('energy-value'),
        journalTagsInput: document.getElementById('journal-tags-input'),
        journalTextInput: document.getElementById('journal-text'),
        gratitudeTextInput: document.getElementById('gratitude-text'),
        saveJournalEntryBtn: document.getElementById('save-journal-entry'),

        bookDetailsModal: document.getElementById('book-details-modal'),
        modalBookCoverImg: document.getElementById('modal-book-cover-img'),
        modalBookTitle: document.getElementById('modal-book-title'),
        modalBookAuthor: document.getElementById('modal-book-author'),
        modalBookGenre: document.getElementById('modal-book-genre'),
        modalBookStatusContainer: document.getElementById('modal-book-status-container'),
        modalBookRating: document.getElementById('modal-book-rating'),
        modalBookTotalPages: document.getElementById('modal-book-total-pages'),
        modalBookCurrentPage: document.getElementById('modal-book-current-page'),
        modalBookProgress: document.getElementById('modal-book-progress'),
        modalProgressBar: document.getElementById('modal-progress-bar'),
        modalBookTotalReadingTime: document.getElementById('modal-book-total-reading-time'),
        modalBookNotesInput: document.getElementById('modal-book-notes-input'),
        addBookNoteBtn: document.getElementById('add-book-note-btn'),
        modalBookNotesList: document.getElementById('modal-book-notes-list'),

        intervalTimerModal: document.getElementById('interval-timer-modal'),
        intervalStepsContainer: document.getElementById('interval-steps-container'),
        addIntervalStepBtn: document.getElementById('add-interval-step'),
        startIntervalMeditationBtn: document.getElementById('start-interval-meditation'),

        confirmationModal: document.getElementById('confirmation-modal'),
        confirmationMessage: document.getElementById('confirmation-message'),
        confirmActionBtn: document.getElementById('confirm-action-btn'),
        cancelActionBtn: document.getElementById('cancel-action-btn'),

        closeButtons: document.querySelectorAll('.close-button'),
        toastContainer: document.getElementById('toast-container')
    };

    // --- Global State Variables ---
    let meditationTimerInterval;
    let meditationStartTime = 0;
    let meditationElapsedTime = 0;
    let meditationPaused = false;
    let meditationDurationTarget = 0; // In milliseconds, for presets & intervals
    let meditationType = 'standard'; // 'standard' or 'interval' or 'freestyle' (for 0 duration target)
    let currentIntervalIndex = 0;
    let intervalTimerSteps = []; // [{duration, label}] (sounds removed)

    // Custom Countdown Meditation state
    let customCountdownInterval = null;
    let customCountdownStartTime = 0; // The actual time countdown began for this session
    let customCountdownRemainingMs = 0; // Time left on the countdown
    let customCountdownInitialSetMs = 0; // The total duration user initially set
    let customCountdownPaused = false;
    let customCountdownEndTime = 0; // When the timer should end if running

    let currentReadingBookId = null;
    let bookReadingTimerInterval;
    let bookReadingStartTime = 0;

    // This flag indicates which meditation-recording timer is currently active
    // null: no timer active
    // 'meditation': Meditation Sanctuary timer is active
    // 'custom-countdown': Custom Countdown Meditation is active
    let activeRecordingSessionType = null;


    // --- Data Structures (Persisted in localStorage) ---
    // meditationSessions: [{ id, startTime, endTime, durationMs, date, journalEntry?, mood?, energy?, tags?, type? }]
    let meditationSessions = loadData('meditationSessions', []);

    // books: [{ id, title, author, totalPages, currentPage, readingSessions: [{ startTime, endTime, durationMs }], notes: [{ id, text, date }], coverImage?, status?, rating?, genre? }]
    let books = loadData('books', []);

    // goals: [{ id, type, targetValue, period, currentProgress, completed, startDate, lastUpdate }]
    let goals = loadData('goals', []);

    // settings: { theme, dailyReminderTime, customBackground }
    let settings = loadData('settings', {
        theme: 'yogify-serene', // New default theme
        dailyReminderTime: '',
        customBackground: null
    });

    // customCountdownState: { remainingMs, initialSetMs, paused, endTime, label, notify }
    let customCountdownState = loadData('customCountdownState', {
        remainingMs: 0,
        initialSetMs: 0,
        paused: false,
        endTime: 0,
        label: '',
        notify: false
    });


    // achievementsList: [{ id, name, description, check(), unlocked, icon }] (check function is part of the JS definition, only unlocked status is persisted)
    // Define achievement check functions here to ensure they are always present.
    const baseAchievements = [
        { id: 'first_session', name: 'First Step', description: 'Complete your first meditation session.', unlocked: false, icon: 'fas fa-shoe-prints', check: () => meditationSessions.length >= 1 },
        { id: 'seven_day_streak', name: '7-Day Streak', description: 'Meditate for 7 consecutive days.', unlocked: false, icon: 'fas fa-fire', check: () => calculateStreaks().longestStreak >= 7 },
        { id: '30_min_meditation', name: 'Deep Dive', description: 'Complete a meditation session of 30 minutes or more.', unlocked: false, icon: 'fas fa-mountain', check: () => meditationSessions.some(s => s.durationMs >= 30 * 60 * 1000) },
        { id: '10_hours_meditated', name: 'Seasoned Seeker', description: 'Accumulate 10 hours of meditation.', unlocked: false, icon: 'fas fa-star', check: () => meditationSessions.reduce((sum, s) => sum + s.durationMs, 0) >= 10 * 60 * 60 * 1000 },
        { id: 'first_book_finished', name: 'Wisdom Gained', description: 'Mark your first spiritual book as "Finished".', unlocked: false, icon: 'fas fa-feather-alt', check: () => books.some(b => b.status === 'Finished') },
        { id: 'five_books_finished', name: 'Enlightened Library', description: 'Finish 5 spiritual books.', unlocked: false, icon: 'fas fa-book-sparkles', check: () => books.filter(b => b.status === 'Finished').length >= 5 },
        { id: 'first_journal_entry', name: 'Inner Voice', description: 'Write your first meditation journal entry.', unlocked: false, icon: 'fas fa-pen-nib', check: () => meditationSessions.some(s => s.journalEntry && s.journalEntry.length > 0) },
        { id: 'first_book_note', name: 'Reflective Reader', description: 'Add your first note to a spiritual book.', unlocked: false, icon: 'fas fa-highlighter', check: () => books.some(b => b.notes && b.notes.length > 0) },
    ];
    let achievementsList = loadAchievementsWithChecks(baseAchievements, loadData('achievementsListStatus', []));

    // --- Charts ---
    let meditationTimeChart, meditationSessionsChart, moodDistributionChart, topTagsChart, bookReadingTimeChart;


    // --- Utility Functions ---

    /**
     * Loads data from localStorage or returns a default value.
     * @param {string} key
     * @param {any} defaultValue
     * @returns {any}
     */
    function loadData(key, defaultValue) {
        try {
            const data = localStorage.getItem(key);
            return data ? JSON.parse(data) : defaultValue;
        } catch (e) {
            console.error(`Error loading data for key ${key}:`, e);
            showToast('Error loading data: Local storage might be corrupted.', 'error');
            return defaultValue;
        }
    }

    /**
     * Saves data to localStorage.
     * @param {string} key
     * @param {any} data
     */
    function saveData(key, data) {
        try {
            localStorage.setItem(key, JSON.stringify(data));
        } catch (e) {
            console.error(`Error saving data for key ${key}:`, e);
            showToast('Not enough storage space. Please clear some data.', 'error');
        }
    }

    /**
     * Loads achievement status and merges with base achievement definitions.
     * @param {Array} baseAch The full achievement definitions with check functions.
     * @param {Array} storedStatus The stored unlocked status (id, unlocked).
     * @returns {Array} The merged achievements list.
     */
    function loadAchievementsWithChecks(baseAch, storedStatus) {
        const mergedList = [...baseAch]; // Deep copy to avoid modifying base
        storedStatus.forEach(stored => {
            const ach = mergedList.find(a => a.id === stored.id);
            if (ach) {
                ach.unlocked = stored.unlocked;
            }
        });
        return mergedList;
    }

    /**
     * Formats milliseconds into HH:MM:SS string.
     * @param {number} ms
     * @returns {string}
     */
    function formatTime(ms) {
        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        return [hours, minutes, seconds]
            .map(unit => String(unit).padStart(2, '0'))
            .join(':');
    }

    /**
     * Formats milliseconds into human-readable hours and minutes.
     * @param {number} ms
     * @returns {string}
     */
    function formatDuration(ms) {
        if (ms === 0) return '0m';
        const totalMinutes = Math.floor(ms / (1000 * 60));
        const hours = Math.floor(totalMinutes / 60);
        const minutes = totalMinutes % 60;
        if (hours > 0) {
            return `${hours}h ${minutes}m`;
        }
        return `${minutes}m`;
    }

    /**
     * Generates a unique ID.
     * @returns {string}
     */
    function generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
    }

    /**
     * Opens a modal.
     * @param {HTMLElement} modalElement
     */
    function openModal(modalElement) {
        modalElement.style.display = 'flex'; // Use flex for centering
        document.body.classList.add('modal-open');
    }

    /**
     * Closes a modal.
     * @param {HTMLElement} modalElement
     */
    function closeModal(modalElement) {
        modalElement.style.display = 'none';
        document.body.classList.remove('modal-open');
    }

    /**
     * Shows a toast notification.
     * @param {string} message
     * @param {string} type 'success', 'error', 'info', 'warning'
     */
    function showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        let icon = '';
        if (type === 'success') icon = '<i class="fas fa-check-circle"></i>';
        else if (type === 'error') icon = '<i class="fas fa-exclamation-triangle"></i>';
        else if (type === 'warning') icon = '<i class="fas fa-exclamation-circle"></i>';
        else icon = '<i class="fas fa-info-circle"></i>';

        toast.innerHTML = `${icon} <span>${message}</span>`;
        elements.toastContainer.appendChild(toast);

        // Allow reflow for transition
        void toast.offsetWidth; // Trigger reflow
        toast.classList.add('show');

        setTimeout(() => {
            toast.classList.remove('show');
            toast.classList.add('hide');
            toast.addEventListener('transitionend', () => toast.remove(), { once: true });
        }, 3000);
    }

    // --- Meditation Logic (Main Sanctuary Timer) ---

    function startMeditationTimer(durationMinutes = 0, type = 'standard') {
        if (activeRecordingSessionType) {
            showToast('Another meditation timer is already active!', 'warning');
            return;
        }

        meditationDurationTarget = durationMinutes * 60 * 1000;
        meditationType = type;

        if (!meditationPaused) {
            meditationStartTime = Date.now();
            meditationElapsedTime = 0;
            currentIntervalIndex = 0; // Reset for new session
        } else {
            meditationStartTime = Date.now() - meditationElapsedTime;
            meditationPaused = false;
        }
        
        activeRecordingSessionType = 'meditation';
        updateAllTimerButtonStates(); // Update all timer buttons

        showToast('Meditation started.', 'info');

        meditationTimerInterval = setInterval(() => {
            meditationElapsedTime = Date.now() - meditationStartTime;
            elements.meditationTimerDisplay.textContent = formatTime(meditationElapsedTime);

            if (meditationType === 'standard' && meditationDurationTarget > 0 && meditationElapsedTime >= meditationDurationTarget) {
                stopMeditationTimer();
                showToast('Meditation session completed!', 'success');
            } else if (meditationType === 'interval' && intervalTimerSteps.length > 0) {
                const totalIntervalDurationSoFar = intervalTimerSteps.slice(0, currentIntervalIndex + 1).reduce((sum, step) => sum + (step.duration * 1000), 0);

                if (meditationElapsedTime >= totalIntervalDurationSoFar) {
                    currentIntervalIndex++;
                    if (currentIntervalIndex < intervalTimerSteps.length) {
                        const nextStep = intervalTimerSteps[currentIntervalIndex];
                        showToast(`Next Interval: ${nextStep.label} (${nextStep.duration}s)`, 'info');
                    } else {
                        stopMeditationTimer();
                        showToast('Interval meditation completed!', 'success');
                    }
                }
            }
        }, 1000);
    }

    function pauseMeditationTimer() {
        if (!meditationTimerInterval) return;
        clearInterval(meditationTimerInterval);
        meditationTimerInterval = null;
        meditationPaused = true;
        activeRecordingSessionType = 'meditation'; // Still considered active but paused
        updateAllTimerButtonStates();
        showToast('Meditation paused.', 'info');
    }

    function stopMeditationTimer() {
        if (!meditationTimerInterval && !meditationPaused) return;

        clearInterval(meditationTimerInterval);
        meditationTimerInterval = null;

        const durationMs = meditationElapsedTime;

        if (durationMs > 5000) { // Only record sessions longer than 5 seconds
            const session = {
                id: generateId(),
                startTime: meditationStartTime,
                endTime: Date.now(),
                durationMs: durationMs,
                date: new Date(meditationStartTime).toDateString(),
                type: meditationType,
                mood: null,
                energy: null,
                tags: [],
                journalEntry: '',
                gratitudeEntry: ''
            };
            meditationSessions.push(session);
            saveData('meditationSessions', meditationSessions);
            renderMeditationSessions();
            updateMeditationStats();
            updateAchievements();
            updateGoals();
            openMeditationJournalModal(session.id);
            showToast('Meditation session recorded!', 'success');
        } else {
            showToast('Meditation session was too short to record (min 5s).', 'info');
        }

        resetMeditationDisplay();
    }

    function resetMeditationDisplay() {
        clearInterval(meditationTimerInterval);
        meditationTimerInterval = null;
        meditationStartTime = 0;
        meditationElapsedTime = 0;
        meditationPaused = false;
        meditationDurationTarget = 0;
        meditationType = 'standard';
        currentIntervalIndex = 0;
        elements.meditationTimerDisplay.textContent = '00:00:00';
        elements.customMeditationMinutesInput.value = ''; // Clear custom input
        
        activeRecordingSessionType = null;
        updateAllTimerButtonStates();
    }

    // --- General function to update ALL timer button states ---
    function updateAllTimerButtonStates() {
        // Meditation Sanctuary Timer States
        const isMeditationRunning = meditationTimerInterval !== null;
        const isMeditationPaused = meditationPaused;
        const isMeditationActive = isMeditationRunning || isMeditationPaused;
        const isMeditationIdle = !isMeditationActive && meditationElapsedTime === 0;

        elements.startMeditationBtn.disabled = isMeditationRunning || activeRecordingSessionType === 'custom-countdown';
        elements.pauseMeditationBtn.disabled = !isMeditationRunning;
        elements.stopMeditationBtn.disabled = (!isMeditationActive && meditationElapsedTime === 0) || activeRecordingSessionType === 'custom-countdown';
        elements.resetMeditationBtn.disabled = isMeditationIdle || activeRecordingSessionType === 'custom-countdown';

        elements.presetMeditationButtons.forEach(btn => btn.disabled = isMeditationActive || activeRecordingSessionType === 'custom-countdown');
        elements.openIntervalTimerBtn.disabled = isMeditationActive || activeRecordingSessionType === 'custom-countdown';
        elements.setCustomMeditationBtn.disabled = isMeditationActive || activeRecordingSessionType === 'custom-countdown';
        elements.customMeditationMinutesInput.disabled = isMeditationActive || activeRecordingSessionType === 'custom-countdown';


        // Custom Countdown Meditation Timer States
        const isCountdownRunning = customCountdownInterval !== null;
        const isCountdownPaused = customCountdownPaused;
        const isCountdownActive = isCountdownRunning || isCountdownPaused;
        const isCountdownIdle = !isCountdownActive && customCountdownRemainingMs === 0;

        elements.startCountdownBtn.disabled = isCountdownRunning || activeRecordingSessionType === 'meditation';
        elements.pauseCountdownBtn.disabled = !isCountdownRunning;
        elements.stopCountdownBtn.disabled = (!isCountdownActive && customCountdownRemainingMs === 0) || activeRecordingSessionType === 'meditation';
        elements.resetCountdownBtn.disabled = isCountdownIdle || activeRecordingSessionType === 'meditation';

        elements.countdownHoursInput.disabled = isCountdownActive || activeRecordingSessionType === 'meditation';
        elements.countdownMinutesInput.disabled = isCountdownActive || activeRecordingSessionType === 'meditation';
        elements.countdownSecondsInput.disabled = isCountdownActive || activeRecordingSessionType === 'meditation';
        elements.countdownLabelInput.disabled = isCountdownActive || activeRecordingSessionType === 'meditation';
        elements.countdownNotificationToggle.disabled = isCountdownActive || activeRecordingSessionType === 'meditation';
    }


    function renderMeditationSessions() {
        elements.meditationSessionsList.innerHTML = ''; // Clear all
        elements.dashMeditationSessionsList.innerHTML = ''; // Clear dashboard

        const sortedSessions = [...meditationSessions].sort((a, b) => b.startTime - a.startTime);

        if (sortedSessions.length === 0) {
            elements.meditationSessionsList.innerHTML = '<li class="info-message">No meditation sessions recorded yet. Start your journey!</li>';
        }

        sortedSessions.forEach(session => {
            const li = document.createElement('li');
            const date = new Date(session.startTime);
            const tags = session.tags && session.tags.length > 0 ? `<br><small>Tags: ${session.tags.join(', ')}</small>` : '';
            li.innerHTML = `
                <div>
                    <span class="session-date">${date.toLocaleDateString()} at ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>
                    <br><strong class="session-duration">${formatDuration(session.durationMs)}</strong> (${session.type === 'interval' ? 'Interval' : session.type === 'freestyle' ? 'Freestyle' : session.type === 'custom-countdown' ? 'Countdown' : 'Standard'})
                    ${session.mood ? `<span class="session-mood-emoji" title="Mood: ${session.mood}"> ${getEmojiForMood(session.mood)}</span>` : ''}
                    ${tags}
                </div>
                <button class="view-journal-btn btn-sm" data-session-id="${session.id}" title="View/Edit Journal" aria-label="View or edit journal for session on ${date.toLocaleDateString()}"><i class="fas fa-feather-alt"></i></button>
            `;
            elements.meditationSessionsList.appendChild(li);
        });

        // Dashboard recent sessions (limit to 3)
        if (sortedSessions.length > 0) {
            sortedSessions.slice(0, 3).forEach(session => {
                const li = document.createElement('li');
                const date = new Date(session.startTime);
                li.innerHTML = `
                    <span class="session-date">${date.toLocaleDateString()}: ${formatDuration(session.durationMs)}</span>
                    ${session.mood ? `<span class="session-mood-emoji" title="Mood: ${session.mood}"> ${getEmojiForMood(session.mood)}</span>` : ''}
                `;
                elements.dashMeditationSessionsList.appendChild(li);
            });
        } else {
            elements.dashMeditationSessionsList.innerHTML = '<li class="info-message">No recent meditations.</li>';
        }

        document.querySelectorAll('.view-journal-btn').forEach(btn => {
            btn.onclick = (e) => openMeditationJournalModal(e.currentTarget.dataset.sessionId);
        });
    }

    function updateMeditationStats() {
        const totalDurationMs = meditationSessions.reduce((sum, session) => sum + session.durationMs, 0);
        
        const { currentStreak, longestStreak } = calculateStreaks();

        // Update Dashboard Stats
        elements.dashTotalMedTime.textContent = formatDuration(totalDurationMs);
        elements.dashTotalMedSessions.textContent = meditationSessions.length;
        elements.dashCurrentStreak.textContent = `${currentStreak} days`;
        
        // Update Chart.js data and re-render
        renderMeditationCharts();
        renderMeditationCalendar();
    }

    function calculateStreaks() {
        if (meditationSessions.length === 0) {
            return { currentStreak: 0, longestStreak: 0 };
        }

        const uniqueDatesMs = [...new Set(meditationSessions
            .map(session => {
                const d = new Date(session.startTime);
                d.setHours(0,0,0,0); // Normalize to midnight
                return d.getTime();
            }))]
            .sort((a, b) => a - b); // Sort chronologically

        let currentStreak = 0;
        let longestStreak = 0;
        let tempCurrentStreak = 0;
        let lastDateMs = null;

        const today = new Date();
        today.setHours(0,0,0,0);
        const todayMs = today.getTime();
        const yesterday = new Date(today);
        yesterday.setDate(today.getDate() - 1);
        const yesterdayMs = yesterday.getTime();


        for (let i = 0; i < uniqueDatesMs.length; i++) {
            const currentDateMs = uniqueDatesMs[i];
            if (lastDateMs === null) {
                tempCurrentStreak = 1;
            } else {
                const dayDiff = (currentDateMs - lastDateMs) / (1000 * 60 * 60 * 24);
                if (dayDiff === 1) { // Consecutive day
                    tempCurrentStreak++;
                } else if (dayDiff > 1) { // Gap
                    tempCurrentStreak = 1;
                }
            }
            longestStreak = Math.max(longestStreak, tempCurrentStreak);
            lastDateMs = currentDateMs;
        }

        // Calculate current streak based on today or yesterday having a session
        const latestUniqueDate = uniqueDatesMs[uniqueDatesMs.length - 1];

        if (latestUniqueDate === todayMs) {
            currentStreak = tempCurrentStreak;
        } else if (latestUniqueDate === yesterdayMs) {
            // If the last session was yesterday, current streak is the streak ending yesterday.
            // This 'tempCurrentStreak' already reflects the streak ending at latestUniqueDate.
            currentStreak = tempCurrentStreak;
        } else {
            currentStreak = 0; // No session today or yesterday, streak broken
        }
        
        return { currentStreak, longestStreak };
    }

    function openMeditationJournalModal(sessionId) {
        const session = meditationSessions.find(s => s.id === sessionId);
        if (session) {
            // Reset mood selection and set accessibility attributes
            elements.journalMoodEmojis.forEach(emoji => {
                emoji.classList.remove('selected');
                emoji.setAttribute('aria-checked', 'false');
            });
            if (session.mood) {
                const selectedEmoji = document.querySelector(`.mood-emojis .emoji[data-mood="${session.mood}"]`);
                if (selectedEmoji) {
                    selectedEmoji.classList.add('selected');
                    selectedEmoji.setAttribute('aria-checked', 'true');
                }
            }

            elements.journalEnergyLevel.value = session.energy !== null ? session.energy : 5;
            elements.journalEnergyValue.textContent = elements.journalEnergyLevel.value;

            elements.journalTagsInput.value = session.tags ? session.tags.join(', ') : '';
            elements.journalTextInput.value = session.journalEntry || '';
            elements.gratitudeTextInput.value = session.gratitudeEntry || '';

            elements.saveJournalEntryBtn.onclick = () => {
                session.mood = document.querySelector('.mood-emojis .emoji.selected')?.dataset.mood || null;
                session.energy = parseInt(elements.journalEnergyLevel.value, 10);
                session.tags = elements.journalTagsInput.value.split(',').map(tag => tag.trim()).filter(tag => tag);
                session.journalEntry = elements.journalTextInput.value.trim();
                session.gratitudeEntry = elements.gratitudeTextInput.value.trim();

                saveData('meditationSessions', meditationSessions);
                closeModal(elements.meditationJournalModal);
                renderMeditationSessions(); // Re-render to show mood/tags
                updateMeditationStats(); // Re-render charts
                updateAchievements(); // Check for 'first_journal_entry' achievement
                showToast('Journal entry saved!', 'success');
            };
            openModal(elements.meditationJournalModal);
        }
    }

    function getEmojiForMood(mood) {
        switch (mood) {
            case 'calm': return '😌';
            case 'focused': return '🧐';
            case 'peaceful': return '🕊️';
            case 'energetic': return '⚡';
            case 'tired': return '😴';
            case 'anxious': return '😟';
            case 'happy': return '😊';
            default: return '';
        }
    }

    function addIntervalStep() {
        const stepCount = elements.intervalStepsContainer.children.length;
        const div = document.createElement('div');
        div.className = 'interval-step';
        div.innerHTML = `
            <label>Step ${stepCount + 1}:</label>
            <input type="number" value="60" min="5" placeholder="Seconds" data-type="duration" class="input-field small-input" aria-label="Step ${stepCount + 1} duration in seconds"><span>s</span>
            <input type="text" placeholder="Label (e.g., Focus)" data-type="label" class="input-field" aria-label="Step ${stepCount + 1} label">
            <button class="delete-step-btn delete-button btn-sm" aria-label="Delete Step"><i class="fas fa-times"></i></button>
        `;
        elements.intervalStepsContainer.appendChild(div);
        div.querySelector('.delete-step-btn').onclick = (e) => e.target.closest('.interval-step').remove();
    }

    function getIntervalStepsFromUI() {
        const steps = [];
        elements.intervalStepsContainer.querySelectorAll('.interval-step').forEach(stepDiv => {
            const duration = parseInt(stepDiv.querySelector('[data-type="duration"]').value, 10);
            const label = stepDiv.querySelector('[data-type="label"]').value || `Step ${steps.length + 1}`;
            if (!isNaN(duration) && duration > 0) {
                steps.push({ duration, label });
            }
        });
        return steps;
    }

    // --- Custom Countdown Meditation Logic ---

    function updateCustomCountdownDisplay() {
        elements.generalCountdownDisplay.textContent = formatTime(customCountdownRemainingMs);
        const hours = Math.floor(customCountdownRemainingMs / (1000 * 60 * 60));
        const minutes = Math.floor((customCountdownRemainingMs % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((customCountdownRemainingMs % (1000 * 60)) / 1000);
        elements.countdownHoursInput.value = String(hours).padStart(2, '0');
        elements.countdownMinutesInput.value = String(minutes).padStart(2, '0');
        elements.countdownSecondsInput.value = String(seconds).padStart(2, '0');
    }

    function startCustomCountdown() {
        if (activeRecordingSessionType) {
            showToast('Another meditation timer is already active!', 'warning');
            return;
        }

        const h = parseInt(elements.countdownHoursInput.value) || 0;
        const m = parseInt(elements.countdownMinutesInput.value) || 0;
        const s = parseInt(elements.countdownSecondsInput.value) || 0;

        let totalMsForThisRun = (h * 3600 + m * 60 + s) * 1000;

        if (totalMsForThisRun <= 0 && customCountdownRemainingMs <= 0) {
            showToast('Please set a duration for the countdown!', 'error');
            return;
        }

        if (!customCountdownPaused) {
            customCountdownInitialSetMs = totalMsForThisRun; // Only set initial total if not resuming from pause
            customCountdownRemainingMs = totalMsForThisRun;
            customCountdownStartTime = Date.now(); // Record when this session *actually starts* for recording
        } else {
            customCountdownStartTime = Date.now() - (customCountdownInitialSetMs - customCountdownRemainingMs); // Adjust start time for pause
            customCountdownPaused = false;
        }
        
        if (customCountdownRemainingMs <= 0) {
            showToast('Countdown finished. Please set a new duration.', 'info');
            resetCustomCountdown();
            return;
        }
        
        customCountdownEndTime = Date.now() + customCountdownRemainingMs;
        activeRecordingSessionType = 'custom-countdown';
        updateAllTimerButtonStates();

        showToast(`Countdown "${elements.countdownLabelInput.value || 'Timer'}" started.`, 'info');

        customCountdownInterval = setInterval(() => {
            customCountdownRemainingMs = customCountdownEndTime - Date.now();

            if (customCountdownRemainingMs <= 0) {
                customCountdownRemainingMs = 0;
                stopCustomCountdown(true); // Call stop with 'finished' flag
                showToast(`Countdown "${elements.countdownLabelInput.value || 'Timer'}" finished!`, 'success');
            }
            updateCustomCountdownDisplay();
            saveCustomCountdownState(); // Save state every second
        }, 1000);
    }

    function pauseCustomCountdown() {
        if (!customCountdownInterval) return;
        clearInterval(customCountdownInterval);
        customCountdownInterval = null;
        customCountdownPaused = true;
        customCountdownEndTime = 0; // Clear end time when paused
        activeRecordingSessionType = 'custom-countdown'; // Still considered active but paused
        updateAllTimerButtonStates();
        saveCustomCountdownState();
        showToast(`Countdown "${elements.countdownLabelInput.value || 'Timer'}" paused.`, 'info');
    }

    function stopCustomCountdown(finished = false) {
        if (!customCountdownInterval && !customCountdownPaused) return;

        clearInterval(customCountdownInterval);
        customCountdownInterval = null;
        
        const durationMs = customCountdownInitialSetMs - customCountdownRemainingMs; // Total time elapsed during active countdown

        if (durationMs > 5000) { // Only record sessions longer than 5 seconds
            const session = {
                id: generateId(),
                startTime: customCountdownStartTime,
                endTime: Date.now(),
                durationMs: durationMs,
                date: new Date(customCountdownStartTime).toDateString(),
                type: 'custom-countdown', // Specific type for this timer
                mood: null,
                energy: null,
                tags: elements.countdownLabelInput.value ? [elements.countdownLabelInput.value] : [], // Use label as initial tag
                journalEntry: '',
                gratitudeEntry: ''
            };
            meditationSessions.push(session);
            saveData('meditationSessions', meditationSessions);
            renderMeditationSessions();
            updateMeditationStats();
            updateAchievements();
            updateGoals();
            openMeditationJournalModal(session.id);
            showToast('Countdown meditation session recorded!', 'success');
        } else if (!finished) { // Don't show for finished timers that are too short
            showToast('Countdown meditation session was too short to record (min 5s).', 'info');
        }

        if (finished) {
            if (customCountdownState.notify && Notification.permission === 'granted') {
                new Notification('Yogify Countdown Meditation', {
                    body: `${elements.countdownLabelInput.value || 'Your custom countdown'} has finished!`,
                    icon: './img/icon.png'
                });
            }
            resetCustomCountdown(); // Full reset after finishing
        } else {
            showToast(`Countdown "${elements.countdownLabelInput.value || 'Timer'}" stopped.`, 'info');
            resetCustomCountdown(); // Full reset if manually stopped
        }
    }

    function resetCustomCountdown() {
        clearInterval(customCountdownInterval);
        customCountdownInterval = null;
        customCountdownStartTime = 0;
        customCountdownRemainingMs = 0;
        customCountdownInitialSetMs = 0;
        customCountdownPaused = false;
        customCountdownEndTime = 0;
        
        elements.countdownHoursInput.value = '00';
        elements.countdownMinutesInput.value = '00';
        elements.countdownSecondsInput.value = '00';
        elements.generalCountdownDisplay.textContent = '00:00:00';

        elements.countdownLabelInput.value = ''; // Clear label
        elements.countdownNotificationToggle.checked = false; // Reset notification toggle

        activeRecordingSessionType = null;
        updateAllTimerButtonStates();
        saveCustomCountdownState();
    }

    function saveCustomCountdownState() {
        customCountdownState = {
            remainingMs: customCountdownRemainingMs,
            initialSetMs: customCountdownInitialSetMs,
            paused: customCountdownPaused,
            endTime: customCountdownEndTime,
            label: elements.countdownLabelInput.value,
            notify: elements.countdownNotificationToggle.checked
        };
        saveData('customCountdownState', customCountdownState);
    }

    function loadCustomCountdownState() {
        elements.countdownLabelInput.value = customCountdownState.label;
        elements.countdownNotificationToggle.checked = customCountdownState.notify;

        if (customCountdownState.paused) {
            customCountdownRemainingMs = customCountdownState.remainingMs;
            customCountdownInitialSetMs = customCountdownState.initialSetMs;
            customCountdownPaused = true;
            activeRecordingSessionType = 'custom-countdown';
            updateCustomCountdownDisplay();
            updateAllTimerButtonStates(); // Set to paused state
            showToast(`Countdown "${customCountdownState.label || 'Timer'}" was paused.`, 'info');
        } else if (customCountdownState.endTime > 0) {
            // Timer was running, calculate remaining time
            customCountdownRemainingMs = customCountdownState.endTime - Date.now();
            customCountdownInitialSetMs = customCountdownState.initialSetMs;

            if (customCountdownRemainingMs <= 0) {
                // Timer finished while app was closed
                customCountdownRemainingMs = 0;
                updateCustomCountdownDisplay();
                activeRecordingSessionType = null; // Clear active session type
                updateAllTimerButtonStates(); // Set to idle state
                if (customCountdownState.notify && Notification.permission === 'granted') {
                    new Notification('Yogify Countdown Meditation', {
                        body: `${customCountdownState.label || 'Your custom countdown'} finished while you were away!`,
                        icon: './img/icon.png'
                    });
                }
                resetCustomCountdown(); // Fully reset
                showToast(`Countdown "${customCountdownState.label || 'Timer'}" finished!`, 'success');
            } else {
                // Timer is still running
                customCountdownPaused = false; // Set to not paused to restart it
                customCountdownStartTime = Date.now() - (customCountdownInitialSetMs - customCountdownRemainingMs); // Recalculate startTime
                updateCustomCountdownDisplay();
                startCustomCountdown(); // Restart the interval
                showToast(`Countdown "${customCountdownState.label || 'Timer'}" resumed.`, 'info');
            }
        } else {
            // No active timer, set initial display from inputs
            const h = parseInt(elements.countdownHoursInput.value) || 0;
            const m = parseInt(elements.countdownMinutesInput.value) || 0;
            const s = parseInt(elements.countdownSecondsInput.value) || 0;
            customCountdownRemainingMs = (h * 3600 + m * 60 + s) * 1000;
            customCountdownInitialSetMs = customCountdownRemainingMs;
            updateCustomCountdownDisplay();
            activeRecordingSessionType = null;
            updateAllTimerButtonStates(); // Ensure buttons are reset
        }
    }


    // --- Book Tracking Logic ---

    let newBookCoverBase64 = null; // Store base64 of selected cover image

    function addBook() {
        const title = elements.newBookTitleInput.value.trim();
        const author = elements.newBookAuthorInput.value.trim();
        const totalPages = parseInt(elements.newBookPagesInput.value, 10);
        const genre = elements.newBookGenreInput.value.trim();

        if (!title) {
            showToast('Please enter a book title!', 'error');
            return;
        }
        if (totalPages < 0) {
            showToast('Total pages cannot be negative!', 'error');
            return;
        }


        books.push({
            id: generateId(),
            title: title,
            author: author || 'Unknown Author',
            totalPages: isNaN(totalPages) ? 0 : totalPages,
            currentPage: 0,
            readingSessions: [],
            notes: [],
            coverImage: newBookCoverBase64,
            status: 'Want to Read',
            rating: 0,
            genre: genre
        });
        saveData('books', books);
        elements.newBookTitleInput.value = '';
        elements.newBookAuthorInput.value = '';
        elements.newBookPagesInput.value = '';
        elements.newBookGenreInput.value = '';
        newBookCoverBase64 = null; // Clear selected cover
        elements.uploadBookCoverBtn.innerHTML = '<i class="fas fa-image"></i> Upload Cover Image'; // Reset button icon & text
        renderBooks();
        updateBookStatistics();
        updateAchievements();
        updateGoals();
        showToast('Book added successfully!', 'success');
    }

    function startBookReading(bookId) {
        if (currentReadingBookId) {
            if (currentReadingBookId === bookId) {
                 showToast('You are already reading this book.', 'info');
            } else {
                 showToast('Please stop reading the current book before starting another.', 'info');
            }
            return;
        }

        currentReadingBookId = bookId;
        bookReadingStartTime = Date.now();
        // Set book status to 'Reading' automatically
        const book = books.find(b => b.id === bookId);
        if (book && book.status !== 'Reading') {
            book.status = 'Reading';
            saveData('books', books);
            renderBooks(); // Re-render to update status display
        }
        updateBookButtonsState();
        showToast(`Started reading "${book.title}".`, 'info');
    }

    function stopBookReading(bookId) {
        if (currentReadingBookId !== bookId) return; // Only stop if it's the currently tracked book

        clearInterval(bookReadingTimerInterval); // Ensure any interval is cleared (though not used currently)
        const endTime = Date.now();
        const durationMs = endTime - bookReadingStartTime;

        const book = books.find(b => b.id === bookId);
        if (book && durationMs > 5000) { // Only record sessions longer than 5 seconds
            book.readingSessions.push({
                startTime: bookReadingStartTime,
                endTime: endTime,
                durationMs: durationMs
            });
            saveData('books', books);
            showToast(`Recorded ${formatDuration(durationMs)} for "${book.title}".`, 'success');
        } else if (durationMs <= 5000) {
            showToast('Reading session was too short to record (>5s required).', 'info');
        }

        currentReadingBookId = null;
        bookReadingStartTime = 0;
        updateBookButtonsState();
        renderBooks();
        updateBookStatistics();
    }

    function updateBookButtonsState() {
        document.querySelectorAll('.book-item').forEach(bookItem => {
            const bookId = bookItem.dataset.id;
            const startBtn = bookItem.querySelector('.start-reading');
            const stopBtn = bookItem.querySelector('.stop-reading');
            if (startBtn && stopBtn) {
                startBtn.disabled = currentReadingBookId !== null;
                stopBtn.disabled = currentReadingBookId !== bookId;
            }
        });
    }

    function renderBooks(filterText = '') {
        elements.booksList.innerHTML = '';
        elements.dashCurrentReadingList.innerHTML = ''; // Clear dashboard current reading

        const filteredBooks = books.filter(book => {
            const lowerCaseFilter = filterText.toLowerCase();
            return book.title.toLowerCase().includes(lowerCaseFilter) ||
                   book.author.toLowerCase().includes(lowerCaseFilter) ||
                   book.genre.toLowerCase().includes(lowerCaseFilter);
        }).sort((a,b) => a.title.localeCompare(b.title)); // Sort alphabetically

        if (filteredBooks.length === 0 && filterText === '') {
            elements.booksList.innerHTML = '<li class="info-message">No spiritual books added yet. Add your first scroll of wisdom!</li>';
        } else if (filteredBooks.length === 0 && filterText !== '') {
            elements.booksList.innerHTML = `<li class="info-message">No books matching "${filterText}".</li>`;
        }

        filteredBooks.forEach(book => {
            const li = document.createElement('li');
            li.className = 'book-item';
            li.dataset.id = book.id;

            const totalReadingMs = book.readingSessions.reduce((sum, session) => sum + session.durationMs, 0);
            const progress = book.totalPages > 0 ? ((book.currentPage / book.totalPages) * 100).toFixed(1) : 0;
            const coverSrc = book.coverImage || './img/default_book.png'; // Fallback to default image

            li.innerHTML = `
                <img src="${coverSrc}" alt="Book Cover of ${book.title}" class="book-cover-thumbnail">
                <div class="book-item-info">
                    <strong>${book.title}</strong>
                    <span>by ${book.author} | ${book.genre || 'N/A'}</span>
                    <span>Status: ${book.status} | Progress: ${book.currentPage}/${book.totalPages} (${progress}%)</span>
                    <span>Total Read: ${formatDuration(totalReadingMs)}</span>
                </div>
                <div class="book-item-controls">
                    <button class="start-reading btn-sm" data-book-id="${book.id}" title="Start Reading" aria-label="Start reading ${book.title}">
                        <i class="fas fa-play"></i>
                    </button>
                    <button class="stop-reading btn-sm" data-book-id="${book.id}" title="Stop Reading" aria-label="Stop reading ${book.title}">
                        <i class="fas fa-stop"></i>
                    </button>
                    <button class="view-book-details btn-sm" data-book-id="${book.id}" title="View Details & Notes" aria-label="View details for ${book.title}">
                        <i class="fas fa-info-circle"></i>
                    </button>
                    <button class="delete-book delete-button btn-sm" data-book-id="${book.id}" title="Delete Book" aria-label="Delete ${book.title}">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                </div>
            `;
            elements.booksList.appendChild(li);
        });

        // Dashboard: Currently Reading (limit to 2)
        const currentlyReadingBooks = books.filter(book => book.status === 'Reading').slice(0, 2);
        if (currentlyReadingBooks.length > 0) {
            currentlyReadingBooks.forEach(book => {
                const li = document.createElement('li');
                const progress = book.totalPages > 0 ? ((book.currentPage / book.totalPages) * 100).toFixed(1) : 0;
                li.innerHTML = `
                    <span><strong>${book.title}</strong> by ${book.author}</span>
                    <span>Progress: ${progress}%</span>
                `;
                elements.dashCurrentReadingList.appendChild(li);
            });
        } else {
            elements.dashCurrentReadingList.innerHTML = '<li class="info-message">No books currently being read.</li>';
        }

        updateBookButtonsState(); // Set initial button states after rendering
    }

    function deleteBook(bookId) {
        if (currentReadingBookId === bookId) {
            showToast('Cannot delete a book while it is being read. Please stop the timer first.', 'error');
            return;
        }
        showConfirmationModal('Are you sure you want to delete this book and all its reading records? This action cannot be undone.', () => {
            books = books.filter(book => book.id !== bookId);
            saveData('books', books);
            renderBooks();
            updateBookStatistics();
            updateAchievements();
            updateGoals();
            showToast('Book deleted successfully!', 'success');
            closeModal(elements.confirmationModal);
        });
    }

    function openBookDetailsModal(bookId) {
        const book = books.find(b => b.id === bookId);
        if (!book) return;

        elements.modalBookCoverImg.src = book.coverImage || './img/default_book.png';
        elements.modalBookTitle.textContent = book.title;
        elements.modalBookAuthor.textContent = book.author;
        elements.modalBookGenre.textContent = book.genre || 'N/A';
        
        elements.modalBookTotalPages.textContent = book.totalPages;
        elements.modalBookCurrentPage.value = book.currentPage;

        const totalReadingMs = book.readingSessions.reduce((sum, s) => sum + s.durationMs, 0);
        elements.modalBookTotalReadingTime.textContent = formatDuration(totalReadingMs);

        // Update progress bar and text
        const updateProgressDisplay = () => {
            const progress = book.totalPages > 0 ? ((book.currentPage / book.totalPages) * 100).toFixed(1) : 0;
            elements.modalBookProgress.textContent = `${progress}%`;
            elements.modalProgressBar.style.width = `${progress}%`;
            elements.modalProgressBar.ariaValueNow = progress;
        };
        updateProgressDisplay();

        elements.modalBookCurrentPage.onchange = (e) => {
            const newPage = parseInt(e.target.value, 10);
            if (!isNaN(newPage) && newPage >= 0 && newPage <= book.totalPages) {
                book.currentPage = newPage;
                saveData('books', books);
                updateProgressDisplay();
                renderBooks(); // Re-render main list to update progress
                updateAchievements();
                updateGoals();
            } else {
                e.target.value = book.currentPage; // Revert to previous valid page
                showToast(`Invalid page number! Must be between 0 and ${book.totalPages}.`, 'error');
            }
        };

        // Render Rating Stars
        elements.modalBookRating.innerHTML = '';
        for (let i = 1; i <= 5; i++) {
            const star = document.createElement('i');
            star.className = `fas fa-star ${i <= book.rating ? 'active' : ''}`;
            star.dataset.rating = i;
            star.setAttribute('role', 'radio');
            star.setAttribute('aria-label', `${i} stars`);
            star.setAttribute('aria-checked', i <= book.rating ? 'true' : 'false');
            star.tabIndex = 0; // Make stars keyboard navigable
            star.onclick = () => {
                book.rating = i;
                saveData('books', books);
                openBookDetailsModal(bookId); // Re-render stars
                showToast(`Rated "${book.title}" ${i} stars.`, 'info');
            };
            // Add keyboard navigation for stars
            star.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    book.rating = i;
                    saveData('books', books);
                    openBookDetailsModal(bookId); // Re-render stars
                    showToast(`Rated "${book.title}" ${i} stars.`, 'info');
                }
            });
            elements.modalBookRating.appendChild(star);
        }

        // Dropdown for Status
        const statusSelect = document.createElement('select');
        statusSelect.className = 'input-field small-input';
        statusSelect.setAttribute('aria-label', `Change status for ${book.title}`);
        ['Reading', 'Finished', 'Want to Read'].forEach(status => {
            const option = document.createElement('option');
            option.value = status;
            option.textContent = status;
            if (book.status === status) option.selected = true;
            statusSelect.appendChild(option);
        });
        statusSelect.onchange = (e) => {
            book.status = e.target.value;
            saveData('books', books);
            renderBooks(); // Update status in main list
            updateAchievements(); // Check for 'Books Finished' achievement
            updateGoals();
            showToast(`Status for "${book.title}" changed to "${book.status}".`, 'info');
        };
        elements.modalBookStatusContainer.innerHTML = ''; // Clear previous content
        elements.modalBookStatusContainer.appendChild(statusSelect);


        elements.modalBookNotesInput.value = ''; // Clear input for new note
        renderBookNotes(book);

        elements.addBookNoteBtn.onclick = () => {
            const noteText = elements.modalBookNotesInput.value.trim();
            if (noteText) {
                book.notes.push({ id: generateId(), text: noteText, date: new Date().toISOString() });
                saveData('books', books);
                elements.modalBookNotesInput.value = '';
                renderBookNotes(book);
                updateAchievements(); // Check for 'first_book_note' achievement
                showToast('Note added!', 'success');
            } else {
                showToast('Note cannot be empty!', 'warning');
            }
        };

        openModal(elements.bookDetailsModal);
    }

    function renderBookNotes(book) {
        elements.modalBookNotesList.innerHTML = '';
        if (book.notes.length === 0) {
            elements.modalBookNotesList.innerHTML = '<li class="info-message">No notes yet. Add your insights!</li>';
            return;
        }

        book.notes.sort((a,b) => new Date(b.date) - new Date(a.date)).forEach(note => { // Newest first
            const li = document.createElement('li');
            li.className = 'note-item';
            li.innerHTML = `
                <div class="note-content">${note.text}</div>
                <span class="note-date">${new Date(note.date).toLocaleDateString()} ${new Date(note.date).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>
                <button class="delete-note-btn delete-button btn-sm" data-note-id="${note.id}" aria-label="Delete note"><i class="fas fa-times"></i></button>
            `;
            elements.modalBookNotesList.appendChild(li);
        });

        elements.modalBookNotesList.querySelectorAll('.delete-note-btn').forEach(btn => {
            btn.onclick = (e) => {
                const noteId = e.currentTarget.dataset.noteId;
                book.notes = book.notes.filter(n => n.id !== noteId);
                saveData('books', books);
                renderBookNotes(book);
                showToast('Note deleted.', 'info');
            };
        });
    }

    // --- Statistics & Charts ---

    // Helper to get CSS variable for chart colors
    function getCssVar(name) {
        return getComputedStyle(document.body).getPropertyValue(name).trim();
    }

    function createOrUpdateChart(chartVar, canvasId, type, data, options) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        if (chartVar) {
            chartVar.destroy(); // Destroy previous chart instance
        }
        return new Chart(ctx, { type, data, options });
    }

    function renderMeditationCharts() {
        const textColor = getCssVar('--text-color');
        const primaryColor = getCssVar('--primary-color');
        const secondaryColor = getCssVar('--secondary-color');
        const accentColor = getCssVar('--accent-color');
        const borderColor = getCssVar('--border-color');
        const cardBg = getCssVar('--card-background');
        const secondaryColorAlpha = getCssVar('--secondary-color-alpha');


        // Common chart options
        const commonOptions = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { labels: { color: textColor } },
                tooltip: {
                    bodyColor: textColor,
                    titleColor: primaryColor,
                    backgroundColor: cardBg,
                    borderColor: borderColor,
                    borderWidth: 1,
                }
            },
            scales: {
                x: {
                    type: 'time',
                    time: { unit: 'day', tooltipFormat: 'MMM d, yyyy' },
                    title: { display: true, text: 'Date', color: primaryColor },
                    ticks: { color: textColor },
                    grid: { color: borderColor }
                },
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Value', color: primaryColor },
                    ticks: { color: textColor },
                    grid: { color: borderColor }
                }
            }
        };

        // Data for Meditation Time Trend (Daily)
        const dailyMedTime = {};
        meditationSessions.forEach(session => {
            const date = new Date(session.startTime).toISOString().slice(0, 10);
            dailyMedTime[date] = (dailyMedTime[date] || 0) + session.durationMs;
        });
        const sortedDates = Object.keys(dailyMedTime).sort();
        const medTimeData = sortedDates.map(date => ({ x: date, y: dailyMedTime[date] / (1000 * 60) })); // Minutes

        meditationTimeChart = createOrUpdateChart(meditationTimeChart, 'meditationTimeChart', 'line', {
            datasets: [{
                label: 'Daily Meditation Time (minutes)',
                data: medTimeData,
                borderColor: secondaryColor,
                tension: 0.3,
                fill: true,
                backgroundColor: secondaryColorAlpha, // Use alpha version of secondary
                pointRadius: 3,
                pointHoverRadius: 6
            }]
        }, { ...commonOptions, scales: { ...commonOptions.scales, y: { ...commonOptions.scales.y, title: { display: true, text: 'Minutes' } } } });

        // Data for Meditation Session Count
        const dailySessionCount = {};
        meditationSessions.forEach(session => {
            const date = new Date(session.startTime).toISOString().slice(0, 10);
            dailySessionCount[date] = (dailySessionCount[date] || 0) + 1;
        });
        const sessionCountData = sortedDates.map(date => ({ x: date, y: dailySessionCount[date] }));

        meditationSessionsChart = createOrUpdateChart(meditationSessionsChart, 'meditationSessionsChart', 'bar', {
            datasets: [{
                label: 'Daily Meditation Sessions',
                data: sessionCountData,
                backgroundColor: primaryColor,
                borderColor: primaryColor,
                borderWidth: 1
            }]
        }, { ...commonOptions, scales: { ...commonOptions.scales, y: { ...commonOptions.scales.y, title: { display: true, text: 'Sessions' }, ticks: { precision: 0 } } } });

        // Mood Distribution Chart
        const moodCounts = {};
        meditationSessions.forEach(session => {
            if (session.mood) {
                moodCounts[session.mood] = (moodCounts[session.mood] || 0) + 1;
            }
        });
        const moodLabels = Object.keys(moodCounts);
        const moodData = Object.values(moodCounts);
        const moodColors = moodLabels.map(mood => { // Assign consistent colors
            switch (mood) {
                case 'calm': return '#66bb6a'; // Light Green
                case 'focused': return '#42a5f5'; // Light Blue
                case 'peaceful': return '#ab47bc'; // Purple
                case 'energetic': return '#ffee58'; // Yellow
                case 'tired': return '#9e9e9e'; // Grey
                case 'anxious': return '#ef5350'; // Red
                case 'happy': return '#ffca28'; // Amber
                default: return '#CCCCCC';
            }
        });

        moodDistributionChart = createOrUpdateChart(moodDistributionChart, 'moodDistributionChart', 'pie', {
            labels: moodLabels,
            datasets: [{
                data: moodData,
                backgroundColor: moodColors,
                borderColor: cardBg,
                borderWidth: 2
            }]
        }, {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'top', labels: { color: textColor } },
                title: { display: true, text: 'Mood Distribution', color: primaryColor },
                tooltip: {
                    bodyColor: textColor,
                    titleColor: primaryColor,
                    backgroundColor: cardBg,
                    borderColor: borderColor,
                    borderWidth: 1,
                    callbacks: {
                        label: function(context) {
                            let label = context.label || '';
                            if (label) {
                                label += ': ';
                            }
                            if (context.parsed !== null) {
                                label += context.parsed;
                                const total = context.dataset.data.reduce((sum, val) => sum + val, 0);
                                const percentage = ((context.parsed / total) * 100).toFixed(1) + '%';
                                label += ` (${percentage})`;
                            }
                            return label;
                        }
                    }
                }
            }
        });

        // Top Tags Chart
        const tagCounts = {};
        meditationSessions.forEach(session => {
            if (session.tags) {
                session.tags.forEach(tag => {
                    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                });
            }
        });
        const sortedTags = Object.entries(tagCounts).sort(([, a], [, b]) => b - a).slice(0, 10); // Top 10
        const tagLabels = sortedTags.map(([tag]) => tag);
        const tagData = sortedTags.map(([, count]) => count);

        topTagsChart = createOrUpdateChart(topTagsChart, 'topTagsChart', 'bar', {
            labels: tagLabels,
            datasets: [{
                label: 'Tag Usage',
                data: tagData,
                backgroundColor: accentColor,
                borderColor: accentColor,
                borderWidth: 1
            }]
        }, {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y', // Horizontal bars
            plugins: {
                legend: { labels: { color: textColor } },
                title: { display: true, text: 'Top Meditation Tags', color: primaryColor },
                tooltip: {
                    bodyColor: textColor,
                    titleColor: primaryColor,
                    backgroundColor: cardBg,
                    borderColor: borderColor,
                    borderWidth: 1,
                }
            },
            scales: {
                x: {
                    beginAtZero: true,
                    title: { display: true, text: 'Count', color: primaryColor },
                    ticks: { precision: 0, color: textColor },
                    grid: { color: borderColor }
                },
                y: {
                    title: { display: true, text: 'Tag', color: primaryColor },
                    ticks: { color: textColor },
                    grid: { color: borderColor }
                }
            }
        });
    }

    function updateBookStatistics() {
        const textColor = getCssVar('--text-color');
        const primaryColor = getCssVar('--primary-color');
        const secondaryColor = getCssVar('--secondary-color');
        const borderColor = getCssVar('--border-color');
        const cardBg = getCssVar('--card-background');


        // Book Reading Time Chart
        const bookReadingTotals = {};
        books.forEach(book => {
            bookReadingTotals[book.title] = book.readingSessions.reduce((sum, s) => sum + s.durationMs, 0) / (1000 * 60 * 60); // Hours
        });
        const sortedBookData = Object.entries(bookReadingTotals).sort(([, a], [, b]) => b - a).filter(([, time]) => time > 0);
        const bookLabels = sortedBookData.map(([title]) => title);
        const bookData = sortedBookData.map(([, time]) => time);

        bookReadingTimeChart = createOrUpdateChart(bookReadingTimeChart, 'bookReadingTimeChart', 'bar', {
            labels: bookLabels,
            datasets: [{
                label: 'Total Reading Time (hours)',
                data: bookData,
                backgroundColor: secondaryColor,
                borderColor: secondaryColor,
                borderWidth: 1
            }]
        }, {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { labels: { color: textColor } },
                title: { display: true, text: 'Book Reading Time by Book', color: primaryColor },
                tooltip: {
                    bodyColor: textColor,
                    titleColor: primaryColor,
                    backgroundColor: cardBg,
                    borderColor: borderColor,
                    borderWidth: 1,
                }
            },
            scales: {
                x: {
                    beginAtZero: true,
                    title: { display: true, text: 'Book Title', color: primaryColor },
                    ticks: { color: textColor },
                    grid: { color: borderColor }
                },
                y: {
                    title: { display: true, text: 'Hours', color: primaryColor },
                    ticks: { color: textColor },
                    grid: { color: borderColor }
                }
            }
        });
    }

    function renderMeditationCalendar() {
        elements.meditationCalendar.innerHTML = '';
        const meditatedDays = new Set(meditationSessions.map(s => new Date(s.startTime).toDateString()));

        const today = new Date();
        today.setHours(0,0,0,0);

        const now = new Date();
        const currentYear = now.getFullYear();
        const currentMonth = now.getMonth();

        // Header for the current month
        const header = document.createElement('div');
        header.className = 'calendar-header';
        header.textContent = new Date(currentYear, currentMonth).toLocaleString('default', { month: 'long', year: 'numeric' });
        elements.meditationCalendar.appendChild(header);

        // Day names
        const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        dayNames.forEach(day => {
            const div = document.createElement('div');
            div.className = 'calendar-day-name';
            div.textContent = day;
            elements.meditationCalendar.appendChild(div);
        });

        // Days of the month
        const firstDayOfMonth = new Date(currentYear, currentMonth, 1);
        const lastDayOfMonth = new Date(currentYear, currentMonth + 1, 0);
        const startDayOfWeek = firstDayOfMonth.getDay(); // 0 for Sunday, 1 for Monday...

        // Empty cells for days before the 1st
        for (let i = 0; i < startDayOfWeek; i++) {
            const div = document.createElement('div');
            div.className = 'calendar-day empty';
            elements.meditationCalendar.appendChild(div);
        }

        for (let day = 1; day <= lastDayOfMonth.getDate(); day++) {
            const date = new Date(currentYear, currentMonth, day);
            date.setHours(0,0,0,0);
            const dateString = date.toDateString();
            const div = document.createElement('div');
            div.className = 'calendar-day';
            div.textContent = day;

            if (meditatedDays.has(dateString)) {
                div.classList.add('meditated');
            }
            if (date.getTime() === today.getTime()) {
                div.classList.add('current-day');
            }
            elements.meditationCalendar.appendChild(div);
        }
    }


    // --- Goals Logic ---

    const GOAL_TYPES = {
        meditation_duration: { label: 'Meditation Duration', unit: 'minutes', getProgress: () => meditationSessions.reduce((sum, s) => sum + s.durationMs, 0) / (1000 * 60) },
        meditation_days: { label: 'Meditation Days', unit: 'days', getProgress: () => new Set(meditationSessions.map(s => s.date)).size },
        books_finished: { label: 'Books Finished', unit: 'books', getProgress: () => books.filter(b => b.status === 'Finished').length }
    };

    function addGoal() {
        const type = elements.goalTypeSelect.value;
        const value = parseInt(elements.goalValueInput.value, 10);
        const period = elements.goalPeriodSelect.value;

        if (isNaN(value) || value <= 0) {
            showToast('Please enter a valid target value for your goal (must be a positive number).', 'error');
            return;
        }

        const newGoal = {
            id: generateId(),
            type: type,
            targetValue: value,
            period: period,
            currentProgress: 0, // Will be calculated by updateGoals
            completed: false,
            startDate: new Date().toISOString(),
            lastUpdate: null // Will be set on completion
        };
        goals.push(newGoal);
        saveData('goals', goals);
        elements.goalValueInput.value = '';
        renderGoals();
        updateGoals();
        showToast('Goal added successfully!', 'success');
    }

    function updateGoals() {
        const now = new Date();
        const startOfThisWeek = new Date(now);
        startOfThisWeek.setDate(now.getDate() - now.getDay()); // Sunday (adjust if your week starts on Monday)
        startOfThisWeek.setHours(0,0,0,0);

        const startOfThisMonth = new Date(now.getFullYear(), now.getMonth(), 1);
        startOfThisMonth.setHours(0,0,0,0);

        let changed = false;

        goals.forEach(goal => {
            if (goal.completed) return;

            let relevantMeditations = [];
            let relevantBooks = [];
            let currentProgress = 0;

            if (goal.period === 'week') {
                relevantMeditations = meditationSessions.filter(s => new Date(s.startTime) >= startOfThisWeek);
                relevantBooks = books; // Currently, book goals are overall, not per week/month
            } else if (goal.period === 'month') {
                relevantMeditations = meditationSessions.filter(s => new Date(s.startTime) >= startOfThisMonth);
                relevantBooks = books;
            } else { // 'overall'
                relevantMeditations = meditationSessions;
                relevantBooks = books;
            }

            if (goal.type === 'meditation_duration') {
                currentProgress = relevantMeditations.reduce((sum, s) => sum + s.durationMs, 0) / (1000 * 60);
            } else if (goal.type === 'meditation_days') {
                currentProgress = new Set(relevantMeditations.map(s => new Date(s.startTime).toDateString())).size;
            } else if (goal.type === 'books_finished') {
                currentProgress = relevantBooks.filter(b => b.status === 'Finished').length;
            }

            // Check if progress actually changed before updating
            if (goal.currentProgress !== currentProgress) {
                goal.currentProgress = currentProgress;
                changed = true;
            }

            if (goal.currentProgress >= goal.targetValue && !goal.completed) {
                goal.completed = true;
                goal.lastUpdate = new Date().toISOString(); // Mark completion date
                showToast(`Goal Completed: ${GOAL_TYPES[goal.type].label} of ${goal.targetValue} ${GOAL_TYPES[goal.type].unit} ${goal.period === 'overall' ? '' : 'per ' + goal.period}!`, 'success');
                changed = true;
            }
        });

        if (changed) {
            saveData('goals', goals);
            renderGoals();
        }
    }

    function renderGoals() {
        elements.activeGoalsList.innerHTML = '';
        elements.completedGoalsList.innerHTML = '';

        const activeGoals = goals.filter(g => !g.completed);
        const completedGoals = goals.filter(g => g.completed);

        if (activeGoals.length === 0 && completedGoals.length === 0) {
            elements.activeGoalsList.innerHTML = '<li class="info-message">No goals set yet. Set a goal to start tracking your progress!</li>';
            return;
        }

        activeGoals.forEach(goal => {
            const li = document.createElement('li');
            li.className = 'goal-item';
            const progress = Math.min(100, (goal.currentProgress / goal.targetValue) * 100).toFixed(1);
            li.innerHTML = `
                <div>
                    <strong>${GOAL_TYPES[goal.type].label}: ${goal.currentProgress.toFixed(1)} / ${goal.targetValue} ${GOAL_TYPES[goal.type].unit} ${goal.period === 'overall' ? '' : 'per ' + goal.period}</strong>
                    <div class="goal-progress-bar-container" role="progressbar" aria-valuenow="${progress}" aria-valuemin="0" aria-valuemax="100">
                        <div class="goal-progress-bar" style="width: ${progress}%"></div>
                    </div>
                    <span>Progress: ${progress}%</span>
                </div>
                <button class="delete-goal-btn delete-button btn-sm" data-id="${goal.id}" title="Delete Goal" aria-label="Delete goal: ${GOAL_TYPES[goal.type].label} ${goal.targetValue} ${GOAL_TYPES[goal.type].unit}"></button>
            `;
            elements.activeGoalsList.appendChild(li);
        });

        completedGoals.forEach(goal => {
            const li = document.createElement('li');
            li.className = 'goal-item completed';
            li.innerHTML = `
                <div>
                    <strong>${GOAL_TYPES[goal.type].label}: ${goal.targetValue} ${GOAL_TYPES[goal.type].unit} ${goal.period === 'overall' ? '' : 'per ' + goal.period}</strong>
                    <div class="goal-progress-bar-container" role="progressbar" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100">
                        <div class="goal-progress-bar" style="width: 100%"></div>
                    </div>
                    <span>Completed on: ${new Date(goal.lastUpdate).toLocaleDateString()}</span>
                </div>
                <button class="delete-goal-btn delete-button btn-sm" data-id="${goal.id}" title="Delete Goal" aria-label="Delete completed goal: ${GOAL_TYPES[goal.type].label} ${goal.targetValue} ${GOAL_TYPES[goal.type].unit}"></button>
            `;
            elements.completedGoalsList.appendChild(li);
        });

        document.querySelectorAll('.delete-goal-btn').forEach(btn => {
            btn.onclick = (e) => deleteGoal(e.currentTarget.dataset.id);
        });
    }


    // --- Achievements Logic ---

    function updateAchievements() {
        let changed = false;
        achievementsList.forEach(achievement => {
            if (!achievement.unlocked && achievement.check()) { // Call the check function
                achievement.unlocked = true;
                changed = true;
                showToast(`Achievement Unlocked: ${achievement.name}!`, 'success');
            }
        });
        if (changed) {
            // Save only id and unlocked status
            saveData('achievementsListStatus', achievementsList.map(a => ({ id: a.id, unlocked: a.unlocked })));
            renderAchievements();
        }
    }

    function renderAchievements() {
        elements.achievementsGrid.innerHTML = '';
        achievementsList.forEach(achievement => {
            const card = document.createElement('div');
            card.className = `achievement-card ${achievement.unlocked ? 'unlocked' : ''}`;
            card.setAttribute('aria-label', achievement.unlocked ? `Achievement unlocked: ${achievement.name}. ${achievement.description}` : `Achievement locked: ${achievement.name}. ${achievement.description}`);
            card.innerHTML = `
                <i class="${achievement.icon}" aria-hidden="true"></i>
                <h4>${achievement.name}</h4>
                <p>${achievement.description}</p>
            `;
            elements.achievementsGrid.appendChild(card);
        });
    }

    // --- Settings Logic ---

    function applySettings() {
        document.body.className = `${settings.theme}-theme`; // Set theme class
        elements.themeSelector.value = settings.theme;
        elements.dailyReminderTimeInput.value = settings.dailyReminderTime;

        if (settings.customBackground) {
            document.body.style.backgroundImage = `url(${settings.customBackground})`;
            document.body.style.backgroundSize = 'cover';
            document.body.style.backgroundAttachment = 'fixed';
            document.body.style.backgroundPosition = 'center center';
        } else {
            document.body.style.backgroundImage = '';
        }
        // Re-render charts to pick up new theme colors
        if (document.getElementById('statistics-section').classList.contains('active-section')) {
             renderMeditationCharts();
             updateBookStatistics();
        }
    }

    function saveSettings() {
        settings.theme = elements.themeSelector.value;
        settings.dailyReminderTime = elements.dailyReminderTimeInput.value;

        saveData('settings', settings);
        applySettings();
        showToast('Settings saved!', 'info');
    }

    let reminderTimeoutId = null; // Use timeout for initial, then interval for repeats
    let reminderIntervalId = null;

    function setDailyReminder() {
        // Clear any existing reminders first
        clearDailyReminder();

        if (!settings.dailyReminderTime) {
            showToast('Please select a time for the reminder.', 'error');
            return;
        }

        if (!('Notification' in window)) {
            showToast('This browser does not support desktop notifications.', 'error');
            return;
        }

        if (Notification.permission === 'default') {
            Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                    scheduleReminder();
                } else {
                    showToast('Notification permission denied. Cannot set reminder.', 'warning');
                }
            });
        } else if (Notification.permission === 'granted') {
            scheduleReminder();
        } else { // Permission denied or blocked
            showToast('Notification permission blocked. Please enable it in browser settings.', 'warning');
        }
    }

    function scheduleReminder() {
        const [hour, minute] = settings.dailyReminderTime.split(':').map(Number);

        const now = new Date();
        let nextReminder = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hour, minute, 0, 0);

        if (nextReminder.getTime() <= now.getTime()) {
            nextReminder.setDate(nextReminder.getDate() + 1); // Schedule for tomorrow
        }

        const timeUntilNextReminder = nextReminder.getTime() - now.getTime();

        reminderTimeoutId = setTimeout(() => {
            new Notification('Yogify Reminder', {
                body: 'Time for your daily meditation!',
                icon: './img/icon.png' // Ensure this path is correct
            });

            // Set interval for subsequent daily reminders (every 24 hours)
            reminderIntervalId = setInterval(() => {
                new Notification('Yogify Reminder', {
                    body: 'Time for your daily meditation!',
                    icon: './img/icon.png'
                });
            }, 24 * 60 * 60 * 1000); // 24 hours
        }, timeUntilNextReminder);

        showToast(`Daily meditation reminder set for ${settings.dailyReminderTime}.`, 'success');
        settings.dailyReminderTime = elements.dailyReminderTimeInput.value; // Save selected time
        saveData('settings', settings);
    }


    function clearDailyReminder() {
        if (reminderTimeoutId) {
            clearTimeout(reminderTimeoutId);
            reminderTimeoutId = null;
        }
        if (reminderIntervalId) {
            clearInterval(reminderIntervalId);
            reminderIntervalId = null;
        }
        settings.dailyReminderTime = '';
        saveData('settings', settings);
        elements.dailyReminderTimeInput.value = '';
        showToast('Daily reminder cleared.', 'info');
    }

    function exportData() {
        const data = {
            meditationSessions: meditationSessions,
            books: books,
            goals: goals,
            settings: settings,
            customCountdownState: customCountdownState, // Include countdown state
            achievementsListStatus: achievementsList.map(a => ({ id: a.id, unlocked: a.unlocked }))
        };
        const filename = `yogify_data_${new Date().toISOString().slice(0, 10)}.json`;
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast('Data exported successfully!', 'success');
    }

    function importData(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const importedData = JSON.parse(e.target.result);
                showConfirmationModal('Are you sure you want to import data? This will OVERWRITE your current data!', () => {
                    if (importedData.meditationSessions) meditationSessions = importedData.meditationSessions;
                    if (importedData.books) books = importedData.books;
                    if (importedData.goals) goals = importedData.goals;
                    if (importedData.settings) settings = importedData.settings;
                    if (importedData.customCountdownState) customCountdownState = importedData.customCountdownState; // Import countdown state
                    if (importedData.achievementsListStatus) { // Check for the new key
                        achievementsList = loadAchievementsWithChecks(baseAchievements, importedData.achievementsListStatus);
                    }

                    saveData('meditationSessions', meditationSessions);
                    saveData('books', books);
                    saveData('goals', goals);
                    saveData('settings', settings);
                    saveData('customCountdownState', customCountdownState); // Save imported countdown state
                    saveData('achievementsListStatus', achievementsList.map(a => ({ id: a.id, unlocked: a.unlocked })));

                    initializeApp();
                    showToast('Data imported successfully! The page will refresh.', 'success');
                    closeModal(elements.confirmationModal);
                    // A full page reload might be necessary for all changes to take effect due to global state
                    setTimeout(() => window.location.reload(), 1000); 
                });
            } catch (error) {
                showToast('Error importing data: Invalid JSON file. ' + error.message, 'error');
                console.error('Import error:', error);
            } finally {
                event.target.value = ''; // Clear the file input
            }
        };
        reader.readAsText(file);
    }

    function clearAllData() {
        showConfirmationModal('Are you absolutely sure you want to clear ALL your data? This action cannot be undone!', () => {
            localStorage.clear();
            meditationSessions = [];
            books = [];
            goals = [];
            settings = { theme: 'yogify-serene', dailyReminderTime: '', customBackground: null };
            customCountdownState = { remainingMs: 0, initialSetMs: 0, paused: false, endTime: 0, label: '', notify: false }; // Reset countdown state
            achievementsList = loadAchievementsWithChecks(baseAchievements, []); // Reset achievements to default unlocked=false
            initializeApp();
            showToast('All data cleared! The page will refresh.', 'success');
            closeModal(elements.confirmationModal);
            setTimeout(() => window.location.reload(), 1000); // Full page reload for complete reset
        });
    }

    function showConfirmationModal(message, onConfirm) {
        elements.confirmationMessage.textContent = message;
        elements.confirmActionBtn.onclick = onConfirm;
        elements.cancelActionBtn.onclick = () => closeModal(elements.confirmationModal);
        openModal(elements.confirmationModal);
    }

    // --- UI Navigation ---
    function showSection(sectionId) {
        elements.appSections.forEach(section => {
            section.classList.remove('active-section');
        });
        document.getElementById(sectionId).classList.add('active-section');

        elements.navButtons.forEach(button => {
            if (button.dataset.section === sectionId) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
        });

        // Re-render relevant sections if they were just opened
        if (sectionId === 'dashboard-section') {
            updateDashboard();
        } else if (sectionId === 'meditation-section') {
            renderMeditationSessions();
            loadCustomCountdownState(); // Ensure countdown state is loaded/resumed when section is visible
        } else if (sectionId === 'books-section') {
            renderBooks();
            elements.bookSearchInput.value = ''; // Clear search on section change
        } else if (sectionId === 'statistics-section') {
            renderMeditationCharts();
            updateBookStatistics(); // Updates book chart
            renderMeditationCalendar();
        } else if (sectionId === 'goals-section') {
            renderGoals();
        } else if (sectionId === 'achievements-section') {
            renderAchievements();
        }
    }

    function updateDashboard() {
        updateMeditationStats(); // Populates meditation stats and streaks on dashboard
        elements.dashBooksFinished.textContent = books.filter(b => b.status === 'Finished').length;
        renderMeditationSessions(); // Populates recent meditations on dashboard
        renderBooks(); // Populates currently reading on dashboard
    }

    // --- Event Listeners ---
    elements.startMeditationBtn.addEventListener('click', () => {
        const customMinutes = parseInt(elements.customMeditationMinutesInput.value, 10);
        if (!isNaN(customMinutes) && customMinutes > 0) {
            startMeditationTimer(customMinutes, 'standard');
        } else {
            // If no custom minutes are set or it's 0, treat as freestyle
            startMeditationTimer(0, 'freestyle');
        }
    });

    elements.setCustomMeditationBtn.addEventListener('click', () => {
        const customMinutes = parseInt(elements.customMeditationMinutesInput.value, 10);
        if (isNaN(customMinutes) || customMinutes <= 0) {
            showToast('Please enter a valid custom duration in minutes (e.g., 15).', 'error');
            return;
        }
        showToast(`Custom meditation set for ${customMinutes} minutes. Click Start when ready!`, 'info');
    });

    elements.pauseMeditationBtn.addEventListener('click', pauseMeditationTimer);
    elements.stopMeditationBtn.addEventListener('click', stopMeditationTimer);
    elements.resetMeditationBtn.addEventListener('click', resetMeditationDisplay);

    elements.presetMeditationButtons.forEach(button => {
        button.addEventListener('click', (e) => {
            const minutes = parseInt(e.target.dataset.minutes, 10);
            elements.customMeditationMinutesInput.value = minutes; // Set custom input field
            showToast(`Meditation preset set for ${minutes} minutes. Click Start when ready!`, 'info');
            updateAllTimerButtonStates(); // Update states for visual feedback
        });
    });

    elements.openIntervalTimerBtn.addEventListener('click', () => {
        if (activeRecordingSessionType) {
            showToast('Another meditation timer is already active!', 'warning');
            return;
        }
        elements.intervalStepsContainer.innerHTML = ''; // Clear existing steps
        addIntervalStep(); // Add first default step
        openModal(elements.intervalTimerModal);
    });
    elements.addIntervalStepBtn.addEventListener('click', addIntervalStep);
    elements.startIntervalMeditationBtn.addEventListener('click', () => {
        const steps = getIntervalStepsFromUI();
        if (steps.length > 0) {
            intervalTimerSteps = steps;
            resetMeditationDisplay(); // Resets main meditation timer, also clears activeRecordingSessionType
            // After reset, we can start interval timer
            startMeditationTimer(0, 'interval'); // Duration 0 as it's interval controlled
            closeModal(elements.intervalTimerModal);
        } else {
            showToast('Please add at least one interval step.', 'warning');
        }
    });

    elements.journalMoodEmojis.forEach(emoji => {
        emoji.addEventListener('click', () => {
            elements.journalMoodEmojis.forEach(e => {
                e.classList.remove('selected');
                e.setAttribute('aria-checked', 'false');
            });
            emoji.classList.add('selected');
            emoji.setAttribute('aria-checked', 'true');
        });
        // Add keyboard navigation for mood emojis
        emoji.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                elements.journalMoodEmojis.forEach(el => {
                    el.classList.remove('selected');
                    el.setAttribute('aria-checked', 'false');
                });
                emoji.classList.add('selected');
                emoji.setAttribute('aria-checked', 'true');
            }
        });
    });
    elements.journalEnergyLevel.addEventListener('input', (e) => {
        elements.journalEnergyValue.textContent = e.target.value;
    });

    // Custom Countdown Meditation Event Listeners
    elements.startCountdownBtn.addEventListener('click', startCustomCountdown);
    elements.pauseCountdownBtn.addEventListener('click', pauseCustomCountdown);
    elements.stopCountdownBtn.addEventListener('click', () => stopCustomCountdown(false));
    elements.resetCountdownBtn.addEventListener('click', resetCustomCountdown);
    
    elements.countdownLabelInput.addEventListener('input', saveCustomCountdownState);
    elements.countdownNotificationToggle.addEventListener('change', () => {
        if (elements.countdownNotificationToggle.checked && Notification.permission === 'default') {
            Notification.requestPermission(); // Request permission when user enables toggle
        }
        saveCustomCountdownState();
    });
    
    // Input validation for countdown inputs
    [elements.countdownHoursInput, elements.countdownMinutesInput, elements.countdownSecondsInput].forEach(input => {
        input.addEventListener('input', (e) => {
            let value = parseInt(e.target.value, 10);
            const min = parseInt(e.target.min, 10);
            const max = parseInt(e.target.max, 10);

            if (isNaN(value)) {
                e.target.value = ''; // Allow empty for typing
            } else if (value < min) {
                e.target.value = min;
            } else if (value > max) {
                e.target.value = max;
            }

            // Pad with leading zero only if it's a single digit and not empty
            if (e.target.value !== '' && String(value).length === 1 && value < 10) {
                e.target.value = String(value).padStart(2, '0');
            }
            
            if (activeRecordingSessionType === null || (activeRecordingSessionType === 'custom-countdown' && customCountdownPaused)) {
                 const h = parseInt(elements.countdownHoursInput.value) || 0;
                 const m = parseInt(elements.countdownMinutesInput.value) || 0;
                 const s = parseInt(elements.countdownSecondsInput.value) || 0;
                 elements.generalCountdownDisplay.textContent = formatTime((h * 3600 + m * 60 + s) * 1000);
            }
            saveCustomCountdownState(); // Save state on input change
        });
         input.addEventListener('blur', (e) => { // Ensure 00 on blur if empty or invalid
             if (e.target.value === '' || isNaN(parseInt(e.target.value))) {
                 e.target.value = '00';
                 // Update display if timer is not running
                 if (activeRecordingSessionType === null || (activeRecordingSessionType === 'custom-countdown' && customCountdownPaused)) {
                    const h = parseInt(elements.countdownHoursInput.value) || 0;
                    const m = parseInt(elements.countdownMinutesInput.value) || 0;
                    const s = parseInt(elements.countdownSecondsInput.value) || 0;
                    elements.generalCountdownDisplay.textContent = formatTime((h * 3600 + m * 60 + s) * 1000);
                }
             }
         });
    });


    elements.addBookBtn.addEventListener('click', addBook);
    elements.uploadBookCoverBtn.addEventListener('click', () => elements.newBookCoverInput.click());
    elements.newBookCoverInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            if (file.size > 500 * 1024) { // 500 KB limit for book covers
                showToast('Book cover image size too large! Max 500KB.', 'error');
                e.target.value = ''; // Clear the input
                newBookCoverBase64 = null;
                elements.uploadBookCoverBtn.innerHTML = '<i class="fas fa-image"></i> Upload Cover Image'; // Reset button text
                return;
            }
            const reader = new FileReader();
            reader.onloadend = () => {
                newBookCoverBase64 = reader.result;
                elements.uploadBookCoverBtn.innerHTML = '<i class="fas fa-check"></i> Cover Ready';
                showToast('Book cover selected!', 'info');
            };
            reader.readAsDataURL(file);
        }
    });

    // Event delegation for book actions (start, stop, details, delete)
    elements.booksList.addEventListener('click', (e) => {
        const bookItem = e.target.closest('.book-item');
        if (!bookItem) return;
        const bookId = bookItem.dataset.id;

        if (e.target.classList.contains('start-reading') || e.target.closest('.start-reading')) {
            startBookReading(bookId);
        } else if (e.target.classList.contains('stop-reading') || e.target.closest('.stop-reading')) {
            stopBookReading(bookId);
        } else if (e.target.classList.contains('view-book-details') || e.target.closest('.view-book-details')) {
            openBookDetailsModal(bookId);
        } else if (e.target.classList.contains('delete-book') || e.target.closest('.delete-book')) {
            deleteBook(bookId);
        }
    });


    elements.bookSearchInput.addEventListener('input', (e) => renderBooks(e.target.value));
    elements.clearBookSearchBtn.addEventListener('click', () => {
        elements.bookSearchInput.value = '';
        renderBooks();
    });

    elements.addGoalBtn.addEventListener('click', addGoal);

    elements.navButtons.forEach(button => {
        button.addEventListener('click', () => {
            showSection(button.dataset.section);
        });
    });

    elements.closeButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
            closeModal(document.getElementById(e.currentTarget.dataset.modal));
        });
    });

    window.addEventListener('click', (event) => {
        if (event.target === elements.meditationJournalModal) closeModal(elements.meditationJournalModal);
        if (event.target === elements.bookDetailsModal) closeModal(elements.bookDetailsModal);
        if (event.target === elements.intervalTimerModal) closeModal(elements.intervalTimerModal);
        if (event.target === elements.confirmationModal) closeModal(elements.confirmationModal);
    });

    // Settings listeners
    elements.themeSelector.addEventListener('change', saveSettings);
    elements.setDailyReminderBtn.addEventListener('click', setDailyReminder);
    elements.clearDailyReminderBtn.addEventListener('click', clearDailyReminder);

    elements.uploadCustomBackgroundBtn.addEventListener('click', () => elements.customBackgroundFileInput.click());
    elements.customBackgroundFileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
            if (file.size > 1024 * 1024) { // 1 MB limit for background
                showToast('Background image size too large! Max 1MB.', 'error');
                e.target.value = '';
                return;
            }
            const reader = new FileReader();
            reader.onloadend = () => {
                settings.customBackground = reader.result;
                saveSettings();
                showToast('Custom background applied!', 'success');
            };
            reader.readAsDataURL(file);
        }
    });
    elements.clearCustomBackgroundBtn.addEventListener('click', () => {
        settings.customBackground = null;
        saveSettings();
        showToast('Custom background cleared.', 'info');
    });

    elements.exportDataBtn.addEventListener('click', exportData);
    elements.importDataBtn.addEventListener('click', () => elements.importDataFile.click());
    elements.importDataFile.addEventListener('change', importData);
    elements.clearAllDataBtn.addEventListener('click', clearAllData);


    // --- Initialization ---
    async function initializeApp() {
        applySettings(); // This will apply the theme
        updateAllTimerButtonStates(); // Set initial button states for both timers
        renderMeditationSessions();
        updateMeditationStats();
        renderBooks();
        updateBookStatistics(); // Call to initialize book charts
        renderGoals();
        updateGoals(); // Initial goal check
        updateAchievements(); // Achievements should be updated *after* other data
        renderAchievements();

        if (settings.dailyReminderTime) {
            setDailyReminder(); // Re-schedule reminder on load
        }
        
        // Load custom countdown state only if the meditation section is active initially
        if (document.getElementById('meditation-section').classList.contains('active-section')) {
            loadCustomCountdownState();
        } else {
            // If not active, ensure inputs are populated but timer is not auto-started
            const h = Math.floor(customCountdownState.initialSetMs / (1000 * 60 * 60));
            const m = Math.floor((customCountdownState.initialSetMs % (1000 * 60 * 60)) / (1000 * 60));
            const s = Math.floor((customCountdownState.initialSetMs % (1000 * 60)) / 1000);
            elements.countdownHoursInput.value = String(h).padStart(2, '0');
            elements.countdownMinutesInput.value = String(m).padStart(2, '0');
            elements.countdownSecondsInput.value = String(s).padStart(2, '0');
            elements.generalCountdownDisplay.textContent = formatTime(customCountdownState.initialSetMs || 0);
            elements.countdownLabelInput.value = customCountdownState.label;
            elements.countdownNotificationToggle.checked = customCountdownState.notify;
            activeRecordingSessionType = null; // Ensure no timer is marked as active if starting on non-meditation section
            updateAllTimerButtonStates(); // Apply correct button states based on no active timer
        }

        showSection('dashboard-section'); // Show dashboard by default

        document.getElementById('current-year').textContent = new Date().getFullYear();
    }

    initializeApp();
});

--- END FILE: script.js ---

--- START FILE: style.css ---

/* --- Global & Root Variables (Defaulting to Yogify Serene Theme) --- */
:root {
    /* Yogify Serene (Default/Light) */
    --primary-color: #3b82f6; /* Serene Blue */
    --secondary-color: #22c55e; /* Vibrant Green */
    --accent-color: #f59e0b; /* Warm Orange */
    --background-gradient-start: #f0fdf4; /* Very Light Green-Blue */
    --background-gradient-end: #dcfce7; /* Light Green */
    --text-color: #1a202c; /* Dark text for readability */
    --inverted-text-color: #ffffff; /* White for dark backgrounds */
    --card-background: #ffffff;
    --border-color: #e2e8f0; /* Soft border grey */
    --shadow-light: rgba(0, 0, 0, 0.05);
    --shadow-medium: rgba(0, 0, 0, 0.1);
    --input-bg: #f8fafc; /* Off-white for inputs */
    --meditation-timer-bg: #e0f2f7; /* Light aqua for timer */
    --stats-grid-bg: #f8fafc;
    --list-item-bg: #f8fafc;
    --modal-content-bg: #ffffff;
    --progress-bar-bg: #e2e8f0;
    --progress-bar-fill: var(--secondary-color);
    --secondary-color-alpha: rgba(34, 197, 94, 0.2); /* Alpha version of secondary for shadows */
    --button-hover-darken: #2563eb; /* Specific darken for primary button */

    /* General fixed colors (not theme-dependent) */
    --delete-color: #ef4444; /* Red */
    --delete-hover: #dc2626;
    --success-color: #22c55e; /* Green */
    --success-hover: #16a34a;
    --info-color: #3b82f6; /* Blue */
    --info-hover: #2563eb;
    --warning-color: #f59e0b; /* Orange */
    --warning-hover: #d97706;
    --warning-color-rgb: 245, 158, 11; /* For rgba shadows */

    /* Modal general styles */
    --modal-bg: rgba(0, 0, 0, 0.65);
    /* Toast notifications */
    --toast-bg: rgba(26, 32, 44, 0.9);
    --toast-text: #fff;
}

/* --- Theme Overrides --- */

/* Yogify Serene (Default/Light) - Explicitly set for clarity */
body.yogify-serene-theme {
    --primary-color: #3b82f6;
    --secondary-color: #22c55e;
    --accent-color: #f59e0b;
    --background-gradient-start: #f0fdf4;
    --background-gradient-end: #dcfce7;
    --text-color: #1a202c;
    --inverted-text-color: #ffffff;
    --card-background: #ffffff;
    --border-color: #e2e8f0;
    --shadow-light: rgba(0, 0, 0, 0.05);
    --shadow-medium: rgba(0, 0, 0, 0.1);
    --input-bg: #f8fafc;
    --meditation-timer-bg: #e0f2f7;
    --stats-grid-bg: #f8fafc;
    --list-item-bg: #f8fafc;
    --modal-content-bg: #ffffff;
    --progress-bar-bg: #e2e8f0;
    --progress-bar-fill: var(--secondary-color);
    --secondary-color-alpha: rgba(34, 197, 94, 0.2);
    --button-hover-darken: #2563eb;
}

/* Yogify Nightfall (Dark Theme) */
body.yogify-nightfall-theme {
    --primary-color: #818cf8; /* Lighter Indigo */
    --secondary-color: #a78bfa; /* Light Violet */
    --accent-color: #fcd34d; /* Golden Yellow */
    --background-gradient-start: #1e1b4b; /* Deep Navy */
    --background-gradient-end: #312e81; /* Dark Purple-Blue */
    --text-color: #e0e7ff; /* Light Lavender */
    --inverted-text-color: #ffffff;
    --card-background: #3f3f46; /* Dark Grey */
    --border-color: #4f46e5; /* Indigo Border */
    --shadow-light: rgba(255, 255, 255, 0.04);
    --shadow-medium: rgba(255, 255, 255, 0.08);
    --input-bg: #2d2a58; /* Darker input */
    --meditation-timer-bg: #3730a3; /* Medium Blue-Purple */
    --stats-grid-bg: #3f3f46;
    --list-item-bg: #3f3f46;
    --modal-content-bg: #3f3f46;
    --progress-bar-bg: #4f46e5;
    --progress-bar-fill: var(--secondary-color);
    --secondary-color-alpha: rgba(167, 139, 250, 0.2);
    --button-hover-darken: #6366f1; /* Darken primary for hover */
    --toast-bg: rgba(30, 27, 75, 0.9);
}

/* Yogify Stellar (Cosmic Theme) */
body.yogify-stellar-theme {
    --primary-color: #c084fc; /* Bright Purple */
    --secondary-color: #a855f7; /* Medium Purple */
    --accent-color: #fbbf24; /* Amber */
    --background-gradient-start: #0f172a; /* Dark Blue-Grey */
    --background-gradient-end: #1e293b; /* Slightly Lighter Dark Blue-Grey */
    --text-color: #e2e8f0; /* Off-white Blue-Grey */
    --inverted-text-color: #ffffff;
    --card-background: #1f2937; /* Dark Grey-Blue */
    --border-color: #475569; /* Slate Grey */
    --shadow-light: rgba(255, 255, 255, 0.03);
    --shadow-medium: rgba(255, 255, 255, 0.06);
    --input-bg: #334155; /* Medium Grey-Blue */
    --meditation-timer-bg: #293241; /* Darker Grey-Blue */
    --stats-grid-bg: #1f2937;
    --list-item-bg: #1f2937;
    --modal-content-bg: #1f2937;
    --progress-bar-bg: #475569;
    --progress-bar-fill: var(--secondary-color);
    --secondary-color-alpha: rgba(168, 85, 247, 0.2);
    --button-hover-darken: #a78bfa; /* Darken primary for hover */
    --toast-bg: rgba(15, 23, 42, 0.9);
}

/* Yogify Verdant (Forest Theme) */
body.yogify-verdant-theme {
    --primary-color: #166534; /* Dark Forest Green */
    --secondary-color: #22c55e; /* Vibrant Green */
    --accent-color: #facc15; /* Yellow */
    --background-gradient-start: #f0fdf4; /* Lightest Green */
    --background-gradient-end: #dcfce7; /* Light Green */
    --text-color: #115e59; /* Dark Teal */
    --inverted-text-color: #ffffff;
    --card-background: #ffffff;
    --border-color: #a7f3d0; /* Light Teal Green */
    --shadow-light: rgba(0, 0, 0, 0.04);
    --shadow-medium: rgba(0, 0, 0, 0.08);
    --input-bg: #ecfdf5; /* Very Light Teal */
    --meditation-timer-bg: #d1fae5; /* Pale Green */
    --stats-grid-bg: #ecfdf5;
    --list-item-bg: #ecfdf5;
    --modal-content-bg: #ffffff;
    --progress-bar-bg: #a7f3d0;
    --progress-bar-fill: var(--secondary-color);
    --secondary-color-alpha: rgba(34, 197, 94, 0.2);
    --button-hover-darken: #0f4a27; /* Darken primary for hover */
    --toast-bg: rgba(17, 94, 89, 0.9);
}

/* --- Global Styles --- */
html {
    scroll-behavior: smooth;
}

body {
    font-family: 'Inter', 'Segoe UI', 'Roboto', sans-serif; /* Modern, readable font */
    margin: 0;
    padding: 0;
    background: linear-gradient(135deg, var(--background-gradient-start), var(--background-gradient-end));
    color: var(--text-color);
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    box-sizing: border-box;
    transition: background-color 0.5s ease, color 0.5s ease, background-image 0.5s ease;
    overflow-y: scroll;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}

/* Custom Scrollbar */
body::-webkit-scrollbar {
    width: 12px;
}

body::-webkit-scrollbar-track {
    background: var(--background-gradient-start);
}

body::-webkit-scrollbar-thumb {
    background-color: var(--secondary-color);
    border-radius: 6px;
    border: 3px solid var(--background-gradient-start);
}

body.modal-open {
    overflow: hidden; /* Prevent scrolling when modal is open */
}

.container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 0 1.5em;
}

header {
    background: linear-gradient(45deg, var(--primary-color), var(--info-color)); /* Consistent blue gradient */
    color: var(--inverted-text-color);
    padding: 2.5em 0 1.5em;
    text-align: center;
    box-shadow: 0 6px 15px var(--shadow-medium);
    border-bottom-left-radius: 25px; /* Softer radius */
    border-bottom-right-radius: 25px;
}

header h1 {
    margin: 0;
    font-size: clamp(2.5em, 5vw, 3.8em);
    letter-spacing: 1px;
    font-weight: 700;
    text-shadow: 1px 1px 4px rgba(0,0,0,0.2); /* Softer shadow */
}

header p {
    margin: 0.5em 0 0;
    font-size: clamp(1em, 2.5vw, 1.4em);
    opacity: 0.95;
    font-weight: 400; /* Slightly bolder */
}

/* --- Navigation --- */
.main-nav {
    background-color: var(--card-background);
    padding: 0.8em 0; /* Slightly reduced padding */
    box-shadow: 0 3px 8px var(--shadow-light);
    margin-bottom: 2.5em;
    position: sticky;
    top: 0;
    z-index: 100;
    border-bottom: 1px solid var(--border-color);
    border-top: 1px solid var(--border-color);
    display: flex;
    overflow-x: auto; /* Allow horizontal scrolling by default for smallest screens */
    -webkit-overflow-scrolling: touch;
}

.main-nav::-webkit-scrollbar {
    height: 6px;
}
.main-nav::-webkit-scrollbar-track {
    background: var(--card-background);
}
.main-nav::-webkit-scrollbar-thumb {
    background-color: var(--border-color);
    border-radius: 3px;
}

.main-nav .container {
    display: flex;
    justify-content: flex-start; /* Align to start for scroll on small screens */
    gap: 1em; /* Reduced gap */
    flex-wrap: nowrap; /* Prevent wrapping initially */
    padding: 0 1.5em;
    min-width: max-content; /* Ensure container is wide enough for all buttons */
}

/* Tablet and larger mobile landscape - allow wrap if enough space */
@media (min-width: 600px) {
    .main-nav .container {
        flex-wrap: wrap; /* Allow wrapping on larger mobile screens */
        justify-content: center; /* Center buttons when wrapped */
        overflow-x: visible; /* Disable horizontal scroll if wrapped */
    }
}


.nav-button {
    background-color: transparent;
    border: 1px solid var(--border-color); /* Visible border for distinction */
    color: var(--primary-color);
    padding: 0.8em 1.5em; /* Slightly reduced padding */
    font-size: clamp(0.9em, 2vw, 1.05em); /* Responsive font size */
    cursor: pointer;
    border-radius: 25px; /* More rounded */
    transition: background-color 0.3s ease, color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease, border-color 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
    white-space: nowrap;
    font-weight: 600;
    flex-shrink: 0;
}

.nav-button i {
    font-size: 1.1em;
}

.nav-button:hover:not(:disabled) {
    background-color: var(--background-gradient-end);
    transform: translateY(-2px); /* Softer lift */
    box-shadow: 0 4px 10px var(--shadow-light);
    border-color: var(--secondary-color);
}

.nav-button.active {
    background-color: var(--secondary-color);
    color: var(--inverted-text-color);
    box-shadow: 0 4px 12px var(--shadow-medium);
    transform: translateY(-1px);
    border-color: var(--secondary-color);
}

.nav-button.active:hover {
    background-color: var(--success-hover); /* Darker green on active hover */
    transform: none;
    box-shadow: 0 2px 8px var(--shadow-light);
}

/* --- Main Content Layout --- */
main {
    flex-grow: 1;
    padding-bottom: 3em;
}

.app-section {
    display: none;
    opacity: 0;
    transform: translateY(20px); /* Smaller transform for smoother feel */
    transition: opacity 0.5s ease, transform 0.5s ease;
}

.app-section.active-section {
    display: grid;
    /* Adjusted minmax for better two-column fit before collapsing */
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); 
    gap: 2em; /* Reduced gap */
    opacity: 1;
    transform: translateY(0);
}

/* Collapse to single column on screens smaller than ~600px */
@media (max-width: 600px) {
    .app-section.active-section {
        grid-template-columns: 1fr;
        gap: 1.5em; /* Further reduced gap */
    }
}


/* Card Styles */
.card {
    background-color: var(--card-background);
    border-radius: 20px; /* More rounded corners */
    box-shadow: 0 8px 20px var(--shadow-light); /* Lighter shadow */
    padding: 2.5em; /* Reduced padding */
    border: 1px solid var(--border-color);
    transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.3s ease, border-color 0.3s ease;
    display: flex;
    flex-direction: column;
}

.card:hover {
    transform: translateY(-5px); /* Softer hover lift */
    box-shadow: 0 12px 28px var(--shadow-medium); /* Slightly more pronounced on hover */
}

.card-full-width {
    grid-column: 1 / -1;
}

h2 {
    color: var(--primary-color);
    margin-top: 0;
    /* Adjusted clamp for better scaling on smaller screens */
    font-size: clamp(1.4em, 5vw, 2.2em); 
    border-bottom: 2px solid var(--border-color);
    padding-bottom: 0.8em;
    margin-bottom: 1.5em;
    display: flex;
    align-items: center;
    font-weight: 700;
}

h2 i {
    margin-right: 12px; /* Reduced margin */
    color: var(--accent-color);
    font-size: 1.1em; /* Slightly smaller icon */
}

h3 {
    color: var(--info-color); /* Using info-color for subheadings */
    margin-top: 2em;
    margin-bottom: 1.2em; /* Reduced margin */
    font-size: clamp(1.4em, 3vw, 1.8em);
    border-bottom: 1px dashed var(--border-color);
    padding-bottom: 0.6em;
    font-weight: 600;
}

.card-description {
    font-size: 1em; /* Slightly smaller font */
    color: var(--text-color);
    opacity: 0.85;
    margin-bottom: 1.5em;
    line-height: 1.5;
}

/* --- Buttons --- */
button {
    background-color: var(--primary-color); /* Primary color for general buttons */
    color: var(--inverted-text-color);
    border: none;
    padding: 0.9em 1.8em; /* Slightly reduced padding */
    border-radius: 25px; /* More rounded */
    font-size: 1em;
    cursor: pointer;
    transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease, opacity 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px; /* Reduced gap */
    white-space: nowrap;
    font-weight: 500;
    box-shadow: 0 3px 10px var(--shadow-light);
}

button:hover:not(:disabled) {
    background-color: var(--button-hover-darken); /* Use specific darken */
    transform: translateY(-2px);
    box-shadow: 0 5px 12px var(--shadow-medium);
}

button:active:not(:disabled) {
    transform: translateY(0);
    box-shadow: inset 0 2px 5px rgba(0,0,0,0.2);
}

button:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
    opacity: 0.6;
    box-shadow: none;
    transform: none;
}

.btn-sm {
    padding: 0.6em 1.2em;
    font-size: 0.9em;
    border-radius: 20px;
}

.btn-icon {
    padding: 0.6em 0.9em; /* Reduced padding */
    font-size: 1em;
    border-radius: 50%;
    min-width: 40px;
    min-height: 40px;
    box-shadow: 0 2px 8px var(--shadow-light);
    background-color: var(--secondary-color); /* Consistent with accent */
}
.btn-icon:hover {
    background-color: var(--success-hover);
}

.btn-icon i {
    margin: 0;
}
.btn-success { background-color: var(--secondary-color); } /* Use secondary for success */
.btn-success:hover:not(:disabled) { background-color: var(--success-hover); }

.delete-button { background-color: var(--delete-color); }
.delete-button:hover:not(:disabled) { background-color: var(--delete-hover); }

.export-button { background-color: var(--secondary-color); } /* Consistent with success */
.export-button:hover:not(:disabled) { background-color: var(--success-hover); }

.import-button { background-color: var(--info-color); }
.import-button:hover:not(:disabled) { background-color: var(--info-hover); }

.secondary-button { background-color: #64748b; } /* Slate grey */
.secondary-button:hover:not(:disabled) { background-color: #475569; }

/* --- Forms & Inputs --- */
.input-field, select {
    flex-grow: 1;
    padding: 0.9em 1.2em; /* Slightly reduced padding */
    border: 1px solid var(--border-color);
    border-radius: 25px; /* More rounded */
    font-size: 0.95em;
    outline: none;
    transition: border-color 0.3s ease, box-shadow 0.3s ease, background-color 0.3s ease, color 0.3s ease;
    background-color: var(--input-bg);
    color: var(--text-color);
    min-width: 120px; /* Reduced min-width */
    appearance: none;
    -webkit-appearance: none;
}

select {
    background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%2364748b%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13.6-6.4H18.9c-5%200-9.6%202-13.6%206.4-4%204-6.4%209.6-6.4%2015.6%200%206%202.4%2011.6%206.4%2015.6l127.3%20127.3c4%204%209.6%206.4%2015.6%206.4s11.6-2.4%2015.6-6.4L287%20100.6c4-4%206.4-9.6%206.4-15.6-.2-6-2.5-11.6-6.4-15.6z%22%2F%3E%3C%2Fsvg%3E'); /* Updated arrow color */
    background-repeat: no-repeat;
    background-position: right 1em center; /* Centered vertically */
    background-size: 0.7em auto; /* Slightly smaller arrow */
}

.input-field:focus, select:focus {
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px var(--secondary-color-alpha); /* Use alpha for a softer glow */
}

.small-input {
    min-width: unset;
    width: 100px; /* Slightly smaller default width */
    padding: 0.7em 1em;
    border-radius: 20px;
}

.tiny-input { /* New class for smaller inputs like H:M:S */
    width: 50px; /* Fixed small width */
    padding: 0.7em 0.4em; /* Reduced padding to fit */
    text-align: center;
    -moz-appearance: textfield; /* Remove number input arrows for Firefox */
    /* Ensure vertical alignment */
    vertical-align: middle; 
}
/* Hide number input arrows for Chrome, Safari, Edge */
.tiny-input::-webkit-outer-spin-button,
.tiny-input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
}


/* --- Lists (ul, li) --- */
ul {
    list-style: none;
    padding: 0;
    margin: 1.2em 0 0; /* Reduced margin */
    flex-grow: 1;
}

ul li {
    background-color: var(--list-item-bg);
    border: 1px solid var(--border-color);
    border-radius: 15px; /* More rounded */
    margin-bottom: 1em; /* Reduced margin */
    padding: 1.2em 1.8em; /* Reduced padding */
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 2px 8px var(--shadow-light); /* Lighter shadow */
    transition: background-color 0.2s ease, transform 0.15s ease, box-shadow 0.15s ease, border-color 0.2s ease;
    flex-wrap: wrap;
    gap: 0.8em; /* Reduced gap */
}

ul li:hover {
    transform: translateY(-2px); /* Softer lift */
    box-shadow: 0 4px 12px var(--shadow-medium); /* Slightly more pronounced on hover */
}

ul li:last-child {
    margin-bottom: 0;
}

.info-message {
    text-align: center;
    font-style: italic;
    color: var(--text-color);
    opacity: 0.7;
    padding: 1em;
}

.mini-list li { /* For dashboard recent items */
    padding: 0.7em 1em; /* Reduced padding */
    font-size: 0.85em; /* Slightly smaller font */
    box-shadow: none;
    border: none;
    border-bottom: 1px dashed var(--border-color);
    border-radius: 0;
    background-color: transparent;
}
.mini-list li:hover {
    transform: none;
    background-color: var(--input-bg);
}
.mini-list li:last-child {
    border-bottom: none;
}
.mini-list li .session-date, .mini-list li .session-duration {
    font-weight: 500;
}


/* --- Meditation Specifics --- */
.meditation-timer-card {
    grid-column: span 1;
}
.meditation-history-card {
    grid-column: span 1;
}

.timer-display {
    /* Adjusted clamp for better scaling on smaller screens */
    font-size: clamp(2.5em, 10vw, 3.5em); 
    font-weight: bold;
    color: var(--primary-color);
    text-align: center;
    margin: 1.2em 0 1.8em; /* Reduced margins */
    background-color: var(--meditation-timer-bg);
    padding: 0.7em 1em; /* Reduced padding */
    border-radius: 15px;
    border: 2px solid var(--info-color); /* Info color border */
    box-shadow: inset 0 2px 8px var(--shadow-light);
    transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    letter-spacing: 1px;
}

.meditation-controls-group {
    display: flex;
    flex-direction: column;
    gap: 1.2em; /* Reduced gap */
    margin-bottom: 1.8em; /* Reduced margin */
}

.preset-buttons {
    display: flex;
    justify-content: center;
    gap: 0.8em; /* Reduced gap */
    flex-wrap: wrap;
}

.preset-meditation-time {
    background-color: var(--info-color); /* Use info color for presets */
    min-width: 70px; /* Slightly smaller min-width */
}
.preset-meditation-time:hover:not(:disabled) {
    background-color: var(--info-hover);
}

.custom-timer-input {
    display: flex;
    gap: 0.6em; /* Reduced gap */
    justify-content: center;
    align-items: center;
    flex-wrap: wrap; /* Allow wrapping of custom input and set button */
}
.custom-timer-input .input-field {
    max-width: 120px; /* Reduced max-width */
    text-align: center;
}
@media (max-width: 400px) { /* On very small screens, stack custom input and button */
    .custom-timer-input {
        flex-direction: column;
        align-items: stretch;
    }
    .custom-timer-input .input-field, .custom-timer-input button {
        width: 100%;
        max-width: none;
        text-align: left;
    }
}

.timer-controls {
    display: flex;
    justify-content: center;
    gap: 0.8em; /* Reduced gap */
    margin-bottom: 1.8em; /* Reduced margin */
    flex-wrap: wrap;
}
.timer-controls button {
    flex: 1 1 110px; /* Adjusted flex basis */
    max-width: 160px; /* Reduced max-width */
}
.timer-controls #start-meditation { background-color: var(--secondary-color); } /* Consistent success color */
.timer-controls #start-meditation:hover:not(:disabled) { background-color: var(--success-hover); }


.session-mood-emoji {
    font-size: 1.1em; /* Slightly smaller emoji */
    margin-left: 0.4em; /* Reduced margin */
}

/* --- Custom Countdown Meditation Card --- */
.custom-countdown-card {
    grid-column: span 1; /* Occupy single column */
    text-align: center; /* Center content within the card */
}

.custom-countdown-card h2 {
    justify-content: center; /* Center icon and text */
}
/* Reduce description margin for the countdown card */
.custom-countdown-card .card-description {
    margin-bottom: 1em;
}

.custom-countdown-card .timer-input-group {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 0.5em; /* Small gap between H:M:S */
    margin-bottom: 1.5em;
    flex-wrap: wrap; /* Allow wrapping on very small screens */
}
/* Stack H:M:S inputs vertically on very small screens */
@media (max-width: 400px) {
    .custom-countdown-card .timer-input-group {
        flex-direction: column;
        gap: 0.8em;
    }
    .custom-countdown-card .timer-input-group input {
        width: 100%;
        max-width: none;
    }
    .custom-countdown-card .timer-input-group .colon { /* Hide ":" when stacked */
        display: none;
    }
}

.custom-countdown-card .timer-input-group .colon { /* Specific for the colon separator */
    font-size: 1.5em;
    font-weight: bold;
    color: var(--primary-color);
    /* Ensure vertical alignment with inputs */
    line-height: 1; /* Match line-height to input height if possible */
    vertical-align: middle; 
}

.custom-countdown-card .countdown-display {
    /* Adjusted clamp for better scaling on smaller screens */
    font-size: clamp(2.5em, 10vw, 3.5em); 
    font-weight: bold;
    color: var(--primary-color);
    margin: 0 0 1.8em;
    background-color: var(--meditation-timer-bg);
    padding: 0.7em 1em;
    border-radius: 15px;
    border: 2px solid var(--info-color);
    box-shadow: inset 0 2px 8px var(--shadow-light);
    letter-spacing: 1px;
}

.custom-countdown-card .countdown-controls {
    display: flex;
    justify-content: center;
    gap: 0.8em;
    margin-bottom: 1.5em;
    flex-wrap: wrap;
}
.custom-countdown-card .countdown-controls button {
    flex: 1 1 110px;
    max-width: 160px;
}
/* Stack countdown controls on smaller screens */
@media (max-width: 450px) {
    .custom-countdown-card .countdown-controls {
        flex-direction: column;
        align-items: stretch;
    }
    .custom-countdown-card .countdown-controls button {
        width: 100%;
        max-width: none;
    }
}

.custom-countdown-card .countdown-options {
    display: flex;
    flex-direction: column;
    gap: 1em;
    align-items: center;
}
.custom-countdown-card .countdown-options .input-field {
    width: 100%;
    max-width: 300px; /* Limit width of label input */
}
.custom-countdown-card .countdown-options .notification-toggle {
    display: flex;
    align-items: center;
    gap: 0.8em;
}
.custom-countdown-card .countdown-options .notification-toggle span {
    font-size: 1em;
    color: var(--text-color);
}
.sr-only { /* For screen readers only */
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
}


/* Dashboard Specifics */
.stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); /* Slightly smaller min-width */
    gap: 1em; /* Reduced gap */
    background-color: var(--stats-grid-bg);
    padding: 1.5em; /* Reduced padding */
    border-radius: 12px;
    border: 1px solid var(--border-color);
    box-shadow: inset 0 1px 6px var(--shadow-light); /* Lighter inset shadow */
    transition: background-color 0.3s ease, border-color 0.3s ease;
}

/* Collapse stats grid to single column on very small screens */
@media (max-width: 450px) {
    .stats-grid {
        grid-template-columns: 1fr;
    }
    .stats-grid div:nth-child(odd) { /* Remove vertical divider when stacked */
        border-right: none;
    }
}

.stats-grid div {
    padding: 0.7em; /* Reduced padding */
    border-bottom: 1px dashed var(--border-color);
    display: flex;
    flex-direction: column;
    gap: 0.2em; /* Reduced gap */
}

.stats-grid div:nth-child(odd) {
    border-right: 1px dashed var(--border-color);
}
.stats-grid div:last-child,
.stats-grid div:nth-last-child(2):nth-child(odd) { /* Last two items in a 2-column grid or last item in any grid */
    border-bottom: none;
}
/* Ensure border-bottom is removed for last item in a single column layout */
@media (max-width: 450px) {
    .stats-grid div:last-child {
        border-bottom: none;
    }
}


.stats-grid strong {
    color: var(--primary-color);
    font-size: 1em; /* Slightly smaller font */
    font-weight: 600;
}

/* --- Book Specifics --- */
.book-input-area, .search-input-area {
    display: flex;
    gap: 0.8em; /* Reduced gap */
    margin-bottom: 1.5em; /* Reduced margin */
    flex-wrap: wrap;
    align-items: center;
}
/* Ensure all inputs and buttons stack on smaller mobile screens */
@media (max-width: 500px) {
    .book-input-area, .search-input-area {
        flex-direction: column;
        align-items: stretch; /* Stretch to full width */
    }
    .book-input-area .input-field,
    .book-input-area .small-input,
    .search-input-area .input-field {
        width: 100%;
        max-width: none;
    }
    .book-input-area #upload-book-cover-btn,
    .book-input-area #add-book,
    .search-input-area #clear-book-search {
        width: 100%;
        max-width: none;
        border-radius: 25px; /* Make them pill-shaped when full-width */
    }
}

.book-list li {
    padding: 1em 1.5em; /* Reduced padding */
    flex-direction: row; /* Default to row on larger screens */
    align-items: center;
}
/* Book list items should stack vertically on smaller mobile screens */
@media (max-width: 500px) {
    .book-list li {
        flex-direction: column;
        align-items: flex-start;
        text-align: center; /* Adjust text alignment within stacked item */
    }
    .book-cover-thumbnail {
        margin-right: 0;
        margin-bottom: 1em; /* Add space below image when stacked */
        align-self: center; /* Center the image */
    }
    .book-item-info {
        width: 100%;
        text-align: center;
        margin-bottom: 1em; /* Space before controls */
    }
    .book-item-controls {
        width: 100%;
        justify-content: center; /* Center controls */
        flex-direction: column; /* Stack buttons in controls */
        gap: 0.6em;
    }
    .book-item-controls button {
        width: 100%;
        max-width: none;
    }
}

.book-item-info {
    flex: 1 1 50%;
    display: flex;
    flex-direction: column;
    gap: 0.4em; /* Reduced gap */
}

.book-item-info span {
    font-size: 0.85em; /* Slightly smaller font */
    opacity: 0.8;
}
.book-item-info strong {
    font-size: 1.1em; /* Slightly smaller font */
    color: var(--primary-color);
}

.book-item-controls {
    display: flex;
    gap: 0.6em; /* Reduced gap */
    flex-wrap: wrap;
    justify-content: flex-end;
}

.book-item-controls button {
    padding: 0.5em 1em; /* Reduced padding */
    font-size: 0.8em; /* Reduced font size */
    border-radius: 18px; /* Slightly less rounded */
}

.book-cover-thumbnail {
    width: 50px; /* Slightly smaller thumbnail */
    height: 75px;
    object-fit: cover;
    border-radius: 6px; /* Slightly less rounded */
    box-shadow: 0 1px 4px rgba(0,0,0,0.1);
    margin-right: 0.8em; /* Reduced margin */
    flex-shrink: 0;
    border: 1px solid var(--border-color);
}

/* --- Statistics Section --- */
.chart-container {
    padding: 1.2em; /* Reduced padding */
    background-color: var(--list-item-bg);
    border-radius: 10px;
    border: 1px solid var(--border-color);
    margin-top: 1.2em; /* Reduced margin */
    margin-bottom: 1.8em; /* Reduced margin */
}

/* Meditation Calendar */
.meditation-calendar {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 4px; /* Reduced gap */
    padding: 0.8em; /* Reduced padding */
    border: 1px solid var(--border-color);
    border-radius: 10px;
    background-color: var(--list-item-bg);
}

.calendar-header {
    grid-column: 1 / -1;
    text-align: center;
    font-weight: bold;
    font-size: 1.1em; /* Slightly smaller font */
    margin-bottom: 8px; /* Reduced margin */
    color: var(--primary-color);
}

.calendar-day-name, .calendar-day {
    padding: 6px; /* Reduced padding */
    text-align: center;
    border-radius: 4px; /* Slightly less rounded */
    font-size: 0.85em; /* Slightly smaller font */
    background-color: var(--card-background);
    border: 1px solid var(--border-color);
    min-height: 32px; /* Consistent height */
    display: flex;
    align-items: center;
    justify-content: center;
}

.calendar-day-name {
    font-weight: bold;
    background-color: var(--secondary-color);
    color: var(--inverted-text-color);
    border-color: var(--secondary-color); /* Use secondary for border */
}

.calendar-day.empty {
    background-color: var(--background-gradient-start);
    border-color: transparent;
    opacity: 0.6;
}

.calendar-day.meditated {
    background-color: var(--secondary-color); /* Green for meditated days */
    color: white;
    font-weight: bold;
    border-color: var(--success-hover);
    box-shadow: inset 0 0 4px rgba(0,0,0,0.15);
}

.calendar-day.current-day {
    border: 2px solid var(--accent-color);
    box-shadow: 0 0 0 2px var(--accent-color);
    font-weight: bold;
}

/* --- Goals Section --- */
.goal-input-area {
    display: flex;
    gap: 0.8em; /* Reduced gap */
    margin-bottom: 1.5em; /* Reduced margin */
    flex-wrap: wrap;
    align-items: center;
}
/* Stack goal inputs and button on small screens */
@media (max-width: 550px) {
    .goal-input-area {
        flex-direction: column;
        align-items: stretch;
    }
    .goal-input-area .input-field,
    .goal-input-area .small-input,
    .goal-input-area button {
        width: 100%;
        max-width: none;
    }
}

.goal-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.9em 1.2em; /* Reduced padding */
    border-radius: 10px;
    background-color: var(--list-item-bg);
    border: 1px solid var(--border-color);
    margin-bottom: 0.8em; /* Reduced margin */
    flex-wrap: wrap;
    gap: 0.8em;
}
/* Goal item text should stack on very small screens */
@media (max-width: 400px) {
    .goal-item {
        flex-direction: column;
        align-items: flex-start;
        text-align: left;
    }
    .goal-item > div { /* The div containing text and progress bar */
        width: 100%;
        margin-bottom: 0.8em; /* Space before button */
    }
    .goal-item button {
        align-self: flex-end; /* Push delete button to bottom right */
    }
}


.goal-item.completed {
    opacity: 0.9; /* Slightly less opacity */
    background-color: var(--secondary-color);
    color: var(--inverted-text-color);
    border-color: var(--success-hover);
    box-shadow: 0 2px 8px var(--shadow-medium);
}
.goal-item.completed strong {
    color: var(--inverted-text-color);
}
.goal-item.completed span {
    color: rgba(255,255,255,0.85); /* Slightly brighter text */
}

.goal-progress-bar-container {
    width: 100%;
    height: 7px; /* Slightly thinner */
    background-color: var(--progress-bar-bg);
    border-radius: 4px;
    margin-top: 0.4em; /* Reduced margin */
    overflow: hidden;
}

.goal-progress-bar {
    height: 100%;
    background-color: var(--progress-bar-fill);
    width: 0%;
    border-radius: 4px;
    transition: width 0.4s ease; /* Slightly faster transition */
}
.goal-item.completed .goal-progress-bar {
    background-color: var(--inverted-text-color);
}

/* --- Achievements Section --- */
.achievements-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); /* Slightly smaller min-width */
    gap: 1.2em; /* Reduced gap */
    padding: 0.8em; /* Reduced padding */
}

/* Collapse achievements grid to single column on very small screens */
@media (max-width: 450px) {
    .achievements-grid {
        grid-template-columns: 1fr;
    }
}

.achievement-card {
    background-color: var(--list-item-bg);
    border: 1px solid var(--border-color);
    border-radius: 15px;
    padding: 1.2em; /* Reduced padding */
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-shadow: 0 3px 10px var(--shadow-light);
    transition: transform 0.15s ease, opacity 0.2s ease, background-color 0.2s ease, border-color 0.2s ease;
    min-height: 150px; /* Consistent card height */
}

.achievement-card i {
    font-size: 2.8em; /* Slightly smaller icon */
    color: #94a3b8; /* Default grey for locked */
    margin-bottom: 0.4em; /* Reduced margin */
    transition: color 0.2s ease, text-shadow 0.2s ease;
}

.achievement-card.unlocked {
    background-color: var(--background-gradient-end);
    border-color: var(--accent-color);
    box-shadow: 0 3px 12px rgba(var(--warning-color-rgb), 0.2); /* Lighter shadow */
}

.achievement-card.unlocked i {
    color: var(--accent-color);
    text-shadow: 0 0 8px rgba(var(--warning-color-rgb), 0.5); /* Softer glow */
}

.achievement-card h4 {
    margin: 0.4em 0; /* Reduced margin */
    color: var(--primary-color);
    font-size: 1.1em; /* Slightly smaller font */
}

.achievement-card p {
    font-size: 0.85em; /* Slightly smaller font */
    opacity: 0.8;
}

/* --- Settings Section --- */
.setting-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.9em 0; /* Reduced padding */
    border-bottom: 1px dashed var(--border-color);
    flex-wrap: wrap; /* Allow wrapping */
    gap: 0.6em; /* Reduced gap */
}
/* Stack setting items on mobile */
@media (max-width: 550px) {
    .setting-item {
        flex-direction: column;
        align-items: flex-start;
    }
    .setting-item span { /* Label */
        width: 100%;
        text-align: left;
        margin-bottom: 0.4em;
    }
    .setting-item .input-field,
    .setting-item select,
    .setting-buttons-group { /* Control group */
        width: 100%;
        max-width: none;
        margin-left: 0; /* Override auto margin */
        justify-content: center; /* Center buttons within group */
        flex-wrap: wrap; /* Allow buttons to wrap */
    }
    .setting-buttons-group button,
    .setting-item #daily-reminder-time {
        width: 100%;
        max-width: none;
    }
}


.setting-item:last-of-type {
    border-bottom: none;
}

.setting-item span {
    font-size: 1em; /* Slightly smaller font */
    color: var(--text-color);
    flex-shrink: 0;
}

.setting-item .input-field, .setting-item select {
    margin-left: auto;
    flex-shrink: 0;
}
.setting-buttons-group {
    display: flex;
    gap: 0.6em; /* Reduced gap */
    flex-wrap: wrap;
    margin-left: auto;
}
.setting-buttons-group button {
    flex-shrink: 0;
}
.data-management-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 0.8em; /* Reduced gap */
    justify-content: center;
    margin-top: 1.5em; /* Reduced margin */
}
/* Make data management buttons full width on small screens */
@media (max-width: 500px) {
    .data-management-buttons {
        flex-direction: column;
        align-items: stretch;
    }
    .data-management-buttons button {
        width: 100%;
        max-width: none;
    }
}

#daily-reminder-time {
    width: 90px; /* Slightly smaller width */
}

hr {
    border: none;
    border-top: 1px solid var(--border-color);
    margin: 1.5em 0; /* Reduced margin */
}

/* --- Footer --- */
footer {
    text-align: center;
    padding: 1.5em; /* Reduced padding */
    margin-top: 2.5em; /* Reduced margin */
    background-color: var(--primary-color);
    color: var(--inverted-text-color);
    font-size: 0.85em; /* Slightly smaller font */
    box-shadow: 0 -3px 10px var(--shadow-medium);
    border-top-left-radius: 25px; /* Softer radius */
    border-top-right-radius: 25px;
}

/* --- Modals --- */
.modal {
    display: none; /* Crucially, modals are hidden by default */
    position: fixed;
    z-index: 200;
    left: 0; top: 0;
    width: 100%; height: 100%;
    overflow-y: auto; /* Allow internal scrolling if content overflows */
    background-color: var(--modal-bg);
    padding: 15px 0; /* Vertical padding for desktops */
    animation: fadeIn 0.3s ease-out;
    /* JS will apply display: flex when opened */
    align-items: center;
    justify-content: center;
}

.modal-content {
    background-color: var(--modal-content-bg);
    margin: auto;
    padding: 2.5em; /* Reduced padding */
    border: 1px solid var(--border-color);
    border-radius: 20px;
    width: 90%;
    max-width: 600px; /* Reduced max-width */
    box-shadow: 0 12px 30px var(--shadow-medium); /* Lighter shadow */
    position: relative;
    animation: slideInTop 0.35s ease-out; /* Slightly faster */
    color: var(--text-color);
    max-height: 90vh; /* Reduced max height */
    overflow-y: auto;
    display: flex;
    flex-direction: column;
}
.modal-content.modal-small {
    max-width: 400px; /* Smaller width for confirmation modal */
    padding: 2em;
}

/* Modals become full-screen on mobile */
@media (max-width: 768px) {
    .modal {
        padding: 0; /* No padding on container, modal takes full space */
    }
    .modal-content {
        width: 100%;
        min-height: 100vh; /* Occupy full screen height */
        border-radius: 0;
        padding: 1.2em; /* Reduced padding for content */
        margin: 0;
        box-shadow: none;
        max-height: unset; /* Remove max height constraint */
    }
    .modal-content.modal-small {
        min-height: unset; /* Restore min-height for small modal (e.g. confirmation) */
        border-radius: 10px;
        padding: 1.2em;
        max-width: 90%; /* Still limit width of small modals */
        margin: auto; /* Re-center small modals */
    }
}

.modal-content h2 {
    color: var(--primary-color);
    border-bottom: 2px solid var(--border-color);
    padding-bottom: 0.7em; /* Reduced padding */
    margin-bottom: 1.2em; /* Reduced margin */
    font-size: clamp(1.6em, 3.5vw, 2em); /* Slightly smaller max font size */
}

.modal-content h3 {
    font-size: clamp(1.2em, 2.5vw, 1.5em); /* Slightly smaller max font size */
    margin-top: 1.5em;
    margin-bottom: 1em;
}

.modal-content p {
    margin-bottom: 0.8em; /* Reduced margin */
    line-height: 1.6;
}

.modal-content textarea {
    width: calc(100% - 24px); /* Account for padding */
    min-height: 90px; /* Slightly smaller min-height */
    padding: 10px; /* Reduced padding */
    border: 1px solid var(--border-color);
    border-radius: 10px;
    font-size: 0.95em;
    line-height: 1.5;
    resize: vertical;
    margin-bottom: 1.2em; /* Reduced margin */
    background-color: var(--input-bg);
    color: var(--text-color);
    transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
}

.modal-content textarea:focus {
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px var(--secondary-color-alpha);
}

.modal-content button {
    margin-top: 1.2em; /* Reduced margin */
    width: auto;
    min-width: 140px;
    align-self: flex-end;
}
/* Ensure modal buttons go full width on mobile */
@media (max-width: 500px) {
    .modal-content button {
        width: 100%;
        max-width: none;
    }
    .modal-actions { /* Align buttons in modal actions as well */
        flex-direction: column;
        align-items: stretch;
    }
    .modal-actions button {
        width: 100%;
        max-width: none;
    }
}


.close-button {
    color: #888; /* Softer close button color */
    float: right;
    font-size: 36px; /* Slightly smaller */
    font-weight: bold;
    position: absolute;
    right: 20px; /* Reduced position */
    top: 12px; /* Reduced position */
    cursor: pointer;
    transition: color 0.2s ease;
}
/* Make close button more touch-friendly on mobile */
@media (max-width: 768px) {
    .close-button {
        font-size: 28px;
        right: 12px;
        top: 10px;
        background-color: var(--card-background); /* Give it a background for visibility */
        border-radius: 50%;
        width: 36px;
        height: 36px;
        display: flex; /* Use flex to center the X */
        align-items: center;
        justify-content: center;
        box-shadow: 0 1px 4px rgba(0,0,0,0.2);
    }
}

.close-button:hover {
    color: var(--primary-color);
}

.modal-actions {
    display: flex;
    justify-content: flex-end;
    gap: 1.2em; /* Reduced gap */
    margin-top: 1.5em; /* Reduced margin */
    flex-wrap: wrap;
}


/* Journal Modal Specifics */
.journal-meta {
    display: flex;
    flex-wrap: wrap;
    gap: 1.5em; /* Reduced gap */
    margin-bottom: 1.2em; /* Reduced margin */
    width: 100%;
}
/* Stack mood and energy trackers on very small screens */
@media (max-width: 500px) {
    .journal-meta {
        flex-direction: column;
        align-items: stretch; /* Stretch children to full width */
        text-align: left; /* Align text to left */
    }
    .mood-tracker, .energy-tracker {
        flex: 1 1 100%;
        min-width: unset;
    }
    .mood-emojis {
        justify-content: center; /* Center emojis when stacked */
    }
}
.mood-tracker h4, .energy-tracker h4 {
    margin-top: 0;
    margin-bottom: 0.6em; /* Reduced margin */
    color: var(--info-color); /* Info color for headings */
    font-size: 1.1em; /* Slightly smaller font */
}
.mood-emojis {
    display: flex;
    gap: 0.6em; /* Reduced gap */
    flex-wrap: wrap;
    justify-content: flex-start; /* Align left by default */
}
.mood-emojis .emoji {
    font-size: 2em; /* Slightly smaller */
    cursor: pointer;
    padding: 6px; /* Reduced padding */
    border-radius: 8px; /* Slightly less rounded */
    background-color: var(--input-bg);
    border: 1px solid var(--border-color);
    transition: transform 0.15s ease, background-color 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
    user-select: none;
    min-width: 40px;
    text-align: center;
}
.mood-emojis .emoji:hover {
    transform: scale(1.08); /* Softer scale */
    background-color: var(--background-gradient-end);
}
.mood-emojis .emoji.selected {
    background-color: var(--accent-color);
    border-color: var(--warning-hover);
    transform: scale(1.1); /* Softer scale */
    box-shadow: 0 0 10px rgba(var(--warning-color-rgb), 0.4); /* Softer glow */
    color: white;
}
.slider-energy {
    width: calc(100% - 50px); /* Adjusted width */
    vertical-align: middle;
    accent-color: var(--secondary-color);
    height: 7px; /* Slightly thinner */
    cursor: pointer;
    margin-right: 8px; /* Reduced margin */
}
#energy-value {
    vertical-align: middle;
    font-weight: bold;
    color: var(--primary-color);
}

/* Book Modal Specifics */
.book-modal-header {
    display: flex;
    gap: 1.2em; /* Reduced gap */
    align-items: flex-start;
    margin-bottom: 1.5em; /* Reduced margin */
    flex-wrap: wrap;
}
/* Center image and stack text on very small screens */
@media (max-width: 500px) {
    .book-modal-header {
        flex-direction: column;
        align-items: center;
        text-align: center;
    }
    .modal-book-cover {
        margin-bottom: 1em;
    }
}
.modal-book-cover {
    width: 100px; /* Reduced width */
    height: 150px; /* Reduced height */
    object-fit: cover;
    border-radius: 8px;
    box-shadow: 0 3px 10px rgba(0,0,0,0.15);
    flex-shrink: 0;
    border: 1px solid var(--border-color);
}
.book-info-text {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}
.book-modal-header h2 {
    margin-top: 0;
    font-size: 1.8em; /* Slightly smaller */
    border: none;
    padding: 0;
    margin-bottom: 0.4em; /* Reduced margin */
    color: var(--primary-color);
}
.book-modal-header p {
    margin: 0.2em 0; /* Reduced margin */
    font-size: 0.95em;
}
.book-rating .fa-star {
    color: #ccc;
    font-size: 1.4em; /* Slightly smaller */
    cursor: pointer;
    transition: color 0.15s ease, transform 0.1s ease;
}
.book-rating .fa-star:hover {
    transform: scale(1.08);
}
.book-rating .fa-star.active {
    color: var(--accent-color);
}
.book-modal-progress {
    margin-bottom: 1.5em; /* Reduced margin */
    padding-top: 1em;
    border-top: 1px dashed var(--border-color);
}
.page-input-group {
    display: flex;
    align-items: center;
    gap: 0.6em; /* Reduced gap */
    margin-bottom: 0.8em; /* Reduced margin */
    flex-wrap: wrap; /* Allow wrapping */
}
@media (max-width: 500px) {
    .page-input-group {
        flex-direction: column;
        align-items: stretch;
    }
    .page-input-group label {
        width: 100%;
        text-align: center;
    }
    .page-input-group input {
        width: 100%;
        max-width: none;
    }
}
.page-input-group label strong {
    font-size: 0.95em;
    color: var(--primary-color);
}
.page-input-group input {
    max-width: 80px; /* Reduced max-width */
    text-align: center;
}
.progress-bar-container {
    width: 100%;
    height: 8px;
    background-color: var(--progress-bar-bg);
    border-radius: 4px;
    overflow: hidden;
    margin-top: 0.6em; /* Reduced margin */
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
}
.progress-bar {
    height: 100%;
    background-color: var(--progress-bar-fill);
    width: 0%;
    border-radius: 4px;
    transition: width 0.4s ease;
}
.notes-list {
    margin-top: 1.2em; /* Reduced margin */
}
.notes-list .note-item {
    background-color: var(--background-gradient-start);
    padding: 12px; /* Reduced padding */
    margin-bottom: 8px; /* Reduced margin */
    border-radius: 8px;
    border: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    gap: 0.4em; /* Reduced gap */
    box-shadow: 0 1px 6px var(--shadow-light);
}
.notes-list .note-item:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 8px var(--shadow-medium);
}
.notes-list .note-item .note-content {
    flex-grow: 1;
    white-space: pre-wrap;
    word-break: break-word;
    font-size: 0.95em;
    color: var(--text-color);
}
.notes-list .note-item .note-date {
    font-size: 0.75em;
    color: var(--text-color);
    opacity: 0.7;
    text-align: right;
    width: 100%;
}
.notes-list .note-item .delete-note-btn {
    padding: 0.3em 0.6em;
    font-size: 0.75em;
    min-width: unset;
    margin-top: 0.4em;
    align-self: flex-end;
}

/* Interval Timer Modal Specifics */
.interval-step {
    display: flex;
    align-items: center;
    gap: 0.8em; /* Reduced gap */
    margin-bottom: 0.8em; /* Reduced margin */
    padding: 0.7em; /* Reduced padding */
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: var(--input-bg);
    flex-wrap: wrap;
}
/* Stack interval step inputs on small screens */
@media (max-width: 500px) {
    .interval-step {
        flex-direction: column;
        align-items: stretch;
    }
    .interval-step label {
        width: 100%;
        text-align: center;
    }
    .interval-step input, .interval-step select {
        width: 100%;
        max-width: none;
    }
    .interval-step .delete-step-btn {
        align-self: flex-end;
    }
}
.interval-step label {
    font-weight: bold;
    color: var(--primary-color);
    flex-shrink: 0;
    font-size: 0.9em;
}
.interval-step input[type="number"], .interval-step select {
    width: 70px; /* Reduced width */
    padding: 0.5em; /* Reduced padding */
    border-radius: 6px;
    flex-shrink: 0;
}
.interval-step .delete-step-btn {
    margin-left: auto;
    padding: 0.4em 0.7em;
    font-size: 0.85em;
}
#interval-timer-modal button {
    margin-top: 1.2em;
}
#add-interval-step {
    background-color: var(--info-color); /* Use info color for add step */
}
#start-interval-meditation {
    background-color: var(--secondary-color);
    margin-left: 0.8em; /* Reduced margin */
}

/* --- Toast Notifications --- */
#toast-container {
    position: fixed;
    top: 20px; /* Default top for desktop */
    right: 20px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 8px; /* Reduced gap */
}

/* Toast notifications repositioned to bottom on mobile */
@media (max-width: 768px) {
    #toast-container {
        top: unset; /* Remove top constraint */
        bottom: 15px; /* Position at bottom */
        right: 15px;
        left: 15px; /* Span full width (with padding) */
        align-items: center; /* Center toasts horizontally */
    }
    .toast {
        max-width: unset; /* Allow full width (minus container padding) */
        width: 100%; /* Ensure it takes full width */
        transform: translateY(120%); /* Slide up from bottom */
    }
    .toast.show {
        transform: translateY(0);
    }
    .toast.hide {
        transform: translateY(120%);
    }
}
/* Adjust toast position for landscape mode on mobile */
@media (max-width: 900px) and (orientation: landscape) {
    #toast-container {
        top: 15px; /* Move back to top-right in landscape */
        bottom: unset;
        left: unset;
        right: 15px;
        align-items: flex-end; /* Align to right */
    }
    .toast {
        transform: translateX(120%); /* Slide from right */
    }
}


.toast {
    background-color: var(--toast-bg);
    color: var(--toast-text);
    padding: 12px 16px; /* Reduced padding */
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    opacity: 0;
    transform: translateX(120%);
    transition: opacity 0.3s ease-out, transform 0.3s ease-out; /* Slightly faster transition */
    min-width: 250px;
    max-width: 350px;
    display: flex;
    align-items: center;
    gap: 10px; /* Reduced gap */
}

.toast.show {
    opacity: 1;
    transform: translateX(0);
}

.toast.hide {
    opacity: 0;
    transform: translateX(120%);
}

.toast i {
    font-size: 1.4em; /* Slightly smaller icon */
    color: var(--accent-color);
}
.toast.success i { color: var(--secondary-color); } /* Use secondary for success */
.toast.error i { color: var(--delete-color); }
.toast.info i { color: var(--primary-color); } /* Use primary for info */
.toast.warning i { color: var(--warning-color); }


/* --- Keyframe Animations --- */
@keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
@keyframes slideInTop { from { transform: translateY(-30px); opacity: 0; } to { transform: translateY(0); opacity: 1; } } /* Smaller slide */

/* --- General Responsive Adjustments --- */
/* Breakpoints:
   - Max-width 768px: General mobile (portrait & landscape tablet)
   - Max-width 600px: Smaller tablets & larger phones
   - Max-width 500px: Most smartphones
   - Max-width 450px: Very small smartphones
   - Max-width 400px: Extremely small smartphones */

/* General adjustments for tablet-sized screens (768px and below) */
@media (max-width: 768px) {
    .container {
        padding: 0 1em; /* Reduce horizontal padding */
    }
    header {
        padding: 1.5em 0 0.8em;
        border-bottom-left-radius: 15px;
        border-bottom-right-radius: 15px;
    }
    footer {
        padding: 1.2em;
        margin-top: 1.5em;
        border-top-left-radius: 15px;
        border-top-right-radius: 15px;
    }
    .card {
        padding: 1.8em; /* Further reduce card padding */
        border-radius: 12px;
    }
    h2 {
        font-size: clamp(1.4em, 5vw, 1.8em);
        margin-bottom: 0.8em;
        padding-bottom: 0.5em;
    }
    h3 {
        font-size: clamp(1.1em, 4vw, 1.4em);
        margin-top: 1.2em;
        margin-bottom: 0.8em;
        padding-bottom: 0.4em;
    }
    .card-description {
        font-size: 0.9em;
        margin-bottom: 1.2em;
    }
    .timer-display, .countdown-display { /* Apply to both timers */
        font-size: clamp(2.5em, 10vw, 3.5em);
        margin: 1em 0 1.2em;
        padding: 0.5em 0.6em;
    }
    .meditation-controls-group, .timer-controls, .countdown-controls { /* Apply to both timer controls */
        gap: 0.8em;
        margin-bottom: 1.2em;
        flex-direction: column; /* Stack controls on mobile */
        align-items: stretch;
    }
    .meditation-controls-group button, .timer-controls button, .countdown-controls button {
        width: 100%;
        max-width: none;
    }
    .preset-buttons { /* Still allow wrapping within the stacked column */
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.6em;
    }
    .preset-meditation-time {
        flex: 1 1 80px; /* Give some flexibility */
        max-width: 120px; /* Prevent over-stretching */
    }
    .input-field, select {
        font-size: 0.9em;
        padding: 0.8em 1em;
    }
    .small-input {
        width: 80px; /* Adjust width */
        padding: 0.7em 0.9em;
    }
}

/* Landscape orientation for mobile devices (up to 900px wide) */
@media (max-width: 900px) and (orientation: landscape) {
    .container {
        padding: 0 1.5em; /* Restore some padding for landscape */
    }
    .main-nav .container {
        flex-wrap: wrap; /* Allow wrapping in landscape for better use of space */
        justify-content: center;
        overflow-x: visible;
    }
    .app-section.active-section {
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /* Allow multiple columns again */
        gap: 1.5em;
    }
    .card {
        padding: 1.5em; /* Adjust card padding */
    }
    .modal-content {
        max-height: 90vh; /* Restrict height in landscape to prevent full-screen takeover */
        border-radius: 15px;
        margin: auto;
        padding: 1.8em;
        min-height: unset; /* Do not force full height */
    }
    .journal-meta, .book-modal-header {
        flex-direction: row; /* Allow side-by-side again if space permits */
        align-items: flex-start;
        text-align: left;
    }
    .mood-tracker, .energy-tracker {
        flex: 1 1 48%; /* Restore flex for side-by-side */
        min-width: unset;
    }
    .mood-emojis {
        justify-content: flex-start;
    }
    .book-modal-header .modal-book-cover {
        margin-bottom: 0; /* Remove bottom margin */
        margin-right: 1em; /* Add right margin */
        align-self: flex-start; /* Align to top left */
    }
    .timer-display, .countdown-display { /* Apply to both timers */
        font-size: clamp(3em, 6vw, 4.5em); /* Adjust font size */
    }
    .meditation-controls-group, .timer-controls, .countdown-controls { /* Apply to both timer controls */
        flex-direction: row; /* Restore row layout for controls */
        align-items: center;
        justify-content: center;
    }
    .meditation-controls-group button, .timer-controls button, .countdown-controls button {
        width: auto;
        max-width: 150px;
    }
    .custom-timer-input {
        flex-direction: row; /* Restore row layout */
        align-items: center;
    }
    .custom-timer-input .input-field {
        width: auto;
        max-width: 120px;
        text-align: center;
    }
    .custom-timer-input button {
        width: auto;
    }
    .custom-countdown-card .timer-input-group { /* Restore row layout for H:M:S */
        flex-direction: row;
        gap: 0.5em;
    }
    .custom-countdown-card .timer-input-group input {
        width: 50px; /* Restore fixed width */
        max-width: none;
    }
    .custom-countdown-card .timer-input-group .colon {
        display: inline; /* Show ":" again */
    }
    .book-input-area, .search-input-area, .goal-input-area, .setting-item {
        flex-direction: row; /* Restore row layout */
        align-items: center;
        flex-wrap: wrap;
    }
    .book-input-area .input-field, .search-input-area .input-field, .goal-input-area .input-field,
    .setting-item .input-field, .setting-item select {
        width: auto;
        max-width: unset;
    }
    .book-input-area #upload-book-cover-btn, .book-input-area #add-book,
    .search-input-area #clear-book-search, .goal-input-area button,
    .setting-buttons-group button {
        width: auto;
        max-width: unset;
        border-radius: 25px; /* Restore pill shape */
    }
    #daily-reminder-time {
        width: 90px;
    }
    #toast-container {
        top: 15px; /* Move back to top-right in landscape */
        bottom: unset;
        left: unset;
        right: 15px;
        align-items: flex-end; /* Align to right */
    }
    .toast {
        transform: translateX(120%); /* Slide from right */
    }
}

--- END FILE: style.css ---

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------

do the following : 

1. fix the responsiveness and appearance of the stopwatch and timer section. they are overriding above each other. please fix that. it's not looking good.
2. guide me all the way.